{
  "pkgs.agdaPackages.callPackage": null,
  "pkgs.agdaPackages.mkDerivation": null,
  "pkgs.agdaPackages.mkLibraryFile": null,
  "pkgs.agdaPackages.newScope": null,
  "pkgs.agdaPackages.override": null,
  "pkgs.agdaPackages.overrideDerivation": null,
  "pkgs.agdaPackages.overrideScope": null,
  "pkgs.agdaPackages.packages": null,
  "pkgs.appimageTools.extract": null,
  "pkgs.appimageTools.extractType1": null,
  "pkgs.appimageTools.extractType2": null,
  "pkgs.appimageTools.override": null,
  "pkgs.appimageTools.overrideDerivation": null,
  "pkgs.appimageTools.wrapAppImage": null,
  "pkgs.appimageTools.wrapType1": null,
  "pkgs.appimageTools.wrapType2": null,
  "pkgs.appimageTools.defaultFhsEnvArgs.multiPkgs": "https://github.com/AppImage/pkg2appimage/blob/master/excludelist",
  "pkgs.appimageTools.defaultFhsEnvArgs.targetPkgs": "Most of the packages were taken from the Steam chroot",
  "pkgs.beamPackages.__unfix__": null,
  "pkgs.beamPackages.buildErlangMk": null,
  "pkgs.beamPackages.buildHex": null,
  "pkgs.beamPackages.buildMix": null,
  "pkgs.beamPackages.buildRebar3": null,
  "pkgs.beamPackages.callPackage": null,
  "pkgs.beamPackages.extend": null,
  "pkgs.beamPackages.fetchHex": null,
  "pkgs.beamPackages.fetchMixDeps": null,
  "pkgs.beamPackages.fetchRebar3Deps": null,
  "pkgs.beamPackages.mixRelease": null,
  "pkgs.beamPackages.override": null,
  "pkgs.beamPackages.overrideDerivation": null,
  "pkgs.beamPackages.rebar3Relx": null,
  "pkgs.beamPackages.rebar3WithPlugins": null,
  "pkgs.beamPackages.beamPackages.__unfix__": null,
  "pkgs.beamPackages.beamPackages.buildErlangMk": null,
  "pkgs.beamPackages.beamPackages.buildHex": null,
  "pkgs.beamPackages.beamPackages.buildMix": null,
  "pkgs.beamPackages.beamPackages.buildRebar3": null,
  "pkgs.beamPackages.beamPackages.callPackage": null,
  "pkgs.beamPackages.beamPackages.extend": null,
  "pkgs.beamPackages.beamPackages.fetchHex": null,
  "pkgs.beamPackages.beamPackages.fetchMixDeps": null,
  "pkgs.beamPackages.beamPackages.fetchRebar3Deps": null,
  "pkgs.beamPackages.beamPackages.mixRelease": null,
  "pkgs.beamPackages.beamPackages.rebar3Relx": null,
  "pkgs.beamPackages.beamPackages.rebar3WithPlugins": null,
  "pkgs.beamPackages.buildErlangMk.override": null,
  "pkgs.beamPackages.buildHex.override": null,
  "pkgs.beamPackages.buildMix.override": null,
  "pkgs.beamPackages.buildRebar3.override": null,
  "pkgs.beamPackages.fetchHex.override": null,
  "pkgs.beamPackages.fetchMixDeps.override": null,
  "pkgs.beamPackages.fetchRebar3Deps.override": null,
  "pkgs.beamPackages.mixRelease.override": null,
  "pkgs.beamPackages.rebar3Relx.override": null,
  "pkgs.beamPackages.beamPackages.buildErlangMk.override": null,
  "pkgs.beamPackages.beamPackages.buildHex.override": null,
  "pkgs.beamPackages.beamPackages.buildMix.override": null,
  "pkgs.beamPackages.beamPackages.buildRebar3.override": null,
  "pkgs.beamPackages.beamPackages.fetchHex.override": null,
  "pkgs.beamPackages.beamPackages.fetchMixDeps.override": null,
  "pkgs.beamPackages.beamPackages.fetchRebar3Deps.override": null,
  "pkgs.beamPackages.beamPackages.mixRelease.override": null,
  "pkgs.beamPackages.beamPackages.rebar3Relx.override": null,
  "builtins.abort": "Abort Nix expression evaluation and print the error message *s*.",
  "builtins.add": "Return the sum of the numbers *e1* and *e2*.",
  "builtins.addDrvOutputDependencies": "Create a copy of the given string where a single\n[constant](@docroot@/language/string-context.md#string-context-element-constant)\nstring context element is turned into a\n[derivation deep](@docroot@/language/string-context.md#string-context-element-derivation-deep)\nstring context element.\n\nThe store path that is the constant string context element should point to a valid derivation, and end in `.drv`.\n\nThe original string context element must not be empty or have multiple elements, and it must not have any other type of element other than a constant or derivation deep element.\nThe latter is supported so this function is idempotent.\n\nThis is the opposite of [`builtins.unsafeDiscardOutputDependency`](#builtins-unsafeDiscardOutputDependency).",
  "builtins.addErrorContext": null,
  "builtins.all": "\nReturn true if function `pred` returns true for all elements of\n`list`.\n\n# Inputs\n\n`pred`\n\n: Predicate\n\n`list`\n\n: Input list\n\n# Type\n\n```\nall :: (a -> bool) -> [a] -> bool\n```\n\n# Examples\n:::{.example}\n## `lib.lists.all` usage example\n\n```nix\nall (x: x < 3) [ 1 2 ]\n=> true\nall (x: x < 3) [ 1 2 3 ]\n=> false\n```\n\n:::\n",
  "builtins.any": "\nReturn true if function `pred` returns true for at least one\nelement of `list`.\n\n# Inputs\n\n`pred`\n\n: Predicate\n\n`list`\n\n: Input list\n\n# Type\n\n```\nany :: (a -> bool) -> [a] -> bool\n```\n\n# Examples\n:::{.example}\n## `lib.lists.any` usage example\n\n```nix\nany isString [ 1 \"a\" { } ]\n=> true\nany isString [ 1 { } ]\n=> false\n```\n\n:::\n",
  "builtins.appendContext": null,
  "builtins.attrNames": "Return the names of the attributes in the set *set* in an\nalphabetically sorted list. For instance, `builtins.attrNames { y\n= 1; x = \"foo\"; }` evaluates to `[ \"x\" \"y\" ]`.",
  "builtins.attrValues": "\nReturn the values of all attributes in the given set, sorted by\nattribute name.\n\n# Type\n\n```\nattrValues :: AttrSet -> [Any]\n```\n\n# Examples\n:::{.example}\n## `lib.attrsets.attrValues` usage example\n\n```nix\nattrValues {c = 3; a = 1; b = 2;}\n=> [1 2 3]\n```\n\n:::\n",
  "builtins.baseNameOf": "Return the *base name* of either a [path value](@docroot@/language/types.md#type-path) *x* or a string *x*, depending on which type is passed, and according to the following rules.\n\nFor a path value, the *base name* is considered to be the part of the path after the last directory separator, including any file extensions.\nThis is the simple case, as path values don't have trailing slashes.\n\nWhen the argument is a string, a more involved logic applies. If the string ends with a `/`, only this one final slash is removed.\n\nAfter this, the *base name* is returned as previously described, assuming `/` as the directory separator. (Note that evaluation must be platform independent.)\n\nThis is somewhat similar to the [GNU `basename`](https://www.gnu.org/software/coreutils/manual/html_node/basename-invocation.html) command, but GNU `basename` will strip any number of trailing slashes.",
  "builtins.bitAnd": "Return the bitwise AND of the integers *e1* and *e2*.",
  "builtins.bitOr": "Return the bitwise OR of the integers *e1* and *e2*.",
  "builtins.bitXor": "Return the bitwise XOR of the integers *e1* and *e2*.",
  "builtins.break": "In debug mode (enabled using `--debugger`), pause Nix expression evaluation and enter the REPL.\nOtherwise, return the argument `v`.",
  "builtins.catAttrs": "\nCollect each attribute named `attr` from a list of attribute\nsets.  Sets that don't contain the named attribute are ignored.\n\n# Inputs\n\n`attr`\n\n: The attribute name to get out of the sets.\n\n`list`\n\n: The list of attribute sets to go through\n\n# Type\n\n```\ncatAttrs :: String -> [AttrSet] -> [Any]\n```\n\n# Examples\n:::{.example}\n## `lib.attrsets.catAttrs` usage example\n\n```nix\ncatAttrs \"a\" [{a = 1;} {b = 0;} {a = 2;}]\n=> [1 2]\n```\n\n:::\n",
  "builtins.ceil": "Converts an IEEE-754 double-precision floating-point number (*double*) to\nthe next higher integer.\n\nIf the datatype is neither an integer nor a \"float\", an evaluation error will be\nthrown.",
  "builtins.compareVersions": "Compare two strings representing versions and return `-1` if\nversion *s1* is older than version *s2*, `0` if they are the same,\nand `1` if *s1* is newer than *s2*. The version comparison\nalgorithm is the same as the one used by [`nix-env\n-u`](../command-ref/nix-env.md#operation---upgrade).",
  "builtins.concatLists": "Concatenate a list of lists into a single list.",
  "builtins.concatMap": "\nMap and concatenate the result.\n\n# Type\n\n```\nconcatMap :: (a -> [b]) -> [a] -> [b]\n```\n\n# Examples\n:::{.example}\n## `lib.lists.concatMap` usage example\n\n```nix\nconcatMap (x: [x] ++ [\"z\"]) [\"a\" \"b\"]\n=> [ \"a\" \"z\" \"b\" \"z\" ]\n```\n\n:::\n",
  "builtins.concatStringsSep": "\nConcatenate a list of strings with a separator between each element\n\n# Inputs\n\n`sep`\n: Separator to add between elements\n\n`list`\n: List of input strings\n\n# Type\n\n```\nconcatStringsSep :: string -> [string] -> string\n```\n\n# Examples\n:::{.example}\n## `lib.strings.concatStringsSep` usage example\n\n```nix\nconcatStringsSep \"/\" [\"usr\" \"local\" \"bin\"]\n=> \"usr/local/bin\"\n```\n\n:::\n",
  "builtins.convertHash": "Return the specified representation of a hash string, based on the attributes presented in *args*:\n\n- `hash`\n\n  The hash to be converted.\n  The hash format is detected automatically.\n\n- `hashAlgo`\n\n  The algorithm used to create the hash. Must be one of\n  - `\"md5\"`\n  - `\"sha1\"`\n  - `\"sha256\"`\n  - `\"sha512\"`\n\n  The attribute may be omitted when `hash` is an [SRI hash](https://www.w3.org/TR/SRI/#the-integrity-attribute) or when the hash is prefixed with the hash algorithm name followed by a colon.\n  That `<hashAlgo>:<hashBody>` syntax is supported for backwards compatibility with existing tooling.\n\n- `toHashFormat`\n\n  The format of the resulting hash. Must be one of\n  - `\"base16\"`\n  - `\"nix32\"`\n  - `\"base32\"` (deprecated alias for `\"nix32\"`)\n  - `\"base64\"`\n  - `\"sri\"`\n\nThe result hash is the *toHashFormat* representation of the hash *hash*.\n\n> **Example**\n>\n>   Convert a SHA256 hash in Base16 to SRI:\n>\n> ```nix\n> builtins.convertHash {\n>   hash = \"e3b0c44298fc1c149afbf4c8996fb92427ae41e4649b934ca495991b7852b855\";\n>   toHashFormat = \"sri\";\n>   hashAlgo = \"sha256\";\n> }\n> ```\n>\n>     \"sha256-47DEQpj8HBSa+/TImW+5JCeuQeRkm5NMpJWZG3hSuFU=\"\n\n> **Example**\n>\n>   Convert a SHA256 hash in SRI to Base16:\n>\n> ```nix\n> builtins.convertHash {\n>   hash = \"sha256-47DEQpj8HBSa+/TImW+5JCeuQeRkm5NMpJWZG3hSuFU=\";\n>   toHashFormat = \"base16\";\n> }\n> ```\n>\n>     \"e3b0c44298fc1c149afbf4c8996fb92427ae41e4649b934ca495991b7852b855\"\n\n> **Example**\n>\n>   Convert a hash in the form `<hashAlgo>:<hashBody>` in Base16 to SRI:\n>\n> ```nix\n> builtins.convertHash {\n>   hash = \"sha256:e3b0c44298fc1c149afbf4c8996fb92427ae41e4649b934ca495991b7852b855\";\n>   toHashFormat = \"sri\";\n> }\n> ```\n>\n>     \"sha256-47DEQpj8HBSa+/TImW+5JCeuQeRkm5NMpJWZG3hSuFU=\"",
  "builtins.deepSeq": "This is like `seq e1 e2`, except that *e1* is evaluated *deeply*:\nif it’s a list or set, its elements or attributes are also\nevaluated recursively.",
  "builtins.derivation": null,
  "builtins.derivationStrict": null,
  "builtins.dirOf": "Return the directory part of the string *s*, that is, everything\nbefore the final slash in the string. This is similar to the GNU\n`dirname` command.",
  "builtins.div": "Return the quotient of the numbers *e1* and *e2*.",
  "builtins.elem": "Return `true` if a value equal to *x* occurs in the list *xs*, and\n`false` otherwise.",
  "builtins.elemAt": "Return element *n* from the list *xs*. Elements are counted starting\nfrom 0. A fatal error occurs if the index is out of bounds.",
  "builtins.fetchGit": "Fetch a path from git. *args* can be a URL, in which case the HEAD\nof the repo at that URL is fetched. Otherwise, it can be an\nattribute with the following attributes (all except `url` optional):\n\n- `url`\n\n  The URL of the repo.\n\n- `name` (default: `source`)\n\n  The name of the directory the repo should be exported to in the store.\n\n- `rev` (default: *the tip of `ref`*)\n\n  The [Git revision] to fetch.\n  This is typically a commit hash.\n\n  [Git revision]: https://git-scm.com/docs/git-rev-parse#_specifying_revisions\n\n- `ref` (default: `HEAD`)\n\n  The [Git reference] under which to look for the requested revision.\n  This is often a branch or tag name.\n\n  [Git reference]: https://git-scm.com/book/en/v2/Git-Internals-Git-References\n\n  This option has no effect once `shallow` cloning is enabled.\n\n  By default, the `ref` value is prefixed with `refs/heads/`.\n  As of 2.3.0, Nix will not prefix `refs/heads/` if `ref` starts with `refs/`.\n\n- `submodules` (default: `false`)\n\n  A Boolean parameter that specifies whether submodules should be checked out.\n\n- `exportIgnore` (default: `true`)\n\n  A Boolean parameter that specifies whether `export-ignore` from `.gitattributes` should be applied.\n  This approximates part of the `git archive` behavior.\n\n  Enabling this option is not recommended because it is unknown whether the Git developers commit to the reproducibility of `export-ignore` in newer Git versions.\n\n- `shallow` (default: `false`)\n\n  Make a shallow clone when fetching the Git tree.\n  When this is enabled, the options `ref` and `allRefs` have no effect anymore.\n\n- `lfs` (default: `false`)\n\n  A boolean that when `true` specifies that [Git LFS] files should be fetched.\n\n  [Git LFS]: https://git-lfs.com/\n\n- `allRefs`\n\n  Whether to fetch all references (eg. branches and tags) of the repository.\n  With this argument being true, it's possible to load a `rev` from *any* `ref`.\n  (by default only `rev`s from the specified `ref` are supported).\n\n  This option has no effect once `shallow` cloning is enabled.\n\n- `verifyCommit` (default: `true` if `publicKey` or `publicKeys` are provided, otherwise `false`)\n\n  Whether to check `rev` for a signature matching `publicKey` or `publicKeys`.\n  If `verifyCommit` is enabled, then `fetchGit` cannot use a local repository with uncommitted changes.\n  Requires the [`verified-fetches` experimental feature](@docroot@/development/experimental-features.md#xp-feature-verified-fetches).\n\n- `publicKey`\n\n  The public key against which `rev` is verified if `verifyCommit` is enabled.\n  Requires the [`verified-fetches` experimental feature](@docroot@/development/experimental-features.md#xp-feature-verified-fetches).\n\n- `keytype` (default: `\"ssh-ed25519\"`)\n\n  The key type of `publicKey`.\n  Possible values:\n  - `\"ssh-dsa\"`\n  - `\"ssh-ecdsa\"`\n  - `\"ssh-ecdsa-sk\"`\n  - `\"ssh-ed25519\"`\n  - `\"ssh-ed25519-sk\"`\n  - `\"ssh-rsa\"`\n  Requires the [`verified-fetches` experimental feature](@docroot@/development/experimental-features.md#xp-feature-verified-fetches).\n\n- `publicKeys`\n\n  The public keys against which `rev` is verified if `verifyCommit` is enabled.\n  Must be given as a list of attribute sets with the following form:\n\n  ```nix\n  {\n    key = \"<public key>\";\n    type = \"<key type>\"; # optional, default: \"ssh-ed25519\"\n  }\n  ```\n\n  Requires the [`verified-fetches` experimental feature](@docroot@/development/experimental-features.md#xp-feature-verified-fetches).\n\n\nHere are some examples of how to use `fetchGit`.\n\n  - To fetch a private repository over SSH:\n\n    ```nix\n    builtins.fetchGit {\n      url = \"git@github.com:my-secret/repository.git\";\n      ref = \"master\";\n      rev = \"adab8b916a45068c044658c4158d81878f9ed1c3\";\n    }\n    ```\n\n  - To fetch an arbitrary reference:\n\n    ```nix\n    builtins.fetchGit {\n      url = \"https://github.com/NixOS/nix.git\";\n      ref = \"refs/heads/0.5-release\";\n    }\n    ```\n\n  - If the revision you're looking for is in the default branch of\n    the git repository you don't strictly need to specify the branch\n    name in the `ref` attribute.\n\n    However, if the revision you're looking for is in a future\n    branch for the non-default branch you will need to specify the\n    the `ref` attribute as well.\n\n    ```nix\n    builtins.fetchGit {\n      url = \"https://github.com/nixos/nix.git\";\n      rev = \"841fcbd04755c7a2865c51c1e2d3b045976b7452\";\n      ref = \"1.11-maintenance\";\n    }\n    ```\n\n    > **Note**\n    >\n    > It is nice to always specify the branch which a revision\n    > belongs to. Without the branch being specified, the fetcher\n    > might fail if the default branch changes. Additionally, it can\n    > be confusing to try a commit from a non-default branch and see\n    > the fetch fail. If the branch is specified the fault is much\n    > more obvious.\n\n  - If the revision you're looking for is in the default branch of\n    the git repository you may omit the `ref` attribute.\n\n    ```nix\n    builtins.fetchGit {\n      url = \"https://github.com/nixos/nix.git\";\n      rev = \"841fcbd04755c7a2865c51c1e2d3b045976b7452\";\n    }\n    ```\n\n  - To fetch a specific tag:\n\n    ```nix\n    builtins.fetchGit {\n      url = \"https://github.com/nixos/nix.git\";\n      ref = \"refs/tags/1.9\";\n    }\n    ```\n\n  - To fetch the latest version of a remote branch:\n\n    ```nix\n    builtins.fetchGit {\n      url = \"ssh://git@github.com/nixos/nix.git\";\n      ref = \"master\";\n    }\n    ```\n\n  - To verify the commit signature:\n\n    ```nix\n    builtins.fetchGit {\n      url = \"ssh://git@github.com/nixos/nix.git\";\n      verifyCommit = true;\n      publicKeys = [\n          {\n            type = \"ssh-ed25519\";\n            key = \"AAAAC3NzaC1lZDI1NTE5AAAAIArPKULJOid8eS6XETwUjO48/HKBWl7FTCK0Z//fplDi\";\n          }\n      ];\n    }\n    ```\n\n    Nix will refetch the branch according to the [`tarball-ttl`](@docroot@/command-ref/conf-file.md#conf-tarball-ttl) setting.\n\n    This behavior is disabled in [pure evaluation mode](@docroot@/command-ref/conf-file.md#conf-pure-eval).\n\n  - To fetch the content of a checked-out work directory:\n\n    ```nix\n    builtins.fetchGit ./work-dir\n    ```\n\nIf the URL points to a local directory, and no `ref` or `rev` is\ngiven, `fetchGit` will use the current content of the checked-out\nfiles, even if they are not committed or added to Git's index. It will\nonly consider files added to the Git repository, as listed by `git ls-files`.",
  "builtins.fetchMercurial": null,
  "builtins.fetchTarball": "Download the specified URL, unpack it and return the path of the\nunpacked tree. The file must be a tape archive (`.tar`) compressed\nwith `gzip`, `bzip2` or `xz`. If the tarball consists of a\nsingle directory, then the top-level path component of the files\nin the tarball is removed. The typical use of the function is to\nobtain external Nix expression dependencies, such as a\nparticular version of Nixpkgs, e.g.\n\n```nix\nwith import (fetchTarball https://github.com/NixOS/nixpkgs/archive/nixos-14.12.tar.gz) {};\n\nstdenv.mkDerivation { … }\n```\n\nThe fetched tarball is cached for a certain amount of time (1\nhour by default) in `~/.cache/nix/tarballs/`. You can change the\ncache timeout either on the command line with `--tarball-ttl`\n*number-of-seconds* or in the Nix configuration file by adding\nthe line `tarball-ttl = ` *number-of-seconds*.\n\nNote that when obtaining the hash with `nix-prefetch-url` the\noption `--unpack` is required.\n\nThis function can also verify the contents against a hash. In that\ncase, the function takes a set instead of a URL. The set requires\nthe attribute `url` and the attribute `sha256`, e.g.\n\n```nix\nwith import (fetchTarball {\n  url = \"https://github.com/NixOS/nixpkgs/archive/nixos-14.12.tar.gz\";\n  sha256 = \"1jppksrfvbk5ypiqdz4cddxdl8z6zyzdb2srq8fcffr327ld5jj2\";\n}) {};\n\nstdenv.mkDerivation { … }\n```\n\nNot available in [restricted evaluation mode](@docroot@/command-ref/conf-file.md#conf-restrict-eval).",
  "builtins.fetchTree": "Fetch a file system tree or a plain file using one of the supported backends and return an attribute set with:\n\n - the resulting fixed-output [store path](@docroot@/store/store-path.md)\n - the corresponding [NAR](@docroot@/store/file-system-object/content-address.md#serial-nix-archive) hash\n - backend-specific metadata (currently not documented). <!-- TODO: document output attributes -->\n\n *input* must be an attribute set with the following attributes:\n\n - `type` (String, required)\n\n   One of the [supported source types](#source-types).\n   This determines other required and allowed input attributes.\n\n - `narHash` (String, optional)\n\n   The `narHash` parameter can be used to substitute the source of the tree.\n   It also allows for verification of tree contents that may not be provided by the underlying transfer mechanism.\n   If `narHash` is set, the source is first looked up is the Nix store and [substituters](@docroot@/command-ref/conf-file.md#conf-substituters), and only fetched if not available.\n\n A subset of the output attributes of `fetchTree` can be re-used for subsequent calls to `fetchTree` to produce the same result again.\n That is, `fetchTree` is idempotent.\n\n Downloads are cached in `$XDG_CACHE_HOME/nix`.\n The remote source will be fetched from the network if both are true:\n - A NAR hash is supplied and the corresponding store path is not [valid](@docroot@/glossary.md#gloss-validity), that is, not available in the store\n\n   > **Note**\n   >\n   > [Substituters](@docroot@/command-ref/conf-file.md#conf-substituters) are not used in fetching.\n\n - There is no cache entry or the cache entry is older than [`tarball-ttl`](@docroot@/command-ref/conf-file.md#conf-tarball-ttl)\n\n ## Source types\n\n The following source types and associated input attributes are supported.\n\n <!-- TODO: It would be soooo much more predictable to work with (and\n document) if `fetchTree` was a curried call with the first parameter for\n `type` or an attribute like `builtins.fetchTree.git`! -->\n\n - `\"file\"`\n\n   Place a plain file into the Nix store.\n   This is similar to [`builtins.fetchurl`](@docroot@/language/builtins.md#builtins-fetchurl)\n\n   - `url` (String, required)\n\n     Supported protocols:\n\n     - `https`\n\n       > **Example**\n       >\n       > ```nix\n       > fetchTree {\n       >   type = \"file\";\n       >   url = \"https://example.com/index.html\";\n       > }\n       > ```\n\n     - `http`\n\n       Insecure HTTP transfer for legacy sources.\n\n       > **Warning**\n       >\n       > HTTP performs no encryption or authentication.\n       > Use a `narHash` known in advance to ensure the output has expected contents.\n\n     - `file`\n\n       A file on the local file system.\n\n       > **Example**\n       >\n       > ```nix\n       > fetchTree {\n       >   type = \"file\";\n       >   url = \"file:///home/eelco/nix/README.md\";\n       > }\n       > ```\n\n - `\"tarball\"`\n\n   Download a tar archive and extract it into the Nix store.\n   This has the same underyling implementation as [`builtins.fetchTarball`](@docroot@/language/builtins.md#builtins-fetchTarball)\n\n   - `url` (String, required)\n\n      > **Example**\n      >\n      > ```nix\n      > fetchTree {\n      >   type = \"tarball\";\n      >   url = \"https://github.com/NixOS/nixpkgs/tarball/nixpkgs-23.11\";\n      > }\n      > ```\n\n - `\"git\"`\n\n   Fetch a Git tree and copy it to the Nix store.\n   This is similar to [`builtins.fetchGit`](@docroot@/language/builtins.md#builtins-fetchGit).\n\n   - `url` (String, required)\n\n     The URL formats supported are the same as for Git itself.\n\n     > **Example**\n     >\n     > ```nix\n     > fetchTree {\n     >   type = \"git\";\n     >   url = \"git@github.com:NixOS/nixpkgs.git\";\n     > }\n     > ```\n\n     > **Note**\n     >\n     > If the URL points to a local directory, and no `ref` or `rev` is given, Nix will only consider files added to the Git index, as listed by `git ls-files` but use the *current file contents* of the Git working directory.\n\n   - `ref` (String, optional)\n\n     By default, this has no effect. This becomes relevant only once `shallow` cloning is disabled.\n\n     A [Git reference](https://git-scm.com/book/en/v2/Git-Internals-Git-References), such as a branch or tag name.\n\n     Default: `\"HEAD\"`\n\n   - `rev` (String, optional)\n\n     A Git revision; a commit hash.\n\n     Default: the tip of `ref`\n\n   - `shallow` (Bool, optional)\n\n     Make a shallow clone when fetching the Git tree.\n     When this is enabled, the options `ref` and `allRefs` have no effect anymore.\n\n     Default: `true`\n\n   - `submodules` (Bool, optional)\n\n     Also fetch submodules if available.\n\n     Default: `false`\n\n   - `lfs` (Bool, optional)\n\n     Fetch any [Git LFS](https://git-lfs.com/) files.\n\n     Default: `false`\n\n   - `allRefs` (Bool, optional)\n\n     By default, this has no effect. This becomes relevant only once `shallow` cloning is disabled.\n\n     Whether to fetch all references (eg. branches and tags) of the repository.\n     With this argument being true, it's possible to load a `rev` from *any* `ref`.\n     (Without setting this option, only `rev`s from the specified `ref` are supported).\n\n     Default: `false`\n\n   - `lastModified` (Integer, optional)\n\n     Unix timestamp of the fetched commit.\n\n     If set, pass through the value to the output attribute set.\n     Otherwise, generated from the fetched Git tree.\n\n   - `revCount` (Integer, optional)\n\n     Number of revisions in the history of the Git repository before the fetched commit.\n\n     If set, pass through the value to the output attribute set.\n     Otherwise, generated from the fetched Git tree.\n\n The following input types are still subject to change:\n\n - `\"path\"`\n - `\"github\"`\n - `\"gitlab\"`\n - `\"sourcehut\"`\n - `\"mercurial\"`\n\n*input* can also be a [URL-like reference](@docroot@/command-ref/new-cli/nix3-flake.md#flake-references).\nThe additional input types and the URL-like syntax requires the [`flakes` experimental feature](@docroot@/development/experimental-features.md#xp-feature-flakes) to be enabled.\n\n > **Example**\n >\n > Fetch a GitHub repository using the attribute set representation:\n >\n > ```nix\n > builtins.fetchTree {\n >   type = \"github\";\n >   owner = \"NixOS\";\n >   repo = \"nixpkgs\";\n >   rev = \"ae2e6b3958682513d28f7d633734571fb18285dd\";\n > }\n > ```\n >\n > This evaluates to the following attribute set:\n >\n > ```nix\n > {\n >   lastModified = 1686503798;\n >   lastModifiedDate = \"20230611171638\";\n >   narHash = \"sha256-rA9RqKP9OlBrgGCPvfd5HVAXDOy8k2SmPtB/ijShNXc=\";\n >   outPath = \"/nix/store/l5m6qlvfs9sdw14ja3qbzpglcjlb6j1x-source\";\n >   rev = \"ae2e6b3958682513d28f7d633734571fb18285dd\";\n >   shortRev = \"ae2e6b3\";\n > }\n > ```\n\n > **Example**\n >\n > Fetch the same GitHub repository using the URL-like syntax:\n >\n >   ```nix\n >   builtins.fetchTree \"github:NixOS/nixpkgs/ae2e6b3958682513d28f7d633734571fb18285dd\"\n >   ```",
  "builtins.fetchurl": "Download the specified URL and return the path of the downloaded file.\n`arg` can be either a string denoting the URL, or an attribute set with the following attributes:\n\n- `url`\n\n  The URL of the file to download.\n\n- `name` (default: the last path component of the URL)\n\n  A name for the file in the store. This can be useful if the URL has any\n  characters that are invalid for the store.\n\nNot available in [restricted evaluation mode](@docroot@/command-ref/conf-file.md#conf-restrict-eval).",
  "builtins.filter": "Return a list consisting of the elements of *list* for which the\nfunction *f* returns `true`.",
  "builtins.filterSource": "> **Warning**\n>\n> `filterSource` should not be used to filter store paths. Since\n> `filterSource` uses the name of the input directory while naming\n> the output directory, doing so will produce a directory name in\n> the form of `<hash2>-<hash>-<name>`, where `<hash>-<name>` is\n> the name of the input directory. Since `<hash>` depends on the\n> unfiltered directory, the name of the output directory will\n> indirectly depend on files that are filtered out by the\n> function. This will trigger a rebuild even when a filtered out\n> file is changed. Use `builtins.path` instead, which allows\n> specifying the name of the output directory.\n\nThis function allows you to copy sources into the Nix store while\nfiltering certain files. For instance, suppose that you want to use\nthe directory `source-dir` as an input to a Nix expression, e.g.\n\n```nix\nstdenv.mkDerivation {\n  ...\n  src = ./source-dir;\n}\n```\n\nHowever, if `source-dir` is a Subversion working copy, then all\nthose annoying `.svn` subdirectories will also be copied to the\nstore. Worse, the contents of those directories may change a lot,\ncausing lots of spurious rebuilds. With `filterSource` you can\nfilter out the `.svn` directories:\n\n```nix\nsrc = builtins.filterSource\n  (path: type: type != \"directory\" || baseNameOf path != \".svn\")\n  ./source-dir;\n```\n\nThus, the first argument *e1* must be a predicate function that is\ncalled for each regular file, directory or symlink in the source\ntree *e2*. If the function returns `true`, the file is copied to the\nNix store, otherwise it is omitted. The function is called with two\narguments. The first is the full path of the file. The second is a\nstring that identifies the type of the file, which is either\n`\"regular\"`, `\"directory\"`, `\"symlink\"` or `\"unknown\"` (for other\nkinds of files such as device nodes or fifos — but note that those\ncannot be copied to the Nix store, so if the predicate returns\n`true` for them, the copy will fail). If you exclude a directory,\nthe entire corresponding subtree of *e2* will be excluded.",
  "builtins.findFile": "Find *lookup-path* in *search-path*.\n\n[Lookup path](@docroot@/language/constructs/lookup-path.md) expressions are [desugared](https://en.wikipedia.org/wiki/Syntactic_sugar) using this and [`builtins.nixPath`](#builtins-nixPath):\n\n```nix\n<nixpkgs>\n```\n\nis equivalent to:\n\n```nix\nbuiltins.findFile builtins.nixPath \"nixpkgs\"\n```\n\nA search path is represented as a list of [attribute sets](./types.md#attribute-set) with two attributes:\n- `prefix` is a relative path.\n- `path` denotes a file system location\n\nExamples of search path attribute sets:\n\n- ```\n  {\n    prefix = \"\";\n    path = \"/nix/var/nix/profiles/per-user/root/channels\";\n  }\n  ```\n- ```\n  {\n    prefix = \"nixos-config\";\n    path = \"/etc/nixos/configuration.nix\";\n  }\n  ```\n- ```\n  {\n    prefix = \"nixpkgs\";\n    path = \"https://github.com/NixOS/nixpkgs/tarballs/master\";\n  }\n  ```\n- ```\n  {\n    prefix = \"nixpkgs\";\n    path = \"channel:nixpkgs-unstable\";\n  }\n  ```\n- ```\n  {\n    prefix = \"flake-compat\";\n    path = \"flake:github:edolstra/flake-compat\";\n  }\n  ```\n\nThe lookup algorithm checks each entry until a match is found, returning a [path value](@docroot@/language/types.md#type-path) of the match:\n\n- If a prefix of `lookup-path` matches `prefix`, then the remainder of *lookup-path* (the \"suffix\") is searched for within the directory denoted by `path`.\n  The contents of `path` may need to be downloaded at this point to look inside.\n\n- If the suffix is found inside that directory, then the entry is a match.\n  The combined absolute path of the directory (now downloaded if need be) and the suffix is returned.\n\n> **Example**\n>\n> A *search-path* value\n>\n> ```\n> [\n>   {\n>     prefix = \"\";\n>     path = \"/home/eelco/Dev\";\n>   }\n>   {\n>     prefix = \"nixos-config\";\n>     path = \"/etc/nixos\";\n>   }\n> ]\n> ```\n>\n> and a *lookup-path* value `\"nixos-config\"` will cause Nix to try `/home/eelco/Dev/nixos-config` and `/etc/nixos` in that order and return the first path that exists.\n\nIf `path` starts with `http://` or `https://`, it is interpreted as the URL of a tarball that will be downloaded and unpacked to a temporary location.\nThe tarball must consist of a single top-level directory.\n\nThe URLs of the tarballs from the official `nixos.org` channels can be abbreviated as `channel:<channel-name>`.\nSee [documentation on `nix-channel`](@docroot@/command-ref/nix-channel.md) for details about channels.\n\n> **Example**\n>\n> These two search path entries are equivalent:\n>\n> - ```\n>   {\n>     prefix = \"nixpkgs\";\n>     path = \"channel:nixpkgs-unstable\";\n>   }\n>   ```\n> - ```\n>   {\n>     prefix = \"nixpkgs\";\n>     path = \"https://nixos.org/channels/nixos-unstable/nixexprs.tar.xz\";\n>   }\n>   ```\n\nSearch paths can also point to source trees using [flake URLs](@docroot@/command-ref/new-cli/nix3-flake.md#url-like-syntax).\n\n\n> **Example**\n>\n> The search path entry\n>\n> ```\n> {\n>   prefix = \"nixpkgs\";\n>   path = \"flake:nixpkgs\";\n> }\n> ```\n> specifies that the prefix `nixpkgs` shall refer to the source tree downloaded from the `nixpkgs` entry in the flake registry.\n>\n> Similarly\n>\n> ```\n> {\n>   prefix = \"nixpkgs\";\n>   path = \"flake:github:nixos/nixpkgs/nixos-22.05\";\n> }\n> ```\n>\n> makes `<nixpkgs>` refer to a particular branch of the `NixOS/nixpkgs` repository on GitHub.",
  "builtins.flakeRefToString": "Convert a flake reference from attribute set format to URL format.\n\nFor example:\n\n```nix\nbuiltins.flakeRefToString {\n  dir = \"lib\"; owner = \"NixOS\"; ref = \"23.05\"; repo = \"nixpkgs\"; type = \"github\";\n}\n```\n\nevaluates to\n\n```nix\n\"github:NixOS/nixpkgs/23.05?dir=lib\"\n```",
  "builtins.floor": "Converts an IEEE-754 double-precision floating-point number (*double*) to\nthe next lower integer.\n\nIf the datatype is neither an integer nor a \"float\", an evaluation error will be\nthrown.",
  "builtins.foldl' (Prime)": "Reduce a list by applying a binary operator, from left to right,\ne.g. `foldl' op nul [x0 x1 x2 ...] = op (op (op nul x0) x1) x2)\n...`.\n\nFor example, `foldl' (acc: elem: acc + elem) 0 [1 2 3]` evaluates\nto `6` and `foldl' (acc: elem: { \"${elem}\" = elem; } // acc) {}\n[\"a\" \"b\"]` evaluates to `{ a = \"a\"; b = \"b\"; }`.\n\nThe first argument of `op` is the accumulator whereas the second\nargument is the current element being processed. The return value\nof each application of `op` is evaluated immediately, even for\nintermediate values.",
  "builtins.fromJSON": "Convert a JSON string to a Nix value. For example,\n\n```nix\nbuiltins.fromJSON ''{\"x\": [1, 2, 3], \"y\": null}''\n```\n\nreturns the value `{ x = [ 1 2 3 ]; y = null; }`.",
  "builtins.fromTOML": "Convert a TOML string to a Nix value. For example,\n\n```nix\nbuiltins.fromTOML ''\n  x=1\n  s=\"a\"\n  [table]\n  y=2\n''\n```\n\nreturns the value `{ s = \"a\"; table = { y = 2; }; x = 1; }`.",
  "builtins.functionArgs": "Return a set containing the names of the formal arguments expected\nby the function *f*. The value of each attribute is a Boolean\ndenoting whether the corresponding argument has a default value. For\ninstance, `functionArgs ({ x, y ? 123}: ...) = { x = false; y =\ntrue; }`.\n\n\"Formal argument\" here refers to the attributes pattern-matched by\nthe function. Plain lambdas are not included, e.g. `functionArgs (x:\n...) = { }`.",
  "builtins.genList": "Generate list of size *length*, with each element *i* equal to the\nvalue returned by *generator* `i`. For example,\n\n```nix\nbuiltins.genList (x: x * x) 5\n```\n\nreturns the list `[ 0 1 4 9 16 ]`.",
  "builtins.genericClosure": "`builtins.genericClosure` iteratively computes the transitive closure over an arbitrary relation defined by a function.\n\nIt takes *attrset* with two attributes named `startSet` and `operator`, and returns a list of attribute sets:\n\n- `startSet`:\n  The initial list of attribute sets.\n\n- `operator`:\n  A function that takes an attribute set and returns a list of attribute sets.\n  It defines how each item in the current set is processed and expanded into more items.\n\nEach attribute set in the list `startSet` and the list returned by `operator` must have an attribute `key`, which must support equality comparison.\nThe value of `key` can be one of the following types:\n\n- [Int](@docroot@/language/types.md#type-int)\n- [Float](@docroot@/language/types.md#type-float)\n- [Boolean](@docroot@/language/types.md#type-boolean)\n- [String](@docroot@/language/types.md#type-string)\n- [Path](@docroot@/language/types.md#type-path)\n- [List](@docroot@/language/types.md#list)\n\nThe result is produced by calling the `operator` on each `item` that has not been called yet, including newly added items, until no new items are added.\nItems are compared by their `key` attribute.\n\nCommon usages are:\n\n- Generating unique collections of items, such as dependency graphs.\n- Traversing through structures that may contain cycles or loops.\n- Processing data structures with complex internal relationships.\n\n> **Example**\n>\n> ```nix\n> builtins.genericClosure {\n>   startSet = [ {key = 5;} ];\n>   operator = item: [{\n>     key = if (item.key / 2 ) * 2 == item.key\n>          then item.key / 2\n>          else 3 * item.key + 1;\n>   }];\n> }\n> ```\n>\n> evaluates to\n>\n> ```nix\n> [ { key = 5; } { key = 16; } { key = 8; } { key = 4; } { key = 2; } { key = 1; } ]\n> ```",
  "builtins.getAttr": "`getAttr` returns the attribute named *s* from *set*. Evaluation\naborts if the attribute doesn’t exist. This is a dynamic version of\nthe `.` operator, since *s* is an expression rather than an\nidentifier.",
  "builtins.getContext": "Return the string context of *s*.\n\nThe string context tracks references to derivations within a string.\nIt is represented as an attribute set of [store derivation](@docroot@/glossary.md#gloss-store-derivation) paths mapping to output names.\n\nUsing [string interpolation](@docroot@/language/string-interpolation.md) on a derivation will add that derivation to the string context.\nFor example,\n\n```nix\nbuiltins.getContext \"${derivation { name = \"a\"; builder = \"b\"; system = \"c\"; }}\"\n```\n\nevaluates to\n\n```\n{ \"/nix/store/arhvjaf6zmlyn8vh8fgn55rpwnxq0n7l-a.drv\" = { outputs = [ \"out\" ]; }; }\n```",
  "builtins.getEnv": "`getEnv` returns the value of the environment variable *s*, or an\nempty string if the variable doesn’t exist. This function should be\nused with care, as it can introduce all sorts of nasty environment\ndependencies in your Nix expression.\n\n`getEnv` is used in Nix Packages to locate the file\n`~/.nixpkgs/config.nix`, which contains user-local settings for Nix\nPackages. (That is, it does a `getEnv \"HOME\"` to locate the user’s\nhome directory.)",
  "builtins.getFlake": "Fetch a flake from a flake reference, and return its output attributes and some metadata. For example:\n\n```nix\n(builtins.getFlake \"nix/55bc52401966fbffa525c574c14f67b00bc4fb3a\").packages.x86_64-linux.nix\n```\n\nUnless impure evaluation is allowed (`--impure`), the flake reference\nmust be \"locked\", e.g. contain a Git revision or content hash. An\nexample of an unlocked usage is:\n\n```nix\n(builtins.getFlake \"github:edolstra/dwarffs\").rev\n```",
  "builtins.groupBy": "Groups elements of *list* together by the string returned from the\nfunction *f* called on each element. It returns an attribute set\nwhere each attribute value contains the elements of *list* that are\nmapped to the same corresponding attribute name returned by *f*.\n\nFor example,\n\n```nix\nbuiltins.groupBy (builtins.substring 0 1) [\"foo\" \"bar\" \"baz\"]\n```\n\nevaluates to\n\n```nix\n{ b = [ \"bar\" \"baz\" ]; f = [ \"foo\" ]; }\n```",
  "builtins.hasAttr": "`hasAttr` returns `true` if *set* has an attribute named *s*, and\n`false` otherwise. This is a dynamic version of the `?` operator,\nsince *s* is an expression rather than an identifier.",
  "builtins.hasContext": "Return `true` if string *s* has a non-empty context.\nThe context can be obtained with\n[`getContext`](#builtins-getContext).\n\n> **Example**\n>\n> Many operations require a string context to be empty because they are intended only to work with \"regular\" strings, and also to help users avoid unintentionally loosing track of string context elements.\n> `builtins.hasContext` can help create better domain-specific errors in those case.\n>\n> ```nix\n> name: meta:\n>\n> if builtins.hasContext name\n> then throw \"package name cannot contain string context\"\n> else { ${name} = meta; }\n> ```",
  "builtins.hashFile": "Return a base-16 representation of the cryptographic hash of the\nfile at path *p*. The hash algorithm specified by *type* must be one\nof `\"md5\"`, `\"sha1\"`, `\"sha256\"` or `\"sha512\"`.",
  "builtins.hashString": "Return a base-16 representation of the cryptographic hash of string\n*s*. The hash algorithm specified by *type* must be one of `\"md5\"`,\n`\"sha1\"`, `\"sha256\"` or `\"sha512\"`.",
  "builtins.head": "Return the first element of a list; abort evaluation if the argument\nisn’t a list or is an empty list. You can test whether a list is\nempty by comparing it with `[]`.",
  "builtins.import": "Load, parse, and return the Nix expression in the file *path*.\n\n> **Note**\n>\n> Unlike some languages, `import` is a regular function in Nix.\n\nThe *path* argument must meet the same criteria as an [interpolated expression](@docroot@/language/string-interpolation.md#interpolated-expression).\n\nIf *path* is a directory, the file `default.nix` in that directory is used if it exists.\n\n> **Example**\n>\n> ```console\n> $ echo 123 > default.nix\n> ```\n>\n> Import `default.nix` from the current directory.\n>\n> ```nix\n> import ./.\n> ```\n>\n>     123\n\nEvaluation aborts if the file doesn’t exist or contains an invalid Nix expression.\n\nA Nix expression loaded by `import` must not contain any *free variables*, that is, identifiers that are not defined in the Nix expression itself and are not built-in.\nTherefore, it cannot refer to variables that are in scope at the call site.\n\n> **Example**\n>\n> If you have a calling expression\n>\n> ```nix\n> rec {\n>   x = 123;\n>   y = import ./foo.nix;\n> }\n> ```\n>\n>  then the following `foo.nix` will give an error:\n>\n>  ```nix\n>  # foo.nix\n>  x + 456\n>  ```\n>\n>  since `x` is not in scope in `foo.nix`.\n> If you want `x` to be available in `foo.nix`, pass it as a function argument:\n>\n>  ```nix\n>  rec {\n>    x = 123;\n>    y = import ./foo.nix x;\n>  }\n>  ```\n>\n>  and\n>\n>  ```nix\n>  # foo.nix\n>  x: x + 456\n>  ```\n>\n>  The function argument doesn’t have to be called `x` in `foo.nix`; any name would work.",
  "builtins.intersectAttrs": "Return a set consisting of the attributes in the set *e2* which have the\nsame name as some attribute in *e1*.\n\nPerforms in O(*n* log *m*) where *n* is the size of the smaller set and *m* the larger set's size.",
  "builtins.isAttrs": "Return `true` if *e* evaluates to a set, and `false` otherwise.",
  "builtins.isBool": "Return `true` if *e* evaluates to a bool, and `false` otherwise.",
  "builtins.isFloat": "Return `true` if *e* evaluates to a float, and `false` otherwise.",
  "builtins.isFunction": "Return `true` if *e* evaluates to a function, and `false` otherwise.",
  "builtins.isInt": "Return `true` if *e* evaluates to an integer, and `false` otherwise.",
  "builtins.isList": "Return `true` if *e* evaluates to a list, and `false` otherwise.",
  "builtins.isNull": "Return `true` if *e* evaluates to `null`, and `false` otherwise.\n\nThis is equivalent to `e == null`.",
  "builtins.isPath": "Return `true` if *e* evaluates to a path, and `false` otherwise.",
  "builtins.isString": "Return `true` if *e* evaluates to a string, and `false` otherwise.",
  "builtins.lambdaMeta": null,
  "builtins.length": "Return the length of the list *e*.",
  "builtins.lessThan": "Return `true` if the number *e1* is less than the number *e2*, and\n`false` otherwise. Evaluation aborts if either *e1* or *e2* does not\nevaluate to a number.",
  "builtins.listToAttrs": "Construct a set from a list specifying the names and values of each\nattribute. Each element of the list should be a set consisting of a\nstring-valued attribute `name` specifying the name of the attribute,\nand an attribute `value` specifying its value.\n\nIn case of duplicate occurrences of the same name, the first\ntakes precedence.\n\nExample:\n\n```nix\nbuiltins.listToAttrs\n  [ { name = \"foo\"; value = 123; }\n    { name = \"bar\"; value = 456; }\n    { name = \"bar\"; value = 420; }\n  ]\n```\n\nevaluates to\n\n```nix\n{ foo = 123; bar = 456; }\n```",
  "builtins.map": "Apply the function *f* to each element in the list *list*. For\nexample,\n\n```nix\nmap (x: \"foo\" + x) [ \"bar\" \"bla\" \"abc\" ]\n```\n\nevaluates to `[ \"foobar\" \"foobla\" \"fooabc\" ]`.",
  "builtins.mapAttrs": "\nApply a function to each element in an attribute set, creating a new attribute set.\n\n# Inputs\n\n`f`\n\n: A function that takes an attribute name and its value, and returns the new value for the attribute.\n\n`attrset`\n\n: The attribute set to iterate through.\n\n# Type\n\n```\nmapAttrs :: (String -> Any -> Any) -> AttrSet -> AttrSet\n```\n\n# Examples\n:::{.example}\n## `lib.attrsets.mapAttrs` usage example\n\n```nix\nmapAttrs (name: value: name + \"-\" + value)\n   { x = \"foo\"; y = \"bar\"; }\n=> { x = \"x-foo\"; y = \"y-bar\"; }\n```\n\n:::\n",
  "builtins.match": "Returns a list if the [extended POSIX regular\nexpression](http://pubs.opengroup.org/onlinepubs/9699919799/basedefs/V1_chap09.html#tag_09_04)\n*regex* matches *str* precisely, otherwise returns `null`. Each item\nin the list is a regex group.\n\n```nix\nbuiltins.match \"ab\" \"abc\"\n```\n\nEvaluates to `null`.\n\n```nix\nbuiltins.match \"abc\" \"abc\"\n```\n\nEvaluates to `[ ]`.\n\n```nix\nbuiltins.match \"a(b)(c)\" \"abc\"\n```\n\nEvaluates to `[ \"b\" \"c\" ]`.\n\n```nix\nbuiltins.match \"[[:space:]]+([[:upper:]]+)[[:space:]]+\" \"  FOO   \"\n```\n\nEvaluates to `[ \"FOO\" ]`.",
  "builtins.mul": "Return the product of the numbers *e1* and *e2*.",
  "builtins.parseDrvName": "Split the string *s* into a package name and version. The package\nname is everything up to but not including the first dash not followed\nby a letter, and the version is everything following that dash. The\nresult is returned in a set `{ name, version }`. Thus,\n`builtins.parseDrvName \"nix-0.12pre12876\"` returns `{ name =\n\"nix\"; version = \"0.12pre12876\"; }`.",
  "builtins.parseFlakeRef": "Parse a flake reference, and return its exploded form.\n\nFor example:\n\n```nix\nbuiltins.parseFlakeRef \"github:NixOS/nixpkgs/23.05?dir=lib\"\n```\n\nevaluates to:\n\n```nix\n{ dir = \"lib\"; owner = \"NixOS\"; ref = \"23.05\"; repo = \"nixpkgs\"; type = \"github\"; }\n```",
  "builtins.partition": "\nSplits the elements of a list in two lists, `right` and\n`wrong`, depending on the evaluation of a predicate.\n\n# Inputs\n\n`pred`\n\n: Predicate\n\n`list`\n\n: Input list\n\n# Type\n\n```\n(a -> bool) -> [a] -> { right :: [a]; wrong :: [a]; }\n```\n\n# Examples\n:::{.example}\n## `lib.lists.partition` usage example\n\n```nix\npartition (x: x > 2) [ 5 1 2 3 4 ]\n=> { right = [ 5 3 4 ]; wrong = [ 1 2 ]; }\n```\n\n:::\n",
  "builtins.path": "An enrichment of the built-in path type, based on the attributes\npresent in *args*. All are optional except `path`:\n\n  - path\\\n    The underlying path.\n\n  - name\\\n    The name of the path when added to the store. This can used to\n    reference paths that have nix-illegal characters in their names,\n    like `@`.\n\n  - filter\\\n    A function of the type expected by [`builtins.filterSource`](#builtins-filterSource),\n    with the same semantics.\n\n  - recursive\\\n    When `false`, when `path` is added to the store it is with a\n    flat hash, rather than a hash of the NAR serialization of the\n    file. Thus, `path` must refer to a regular file, not a\n    directory. This allows similar behavior to `fetchurl`. Defaults\n    to `true`.\n\n  - sha256\\\n    When provided, this is the expected hash of the file at the\n    path. Evaluation will fail if the hash is incorrect, and\n    providing a hash allows `builtins.path` to be used even when the\n    `pure-eval` nix config option is on.",
  "builtins.pathExists": "Return `true` if the path *path* exists at evaluation time, and\n`false` otherwise.",
  "builtins.placeholder": "Return at\n[output placeholder string](@docroot@/store/drv.md#output-placeholder)\nfor the specified *output* that will be substituted by the corresponding\n[output path](@docroot@/glossary.md#gloss-output-path)\nat build time.\n\nTypical outputs would be `\"out\"`, `\"bin\"` or `\"dev\"`.",
  "builtins.readDir": "Return the contents of the directory *path* as a set mapping\ndirectory entries to the corresponding file type. For instance, if\ndirectory `A` contains a regular file `B` and another directory\n`C`, then `builtins.readDir ./A` will return the set\n\n```nix\n{ B = \"regular\"; C = \"directory\"; }\n```\n\nThe possible values for the file type are `\"regular\"`,\n`\"directory\"`, `\"symlink\"` and `\"unknown\"`.",
  "builtins.readFile": "Return the contents of the file *path* as a string.",
  "builtins.readFileType": "\nThe type of a path. The path needs to exist and be accessible.\nThe result is either \"directory\" for a directory, \"regular\" for a regular file, \"symlink\" for a symlink, or \"unknown\" for anything else.\n\n# Inputs\n\npath\n\n: The path to query\n\n# Type\n\n```\npathType :: Path -> String\n```\n\n# Examples\n:::{.example}\n## `lib.filesystem.pathType` usage example\n\n```nix\npathType /.\n=> \"directory\"\n\npathType /some/file.nix\n=> \"regular\"\n```\n\n:::\n",
  "builtins.removeAttrs": "Remove the attributes listed in *list* from *set*. The attributes\ndon’t have to exist in *set*. For instance,\n\n```nix\nremoveAttrs { x = 1; y = 2; z = 3; } [ \"a\" \"x\" \"z\" ]\n```\n\nevaluates to `{ y = 2; }`.",
  "builtins.replaceStrings": "Given string *s*, replace every occurrence of the strings in *from*\nwith the corresponding string in *to*.\n\nThe argument *to* is lazy, that is, it is only evaluated when its corresponding pattern in *from* is matched in the string *s*\n\nExample:\n\n```nix\nbuiltins.replaceStrings [\"oo\" \"a\"] [\"a\" \"i\"] \"foobar\"\n```\n\nevaluates to `\"fabir\"`.",
  "builtins.scopedImport": null,
  "builtins.seq": "Evaluate *e1*, then evaluate and return *e2*. This ensures that a\ncomputation is strict in the value of *e1*.",
  "builtins.sort": "\nSort a list based on a comparator function which compares two\nelements and returns true if the first argument is strictly below\nthe second argument.  The returned list is sorted in an increasing\norder.  The implementation does a quick-sort.\n\nSee also [`sortOn`](#function-library-lib.lists.sortOn), which applies the\ndefault comparison on a function-derived property, and may be more efficient.\n\n# Inputs\n\n`comparator`\n\n: 1\\. Function argument\n\n`list`\n\n: 2\\. Function argument\n\n# Type\n\n```\nsort :: (a -> a -> Bool) -> [a] -> [a]\n```\n\n# Examples\n:::{.example}\n## `lib.lists.sort` usage example\n\n```nix\nsort (p: q: p < q) [ 5 3 7 ]\n=> [ 3 5 7 ]\n```\n\n:::\n",
  "builtins.split": "Returns a list composed of non matched strings interleaved with the\nlists of the [extended POSIX regular\nexpression](http://pubs.opengroup.org/onlinepubs/9699919799/basedefs/V1_chap09.html#tag_09_04)\n*regex* matches of *str*. Each item in the lists of matched\nsequences is a regex group.\n\n```nix\nbuiltins.split \"(a)b\" \"abc\"\n```\n\nEvaluates to `[ \"\" [ \"a\" ] \"c\" ]`.\n\n```nix\nbuiltins.split \"([ac])\" \"abc\"\n```\n\nEvaluates to `[ \"\" [ \"a\" ] \"b\" [ \"c\" ] \"\" ]`.\n\n```nix\nbuiltins.split \"(a)|(c)\" \"abc\"\n```\n\nEvaluates to `[ \"\" [ \"a\" null ] \"b\" [ null \"c\" ] \"\" ]`.\n\n```nix\nbuiltins.split \"([[:upper:]]+)\" \" FOO \"\n```\n\nEvaluates to `[ \" \" [ \"FOO\" ] \" \" ]`.",
  "builtins.splitVersion": "\nBreak a version string into its component parts.\n\n# Examples\n:::{.example}\n## `splitVersion` usage example\n\n```nix\nsplitVersion \"1.2.3\"\n=> [\"1\" \"2\" \"3\"]\n```\n\n:::\n",
  "builtins.storePath": "This function allows you to define a dependency on an already\nexisting store path. For example, the derivation attribute `src\n= builtins.storePath /nix/store/f1d18v1y…-source` causes the\nderivation to depend on the specified path, which must exist or\nbe substitutable. Note that this differs from a plain path\n(e.g. `src = /nix/store/f1d18v1y…-source`) in that the latter\ncauses the path to be *copied* again to the Nix store, resulting\nin a new path (e.g. `/nix/store/ld01dnzc…-source-source`).\n\nNot available in [pure evaluation mode](@docroot@/command-ref/conf-file.md#conf-pure-eval).\n\nSee also [`builtins.fetchClosure`](#builtins-fetchClosure).",
  "builtins.stringLength": "Return the number of bytes of the string *e*. If *e* is not a string,\nevaluation is aborted.",
  "builtins.sub": "Return the difference between the numbers *e1* and *e2*.",
  "builtins.substring": "Return the substring of *s* from byte position *start*\n(zero-based) up to but not including *start + len*. If *start* is\ngreater than the length of the string, an empty string is returned.\nIf *start + len* lies beyond the end of the string or *len* is `-1`,\nonly the substring up to the end of the string is returned.\n*start* must be non-negative.\nFor example,\n\n```nix\nbuiltins.substring 0 3 \"nixos\"\n```\n\nevaluates to `\"nix\"`.",
  "builtins.tail": "Return the list without its first item; abort evaluation if\nthe argument isn’t a list or is an empty list.\n\n> **Warning**\n>\n> This function should generally be avoided since it's inefficient:\n> unlike Haskell's `tail`, it takes O(n) time, so recursing over a\n> list by repeatedly calling `tail` takes O(n^2) time.",
  "builtins.throw": "Throw an error message *s*. This usually aborts Nix expression\nevaluation, but in `nix-env -qa` and other commands that try to\nevaluate a set of derivations to get information about those\nderivations, a derivation that throws an error is silently skipped\n(which is not the case for `abort`).",
  "builtins.toFile": "Store the string *s* in a file in the Nix store and return its\npath.  The file has suffix *name*. This file can be used as an\ninput to derivations. One application is to write builders\n“inline”. For instance, the following Nix expression combines the\nNix expression for GNU Hello and its build script into one file:\n\n```nix\n{ stdenv, fetchurl, perl }:\n\nstdenv.mkDerivation {\n  name = \"hello-2.1.1\";\n\n  builder = builtins.toFile \"builder.sh\" \"\n    source $stdenv/setup\n\n    PATH=$perl/bin:$PATH\n\n    tar xvfz $src\n    cd hello-*\n    ./configure --prefix=$out\n    make\n    make install\n  \";\n\n  src = fetchurl {\n    url = \"http://ftp.nluug.nl/pub/gnu/hello/hello-2.1.1.tar.gz\";\n    sha256 = \"1md7jsfd8pa45z73bz1kszpp01yw6x5ljkjk2hx7wl800any6465\";\n  };\n  inherit perl;\n}\n```\n\nIt is even possible for one file to refer to another, e.g.,\n\n```nix\nbuilder = let\n  configFile = builtins.toFile \"foo.conf\" \"\n    # This is some dummy configuration file.\n    ...\n  \";\nin builtins.toFile \"builder.sh\" \"\n  source $stdenv/setup\n  ...\n  cp ${configFile} $out/etc/foo.conf\n\";\n```\n\nNote that `${configFile}` is a\n[string interpolation](@docroot@/language/types.md#type-string), so the result of the\nexpression `configFile`\n(i.e., a path like `/nix/store/m7p7jfny445k...-foo.conf`) will be\nspliced into the resulting string.\n\nIt is however *not* allowed to have files mutually referring to each\nother, like so:\n\n```nix\nlet\n  foo = builtins.toFile \"foo\" \"...${bar}...\";\n  bar = builtins.toFile \"bar\" \"...${foo}...\";\nin foo\n```\n\nThis is not allowed because it would cause a cyclic dependency in\nthe computation of the cryptographic hashes for `foo` and `bar`.\n\nIt is also not possible to reference the result of a derivation. If\nyou are using Nixpkgs, the `writeTextFile` function is able to do\nthat.",
  "builtins.toJSON": "Return a string containing a JSON representation of *e*. Strings,\nintegers, floats, booleans, nulls and lists are mapped to their JSON\nequivalents. Sets (except derivations) are represented as objects.\nDerivations are translated to a JSON string containing the\nderivation’s output path. Paths are copied to the store and\nrepresented as a JSON string of the resulting store path.",
  "builtins.toPath": "**DEPRECATED.** Use `/. + \"/path\"` to convert a string into an absolute\npath. For relative paths, use `./. + \"/path\"`.",
  "builtins.toString": "Convert the expression *e* to a string. *e* can be:\n\n  - A string (in which case the string is returned unmodified).\n\n  - A path (e.g., `toString /foo/bar` yields `\"/foo/bar\"`.\n\n  - A set containing `{ __toString = self: ...; }` or `{ outPath = ...; }`.\n\n  - An integer.\n\n  - A list, in which case the string representations of its elements\n    are joined with spaces.\n\n  - A Boolean (`false` yields `\"\"`, `true` yields `\"1\"`).\n\n  - `null`, which yields the empty string.",
  "builtins.toXML": "Return a string containing an XML representation of *e*. The main\napplication for `toXML` is to communicate information with the\nbuilder in a more structured format than plain environment\nvariables.\n\nHere is an example where this is the case:\n\n```nix\n{ stdenv, fetchurl, libxslt, jira, uberwiki }:\n\nstdenv.mkDerivation (rec {\n  name = \"web-server\";\n\n  buildInputs = [ libxslt ];\n\n  builder = builtins.toFile \"builder.sh\" \"\n    source $stdenv/setup\n    mkdir $out\n    echo \"$servlets\" | xsltproc ${stylesheet} - > $out/server-conf.xml ①\n  \";\n\n  stylesheet = builtins.toFile \"stylesheet.xsl\" ②\n   \"<?xml version='1.0' encoding='UTF-8'?>\n    <xsl:stylesheet xmlns:xsl='http://www.w3.org/1999/XSL/Transform' version='1.0'>\n      <xsl:template match='/'>\n        <Configure>\n          <xsl:for-each select='/expr/list/attrs'>\n            <Call name='addWebApplication'>\n              <Arg><xsl:value-of select=\\\"attr[@name = 'path']/string/@value\\\" /></Arg>\n              <Arg><xsl:value-of select=\\\"attr[@name = 'war']/path/@value\\\" /></Arg>\n            </Call>\n          </xsl:for-each>\n        </Configure>\n      </xsl:template>\n    </xsl:stylesheet>\n  \";\n\n  servlets = builtins.toXML [ ③\n    { path = \"/bugtracker\"; war = jira + \"/lib/atlassian-jira.war\"; }\n    { path = \"/wiki\"; war = uberwiki + \"/uberwiki.war\"; }\n  ];\n})\n```\n\nThe builder is supposed to generate the configuration file for a\n[Jetty servlet container](http://jetty.mortbay.org/). A servlet\ncontainer contains a number of servlets (`*.war` files) each\nexported under a specific URI prefix. So the servlet configuration\nis a list of sets containing the `path` and `war` of the servlet\n(①). This kind of information is difficult to communicate with the\nnormal method of passing information through an environment\nvariable, which just concatenates everything together into a\nstring (which might just work in this case, but wouldn’t work if\nfields are optional or contain lists themselves). Instead the Nix\nexpression is converted to an XML representation with `toXML`,\nwhich is unambiguous and can easily be processed with the\nappropriate tools. For instance, in the example an XSLT stylesheet\n(at point ②) is applied to it (at point ①) to generate the XML\nconfiguration file for the Jetty server. The XML representation\nproduced at point ③ by `toXML` is as follows:\n\n```xml\n<?xml version='1.0' encoding='utf-8'?>\n<expr>\n  <list>\n    <attrs>\n      <attr name=\"path\">\n        <string value=\"/bugtracker\" />\n      </attr>\n      <attr name=\"war\">\n        <path value=\"/nix/store/d1jh9pasa7k2...-jira/lib/atlassian-jira.war\" />\n      </attr>\n    </attrs>\n    <attrs>\n      <attr name=\"path\">\n        <string value=\"/wiki\" />\n      </attr>\n      <attr name=\"war\">\n        <path value=\"/nix/store/y6423b1yi4sx...-uberwiki/uberwiki.war\" />\n      </attr>\n    </attrs>\n  </list>\n</expr>\n```\n\nNote that we used the `toFile` built-in to write the builder and\nthe stylesheet “inline” in the Nix expression. The path of the\nstylesheet is spliced into the builder using the syntax `xsltproc\n${stylesheet}`.",
  "builtins.trace": "Evaluate *e1* and print its abstract syntax representation on\nstandard error. Then return *e2*. This function is useful for\ndebugging.\n\nIf the\n[`debugger-on-trace`](@docroot@/command-ref/conf-file.md#conf-debugger-on-trace)\noption is set to `true` and the `--debugger` flag is given, the\ninteractive debugger will be started when `trace` is called (like\n[`break`](@docroot@/language/builtins.md#builtins-break)).",
  "builtins.traceVerbose": "Evaluate *e1* and print its abstract syntax representation on standard\nerror if `--trace-verbose` is enabled. Then return *e2*. This function\nis useful for debugging.",
  "builtins.tryEval": "Try to shallowly evaluate *e*. Return a set containing the\nattributes `success` (`true` if *e* evaluated successfully,\n`false` if an error was thrown) and `value`, equalling *e* if\nsuccessful and `false` otherwise. `tryEval` will only prevent\nerrors created by `throw` or `assert` from being thrown.\nErrors `tryEval` will not catch are for example those created\nby `abort` and type errors generated by builtins. Also note that\nthis doesn't evaluate *e* deeply, so `let e = { x = throw \"\"; };\nin (builtins.tryEval e).success` will be `true`. Using\n`builtins.deepSeq` one can get the expected result:\n`let e = { x = throw \"\"; }; in\n(builtins.tryEval (builtins.deepSeq e e)).success` will be\n`false`.\n\n`tryEval` intentionally does not return the error message, because that risks bringing non-determinism into the evaluation result, and it would become very difficult to improve error reporting without breaking existing expressions.\nInstead, use [`builtins.addErrorContext`](@docroot@/language/builtins.md#builtins-addErrorContext) to add context to the error message, and use a Nix unit testing tool for testing.",
  "builtins.typeOf": "Return a string representing the type of the value *e*, namely\n`\"int\"`, `\"bool\"`, `\"string\"`, `\"path\"`, `\"null\"`, `\"set\"`,\n`\"list\"`, `\"lambda\"` or `\"float\"`.",
  "builtins.unsafeDiscardOutputDependency": "Create a copy of the given string where every\n[derivation deep](@docroot@/language/string-context.md#string-context-element-derivation-deep)\nstring context element is turned into a\n[constant](@docroot@/language/string-context.md#string-context-element-constant)\nstring context element.\n\nThis is the opposite of [`builtins.addDrvOutputDependencies`](#builtins-addDrvOutputDependencies).\n\nThis is unsafe because it allows us to \"forget\" store objects we would have otherwise referred to with the string context,\nwhereas Nix normally tracks all dependencies consistently.\nSafe operations \"grow\" but never \"shrink\" string contexts.\n[`builtins.addDrvOutputDependencies`] in contrast is safe because \"derivation deep\" string context element always refers to the underlying derivation (among many more things).\nReplacing a constant string context element with a \"derivation deep\" element is a safe operation that just enlargens the string context without forgetting anything.\n\n[`builtins.addDrvOutputDependencies`]: #builtins-addDrvOutputDependencies",
  "builtins.unsafeDiscardStringContext": "Discard the [string context](@docroot@/language/string-context.md) from a value that can be coerced to a string.",
  "builtins.unsafeGetAttrPos": null,
  "builtins.warn": "\n\n`warn` *`message`* *`value`*\n\nPrint a warning before returning the second argument.\n\nSee [`builtins.warn`](https://nix.dev/manual/nix/latest/language/builtins.html#builtins-warn) (Nix >= 2.23).\nOn older versions, the Nix 2.23 behavior is emulated with [`builtins.trace`](https://nix.dev/manual/nix/latest/language/builtins.html#builtins-warn), including the [`NIX_ABORT_ON_WARN`](https://nix.dev/manual/nix/latest/command-ref/conf-file#conf-abort-on-warn) behavior, but not the `nix.conf` setting or command line option.\n\n# Inputs\n\n*`message`* (String)\n\n: Warning message to print before evaluating *`value`*.\n\n*`value`* (any value)\n\n: Value to return as-is.\n\n# Type\n\n```\nString -> a -> a\n```\n",
  "builtins.zipAttrsWith": "\nMerge sets of attributes and use the function f to merge attribute values.\nLike `lib.attrsets.zipAttrsWithNames` with all key names are passed for `names`.\n\nImplementation note: Common names appear multiple times in the list of\nnames, hopefully this does not affect the system because the maximal\nlaziness avoid computing twice the same expression and `listToAttrs` does\nnot care about duplicated attribute names.\n\n# Type\n\n```\nzipAttrsWith :: (String -> [ Any ] -> Any) -> [ AttrSet ] -> AttrSet\n```\n\n# Examples\n:::{.example}\n## `lib.attrsets.zipAttrsWith` usage example\n\n```nix\nzipAttrsWith (name: values: values) [{a = \"x\";} {a = \"y\"; b = \"z\";}]\n=> { a = [\"x\" \"y\"]; b = [\"z\"]; }\n```\n\n:::\n",
  "pkgs.dhallPackages.__unfix__": null,
  "pkgs.dhallPackages.buildDhallDirectoryPackage": null,
  "pkgs.dhallPackages.buildDhallGitHubPackage": null,
  "pkgs.dhallPackages.buildDhallPackage": null,
  "pkgs.dhallPackages.buildDhallUrl": null,
  "pkgs.dhallPackages.callPackage": null,
  "pkgs.dhallPackages.generateDhallDirectoryPackage": null,
  "pkgs.dhallPackages.override": null,
  "pkgs.dhallPackages.overrideDerivation": null,
  "pkgs.dhallPackages.buildDhallDirectoryPackage.override": null,
  "pkgs.dhallPackages.buildDhallGitHubPackage.override": null,
  "pkgs.dhallPackages.buildDhallPackage.override": null,
  "pkgs.dhallPackages.buildDhallUrl.override": null,
  "pkgs.dhallPackages.generateDhallDirectoryPackage.override": null,
  "pkgs.dockerTools.buildImage": null,
  "pkgs.dockerTools.buildImageWithNixDb": "TODO: add the dependencies of the config json.",
  "pkgs.dockerTools.buildLayeredImage": null,
  "pkgs.dockerTools.buildLayeredImageWithNixDb": null,
  "pkgs.dockerTools.buildNixShellImage": "Tests: nixos/tests/docker-tools-nix-shell.nix",
  "pkgs.dockerTools.exportImage": null,
  "pkgs.dockerTools.mergeDrvs": "buildEnv creates symlinks to dirs, which is hard to edit inside the overlay VM",
  "pkgs.dockerTools.mergeImages": "tarball will load the images into the docker daemon.",
  "pkgs.dockerTools.mkPureLayer": "Create a \"layer\" (set of files).",
  "pkgs.dockerTools.mkRootLayer": "performed in a virtual machine sandbox.",
  "pkgs.dockerTools.override": null,
  "pkgs.dockerTools.overrideDerivation": null,
  "pkgs.dockerTools.pullImage": null,
  "pkgs.dockerTools.runWithOverlay": "Run commands in a virtual machine.",
  "pkgs.dockerTools.shellScript": "things like `ls` or `echo` will be missing.",
  "pkgs.dockerTools.streamLayeredImage": null,
  "pkgs.dockerTools.streamNixShellImage": "Tests: nixos/tests/docker-tools-nix-shell.nix",
  "pkgs.dotnetCorePackages.addNuGetDeps": null,
  "pkgs.dotnetCorePackages.buildDotnetGlobalTool": null,
  "pkgs.dotnetCorePackages.buildDotnetModule": null,
  "pkgs.dotnetCorePackages.buildDotnetSdk": null,
  "pkgs.dotnetCorePackages.callPackage": null,
  "pkgs.dotnetCorePackages.combinePackages": null,
  "pkgs.dotnetCorePackages.fetchNupkg": null,
  "pkgs.dotnetCorePackages.mkNugetDeps": null,
  "pkgs.dotnetCorePackages.mkNugetSource": null,
  "pkgs.dotnetCorePackages.newScope": null,
  "pkgs.dotnetCorePackages.override": null,
  "pkgs.dotnetCorePackages.overrideDerivation": null,
  "pkgs.dotnetCorePackages.overrideScope": "overridden.",
  "pkgs.dotnetCorePackages.packages": null,
  "pkgs.dotnetCorePackages.systemToDotnetRid": "Convert a \"stdenv.hostPlatform.system\" to a dotnet RID",
  "pkgs.dotnetCorePackages.addNuGetDeps.override": null,
  "pkgs.dotnetCorePackages.buildDotnetGlobalTool.override": null,
  "pkgs.dotnetCorePackages.buildDotnetModule.override": null,
  "pkgs.dotnetCorePackages.dotnet_8.override": null,
  "pkgs.dotnetCorePackages.dotnet_8.overrideDerivation": null,
  "pkgs.dotnetCorePackages.dotnet_9.override": null,
  "pkgs.dotnetCorePackages.dotnet_9.overrideDerivation": null,
  "pkgs.dotnetCorePackages.fetchNupkg.override": null,
  "pkgs.dotnetCorePackages.fetchNupkg.overrideDerivation": null,
  "pkgs.dotnetCorePackages.mkNugetDeps.override": null,
  "pkgs.dotnetCorePackages.mkNugetDeps.overrideDerivation": null,
  "pkgs.dotnetCorePackages.mkNugetSource.override": null,
  "pkgs.dotnetCorePackages.dotnet_8.stage0.override": null,
  "pkgs.dotnetCorePackages.dotnet_8.stage0.overrideDerivation": null,
  "pkgs.dotnetCorePackages.dotnet_9.stage0.override": null,
  "pkgs.dotnetCorePackages.dotnet_9.stage0.overrideDerivation": null,
  "pkgs.elmPackages.callPackage": null,
  "pkgs.elmPackages.fetchElmDeps": null,
  "pkgs.elmPackages.newScope": null,
  "pkgs.elmPackages.override": null,
  "pkgs.elmPackages.overrideDerivation": null,
  "pkgs.elmPackages.overrideScope": null,
  "pkgs.elmPackages.packages": null,
  "pkgs.elmPackages.elmLib.patchBinwrap": null,
  "pkgs.elmPackages.elmLib.patchNpmElm": null,
  "pkgs.elmPackages.fetchElmDeps.override": null,
  "pkgs.emacsPackages.callPackage": null,
  "pkgs.emacsPackages.elpaBuild": null,
  "pkgs.emacsPackages.emacsWithPackages": null,
  "pkgs.emacsPackages.melpaBuild": null,
  "pkgs.emacsPackages.newScope": null,
  "pkgs.emacsPackages.override": null,
  "pkgs.emacsPackages.overrideDerivation": null,
  "pkgs.emacsPackages.overrideScope": null,
  "pkgs.emacsPackages.packages": null,
  "pkgs.emacsPackages.trivialBuild": null,
  "pkgs.emacsPackages.withPackages": null,
  "pkgs.emacsPackages.elpaBuild.constructDrv": null,
  "pkgs.emacsPackages.elpaBuild.extendDrvArgs": null,
  "pkgs.emacsPackages.elpaBuild.override": null,
  "pkgs.emacsPackages.elpaBuild.overrideDerivation": null,
  "pkgs.emacsPackages.elpaBuild.transformDrv": "\nThe identity function\nFor when you need a function that does “nothing”.\n\n\n# Inputs\n\n`x`\n\n: The value to return\n\n# Type\n\n```\nid :: a -> a\n```\n",
  "pkgs.emacsPackages.elpaDevelPackages.override": null,
  "pkgs.emacsPackages.elpaDevelPackages.overrideDerivation": null,
  "pkgs.emacsPackages.elpaPackages.override": null,
  "pkgs.emacsPackages.elpaPackages.overrideDerivation": null,
  "pkgs.emacsPackages.melpaBuild.constructDrv": null,
  "pkgs.emacsPackages.melpaBuild.extendDrvArgs": null,
  "pkgs.emacsPackages.melpaBuild.override": null,
  "pkgs.emacsPackages.melpaBuild.overrideDerivation": null,
  "pkgs.emacsPackages.melpaBuild.transformDrv": "\nThe identity function\nFor when you need a function that does “nothing”.\n\n\n# Inputs\n\n`x`\n\n: The value to return\n\n# Type\n\n```\nid :: a -> a\n```\n",
  "pkgs.emacsPackages.melpaPackages.override": null,
  "pkgs.emacsPackages.melpaPackages.overrideDerivation": null,
  "pkgs.emacsPackages.melpaStablePackages.override": null,
  "pkgs.emacsPackages.melpaStablePackages.overrideDerivation": null,
  "pkgs.emacsPackages.nongnuDevelPackages.override": null,
  "pkgs.emacsPackages.nongnuDevelPackages.overrideDerivation": null,
  "pkgs.emacsPackages.nongnuPackages.override": null,
  "pkgs.emacsPackages.nongnuPackages.overrideDerivation": null,
  "pkgs.emacsPackages.treesit-grammars.override": null,
  "pkgs.emacsPackages.treesit-grammars.overrideDerivation": null,
  "pkgs.emacsPackages.treesit-grammars.with-grammars": "treesit-grammars.with-grammars (p: [ p.tree-sitter-bash p.tree-sitter-c ... ])",
  "pkgs.emacsPackages.trivialBuild.constructDrv": null,
  "pkgs.emacsPackages.trivialBuild.extendDrvArgs": null,
  "pkgs.emacsPackages.trivialBuild.override": null,
  "pkgs.emacsPackages.trivialBuild.overrideDerivation": null,
  "pkgs.emacsPackages.trivialBuild.transformDrv": "\nThe identity function\nFor when you need a function that does “nothing”.\n\n\n# Inputs\n\n`x`\n\n: The value to return\n\n# Type\n\n```\nid :: a -> a\n```\n",
  "pkgs.emacsPackages.elpaBuild.constructDrv.extendDrvArgs": null,
  "pkgs.emacsPackages.elpaBuild.constructDrv.transformDrv": "\nThe identity function\nFor when you need a function that does “nothing”.\n\n\n# Inputs\n\n`x`\n\n: The value to return\n\n# Type\n\n```\nid :: a -> a\n```\n",
  "pkgs.emacsPackages.manualPackages.treesit-grammars.override": null,
  "pkgs.emacsPackages.manualPackages.treesit-grammars.overrideDerivation": null,
  "pkgs.emacsPackages.manualPackages.treesit-grammars.with-grammars": "treesit-grammars.with-grammars (p: [ p.tree-sitter-bash p.tree-sitter-c ... ])",
  "pkgs.emacsPackages.melpaBuild.constructDrv.extendDrvArgs": null,
  "pkgs.emacsPackages.melpaBuild.constructDrv.transformDrv": "\nThe identity function\nFor when you need a function that does “nothing”.\n\n\n# Inputs\n\n`x`\n\n: The value to return\n\n# Type\n\n```\nid :: a -> a\n```\n",
  "pkgs.emacsPackages.trivialBuild.constructDrv.extendDrvArgs": null,
  "pkgs.emacsPackages.trivialBuild.constructDrv.override": null,
  "pkgs.emacsPackages.trivialBuild.constructDrv.overrideDerivation": null,
  "pkgs.emacsPackages.trivialBuild.constructDrv.transformDrv": "\nThe identity function\nFor when you need a function that does “nothing”.\n\n\n# Inputs\n\n`x`\n\n: The value to return\n\n# Type\n\n```\nid :: a -> a\n```\n",
  "pkgs.gradle-packages.gen": null,
  "pkgs.gradle-packages.gradle_7": null,
  "pkgs.gradle-packages.gradle_8": null,
  "pkgs.gradle-packages.wrapGradle": null,
  "pkgs.haskell.lib.addBuildDepend": null,
  "pkgs.haskell.lib.addBuildDepends": null,
  "pkgs.haskell.lib.addBuildTool": null,
  "pkgs.haskell.lib.addBuildTools": null,
  "pkgs.haskell.lib.addExtraLibraries": null,
  "pkgs.haskell.lib.addExtraLibrary": null,
  "pkgs.haskell.lib.addOptparseApplicativeCompletionScripts": null,
  "pkgs.haskell.lib.addPkgconfigDepend": null,
  "pkgs.haskell.lib.addPkgconfigDepends": null,
  "pkgs.haskell.lib.addSetupDepend": null,
  "pkgs.haskell.lib.addSetupDepends": null,
  "pkgs.haskell.lib.addTestToolDepend": null,
  "pkgs.haskell.lib.addTestToolDepends": null,
  "pkgs.haskell.lib.allowInconsistentDependencies": null,
  "pkgs.haskell.lib.appendBuildFlag": null,
  "pkgs.haskell.lib.appendBuildFlags": null,
  "pkgs.haskell.lib.appendConfigureFlag": "\nappendConfigureFlag adds a single argument that will be passed to the\ncabal configure command, after the arguments that have been defined\nin the initial declaration or previous overrides.\n\n\n# Inputs\n\n`drv`\n\n: 1\\. Function argument\n\n`x`\n\n: 2\\. Function argument\n\n\n# Examples\n:::{.example}\n## `appendConfigureFlag` usage example\n\n```nix\n> haskell.lib.appendConfigureFlag haskellPackages.servant \"--profiling-detail=all-functions\"\n```\n\n:::\n",
  "pkgs.haskell.lib.appendConfigureFlags": null,
  "pkgs.haskell.lib.appendPatch": null,
  "pkgs.haskell.lib.appendPatches": null,
  "pkgs.haskell.lib.buildFromSdist": "\nBuild a source distribution tarball instead of using the source files\ndirectly. The effect is that the package is built as if it were published\non hackage. This can be used as a test for the source distribution,\nassuming the build fails when packaging mistakes are in the cabal file.\n",
  "pkgs.haskell.lib.buildStackProject": null,
  "pkgs.haskell.lib.buildStrictly": "\nBuild the package in a strict way to uncover potential problems.\nThis includes buildFromSdist and failOnAllWarnings.\n",
  "pkgs.haskell.lib.checkUnusedPackages": "\nAdd a post-build check to verify that dependencies declared in\nthe cabal file are actually used.\n\nThe first attrset argument can be used to configure the strictness\nof this check and a list of ignored package names that would otherwise\ncause false alarms.\n",
  "pkgs.haskell.lib.controlPhases": "Some information about which phases should be run.",
  "pkgs.haskell.lib.disableCabalFlag": null,
  "pkgs.haskell.lib.disableDeadCodeElimination": null,
  "pkgs.haskell.lib.disableExecutableProfiling": null,
  "pkgs.haskell.lib.disableHardening": null,
  "pkgs.haskell.lib.disableLibraryProfiling": null,
  "pkgs.haskell.lib.disableOptimization": null,
  "pkgs.haskell.lib.disableParallelBuilding": null,
  "pkgs.haskell.lib.disableSharedExecutables": null,
  "pkgs.haskell.lib.disableSharedLibraries": null,
  "pkgs.haskell.lib.disableStaticLibraries": null,
  "pkgs.haskell.lib.doBenchmark": "\ndoBenchmark enables dependency checking, compilation and execution\nfor benchmarks listed in the package description file.\n",
  "pkgs.haskell.lib.doCheck": "\ndoCheck enables dependency checking, compilation and execution\nof test suites listed in the package description file.\n",
  "pkgs.haskell.lib.doCoverage": "\ndoCoverage modifies a haskell package to enable the generation\nand installation of a coverage report.\n\nSee https://wiki.haskell.org/Haskell_program_coverage\n",
  "pkgs.haskell.lib.doDistribute": "\ndoDistribute enables the distribution of binaries for the package\nvia hydra.\n",
  "pkgs.haskell.lib.doHaddock": "\ndoHaddock modifies a haskell package to enable the generation and\ninstallation of API documentation from code comments using the\nhaddock tool.\n",
  "pkgs.haskell.lib.doHyperlinkSource": null,
  "pkgs.haskell.lib.doJailbreak": "\ndoJailbreak enables the removal of version bounds from the cabal\nfile. You may want to avoid this function.\n\nThis is useful when a package reports that it can not be built\ndue to version mismatches. In some cases, removing the version\nbounds entirely is an easy way to make a package build, but at\nthe risk of breaking software in non-obvious ways now or in the\nfuture.\n\nInstead of jailbreaking, you can patch the cabal file.\n\nNote that jailbreaking at this time, doesn't lift bounds on\nconditional branches.\nhttps://github.com/peti/jailbreak-cabal/issues/7 has further details.\n",
  "pkgs.haskell.lib.doStrip": "\nLet Nix strip the binary files.\nThis removes debugging symbols.\n",
  "pkgs.haskell.lib.documentationTarball": "\nCreate a documentation tarball suitable for uploading to Hackage instead\nof building the package.\n",
  "pkgs.haskell.lib.dontBenchmark": "\ndontBenchmark disables dependency checking, compilation and execution\nfor benchmarks listed in the package description file.\n",
  "pkgs.haskell.lib.dontCheck": "\ndontCheck disables dependency checking, compilation and execution\nof test suites listed in the package description file.\n",
  "pkgs.haskell.lib.dontCheckIf": "\nThe dontCheckIf variant sets doCheck = false if the condition\napplies. In any other case the previously set/default value is used.\nThis prevents accidentally re-enabling tests in a later override.\n\n\n# Inputs\n\n`drv`\n\n: 1\\. Function argument\n\n`condition`\n\n: 2\\. Function argument\n",
  "pkgs.haskell.lib.dontCoverage": "\ndontCoverage modifies a haskell package to disable the generation\nand installation of a coverage report.\n",
  "pkgs.haskell.lib.dontDistribute": "\ndontDistribute disables the distribution of binaries for the package\nvia hydra.\n",
  "pkgs.haskell.lib.dontHaddock": "\ndontHaddock modifies a haskell package to disable the generation and\ninstallation of API documentation from code comments using the\nhaddock tool.\n",
  "pkgs.haskell.lib.dontHyperlinkSource": null,
  "pkgs.haskell.lib.dontJailbreak": "\ndontJailbreak restores the use of the version bounds the check\nthe use of dependencies in the package description.\n",
  "pkgs.haskell.lib.dontStrip": "\nStop Nix from stripping the binary files.\nThis keeps debugging symbols.\n",
  "pkgs.haskell.lib.enableCabalFlag": null,
  "pkgs.haskell.lib.enableDWARFDebugging": "\nUseful for debugging segfaults with gdb.\nThis includes dontStrip.\n",
  "pkgs.haskell.lib.enableDeadCodeElimination": null,
  "pkgs.haskell.lib.enableExecutableProfiling": null,
  "pkgs.haskell.lib.enableLibraryProfiling": null,
  "pkgs.haskell.lib.enableSeparateBinOutput": null,
  "pkgs.haskell.lib.enableSharedExecutables": null,
  "pkgs.haskell.lib.enableSharedLibraries": null,
  "pkgs.haskell.lib.enableStaticLibraries": null,
  "pkgs.haskell.lib.failOnAllWarnings": "\nTurn on most of the compiler warnings and fail the build if any\nof them occur.\n",
  "pkgs.haskell.lib.generateOptparseApplicativeCompletion": "\nModify a Haskell package to add shell completion scripts for the\ngiven executable produced by it. These completion scripts will be\npicked up automatically if the resulting derivation is installed,\ne.g. by `nix-env -i`.\n\nInvocation:\n  generateOptparseApplicativeCompletions command pkg\n\n  command: name of an executable\n      pkg: Haskell package that builds the executables\n",
  "pkgs.haskell.lib.generateOptparseApplicativeCompletions": "\nModify a Haskell package to add shell completion scripts for the\ngiven executables produced by it. These completion scripts will be\npicked up automatically if the resulting derivation is installed,\ne.g. by `nix-env -i`.\n\nInvocation:\n  generateOptparseApplicativeCompletions commands pkg\n\n commands: name of an executable\n      pkg: Haskell package that builds the executables\n",
  "pkgs.haskell.lib.getBuildInputs": "Get all of the build inputs of a haskell package, divided by category.",
  "pkgs.haskell.lib.getHaskellBuildInputs": "package.",
  "pkgs.haskell.lib.ghcInfo": null,
  "pkgs.haskell.lib.justStaticExecutables": "\nlink executables statically against haskell libs to reduce\nclosure size\n",
  "pkgs.haskell.lib.linkWithGold": "\nUse the gold linker. It is a linker for ELF that is designed\n\"to run as fast as possible on modern systems\"\n",
  "pkgs.haskell.lib.makePackageSet": "\nThis function takes a file like `hackage-packages.nix` and constructs\na full package set out of that.\n",
  "pkgs.haskell.lib.markBroken": null,
  "pkgs.haskell.lib.markBrokenVersion": null,
  "pkgs.haskell.lib.markUnbroken": null,
  "pkgs.haskell.lib.overrideCabal": "\nThe function overrideCabal lets you alter the arguments to the\nmkDerivation function.\n\n\n# Inputs\n\n`drv`\n\n: 1\\. Function argument\n\n`f`\n\n: 2\\. Function argument\n\n\n# Examples\n:::{.example}\n## `overrideCabal` usage example\n\n```nix\nFirst, note how the aeson package is constructed in hackage-packages.nix:\n\n    \"aeson\" = callPackage ({ mkDerivation, attoparsec, <snip>\n                           }:\n                             mkDerivation {\n                               pname = \"aeson\";\n                               <snip>\n                               homepage = \"https://github.com/bos/aeson\";\n                             })\n\nThe mkDerivation function of haskellPackages will take care of putting\nthe homepage in the right place, in meta.\n\n    > haskellPackages.aeson.meta.homepage\n    \"https://github.com/bos/aeson\"\n\n    > x = haskell.lib.overrideCabal haskellPackages.aeson (old: { homepage = old.homepage + \"#readme\"; })\n    > x.meta.homepage\n    \"https://github.com/bos/aeson#readme\"\n```\n\n:::\n",
  "pkgs.haskell.lib.overrideSrc": "\nOverride the sources for the package and optionally the version.\nThis also takes of removing editedCabalFile.\n\n\n# Inputs\n\n`drv`\n\n: 1\\. Function argument\n\n`src`\n\n: 2\\. Function argument\n",
  "pkgs.haskell.lib.packageSourceOverrides": "the packages named in the input set to the corresponding versions",
  "pkgs.haskell.lib.packagesFromDirectory": "packagesFromDirectory : { directory : Directory, ... } -> HaskellPackageOverrideSet",
  "pkgs.haskell.lib.removeConfigureFlag": "\nremoveConfigureFlag drv x is a Haskell package like drv, but with\nall cabal configure arguments that are equal to x removed.\n\n    > haskell.lib.removeConfigureFlag haskellPackages.servant \"--verbose\"\n\n\n# Inputs\n\n`drv`\n\n: 1\\. Function argument\n\n`x`\n\n: 2\\. Function argument\n",
  "pkgs.haskell.lib.sdistTarball": "\nCreate a source distribution tarball like those found on hackage,\ninstead of building the package.\n",
  "pkgs.haskell.lib.setBuildTarget": null,
  "pkgs.haskell.lib.setBuildTargets": "\nSet a specific build target instead of compiling all targets in the package.\nFor example, imagine we have a .cabal file with a library, and 2 executables \"dev\" and \"server\".\nWe can build only \"server\" and not wait on the compilation of \"dev\" by using setBuildTarget as follows:\n\n  setBuildTarget (callCabal2nix \"thePackageName\" thePackageSrc {}) \"server\"\n\n\n# Inputs\n\n`drv`\n\n: 1\\. Function argument\n\n`xs`\n\n: 2\\. Function argument\n",
  "pkgs.haskell.lib.shellAware": "nix-shell evaluation, return a nix-shell optimized environment.",
  "pkgs.haskell.lib.triggerRebuild": "\nAdd a dummy command to trigger a build despite an equivalent\nearlier build that is present in the store or cache.\n\n\n# Inputs\n\n`drv`\n\n: 1\\. Function argument\n\n`i`\n\n: 2\\. Function argument\n",
  "pkgs.haskell.lib.unmarkBroken": null,
  "lib.add": "\nReturn the sum of the numbers *e1* and *e2*.\n",
  "lib.addContextFrom": "\nAppends string context from string like object `src` to `target`.\n\n:::{.warning}\nThis is an implementation\ndetail of Nix and should be used carefully.\n:::\n\nStrings in Nix carry an invisible `context` which is a list of strings\nrepresenting store paths. If the string is later used in a derivation\nattribute, the derivation will properly populate the inputDrvs and\ninputSrcs.\n\n\n# Inputs\n\n`src`\n: The string to take the context from. If the argument is not a string,\n  it will be implicitly converted to a string.\n\n`target`\n: The string to append the context to. If the argument is not a string,\n  it will be implicitly converted to a string.\n\n# Type\n\n```\naddContextFrom :: string -> string -> string\n```\n\n# Examples\n:::{.example}\n## `lib.strings.addContextFrom` usage example\n\n```nix\npkgs = import <nixpkgs> { };\naddContextFrom pkgs.coreutils \"bar\"\n=> \"bar\"\n```\n\nThe context can be displayed using the `toString` function:\n\n```nix\nnix-repl> builtins.getContext (lib.strings.addContextFrom pkgs.coreutils \"bar\")\n{\n  \"/nix/store/m1s1d2dk2dqqlw3j90jl3cjy2cykbdxz-coreutils-9.5.drv\" = { ... };\n}\n```\n\n:::\n",
  "lib.addErrorContext": null,
  "lib.addMetaAttrs": "\nAdd to or override the meta attributes of the given\nderivation.\n\n# Inputs\n\n`newAttrs`\n\n: 1\\. Function argument\n\n`drv`\n\n: 2\\. Function argument\n\n\n# Examples\n:::{.example}\n## `lib.meta.addMetaAttrs` usage example\n\n```nix\naddMetaAttrs {description = \"Bla blah\";} somePkg\n```\n\n:::\n",
  "lib.all": "\nReturn true if function `pred` returns true for all elements of\n`list`.\n\n# Inputs\n\n`pred`\n\n: Predicate\n\n`list`\n\n: Input list\n\n# Type\n\n```\nall :: (a -> bool) -> [a] -> bool\n```\n\n# Examples\n:::{.example}\n## `lib.lists.all` usage example\n\n```nix\nall (x: x < 3) [ 1 2 ]\n=> true\nall (x: x < 3) [ 1 2 3 ]\n=> false\n```\n\n:::\n",
  "lib.allUnique": "\nCheck if list contains only unique elements. O(n^2) complexity.\n\n\n# Inputs\n\n`list`\n\n: 1\\. Function argument\n\n# Type\n\n```\nallUnique :: [a] -> bool\n```\n\n# Examples\n:::{.example}\n## `lib.lists.allUnique` usage example\n\n```nix\nallUnique [ 3 2 3 4 ]\n=> false\nallUnique [ 3 2 4 1 ]\n=> true\n```\n\n:::\n",
  "lib.and": "\nboolean “and”\n\n\n# Inputs\n\n`x`\n\n: 1\\. Function argument\n\n`y`\n\n: 2\\. Function argument\n",
  "lib.any": "\nReturn true if function `pred` returns true for at least one\nelement of `list`.\n\n# Inputs\n\n`pred`\n\n: Predicate\n\n`list`\n\n: Input list\n\n# Type\n\n```\nany :: (a -> bool) -> [a] -> bool\n```\n\n# Examples\n:::{.example}\n## `lib.lists.any` usage example\n\n```nix\nany isString [ 1 \"a\" { } ]\n=> true\nany isString [ 1 { } ]\n=> false\n```\n\n:::\n",
  "lib.appendToName": "\nAppend a suffix to the name of a package (before the version\npart).\n\n# Inputs\n\n`suffix`\n\n: 1\\. Function argument\n",
  "lib.applyModuleArgsIfFunction": null,
  "lib.assertMsg": "\nThrow if pred is false, else return pred.\nIntended to be used to augment asserts with helpful error messages.\n\n# Inputs\n\n`pred`\n\n: Predicate that needs to succeed, otherwise `msg` is thrown\n\n`msg`\n\n: Message to throw in case `pred` fails\n\n# Type\n\n```\nassertMsg :: Bool -> String -> Bool\n```\n\n# Examples\n:::{.example}\n## `lib.asserts.assertMsg` usage example\n\n```nix\nassertMsg false \"nope\"\nstderr> error: nope\nassert assertMsg (\"foo\" == \"bar\") \"foo is not bar, silly\"; \"\"\nstderr> error: foo is not bar, silly\n```\n\n:::\n",
  "lib.assertOneOf": "\nSpecialized `assertMsg` for checking if `val` is one of the elements\nof the list `xs`. Useful for checking enums.\n\n# Inputs\n\n`name`\n\n: The name of the variable the user entered `val` into, for inclusion in the error message\n\n`val`\n\n: The value of what the user provided, to be compared against the values in `xs`\n\n`xs`\n\n: The list of valid values\n\n# Type\n\n```\nassertOneOf :: String -> ComparableVal -> List ComparableVal -> Bool\n```\n\n# Examples\n:::{.example}\n## `lib.asserts.assertOneOf` usage example\n\n```nix\nlet sslLibrary = \"libressl\";\nin assertOneOf \"sslLibrary\" sslLibrary [ \"openssl\" \"bearssl\" ]\nstderr> error: sslLibrary must be one of [\nstderr>   \"openssl\"\nstderr>   \"bearssl\"\nstderr> ], but is: \"libressl\"\n```\n\n:::\n",
  "lib.attrByPath": "\nReturn an attribute from nested attribute sets.\n\nNix has an [attribute selection operator `.`](https://nixos.org/manual/nix/stable/language/operators#attribute-selection) which is sufficient for such queries, as long as the number of attributes is static. For example:\n\n```nix\n(x.a.b or 6) == attrByPath [\"a\" \"b\"] 6 x\n# and\n(x.${f p}.\"example.com\" or 6) == attrByPath [ (f p) \"example.com\" ] 6 x\n```\n\n\n# Inputs\n\n`attrPath`\n\n: A list of strings representing the attribute path to return from `set`\n\n`default`\n\n: Default value if `attrPath` does not resolve to an existing value\n\n`set`\n\n: The nested attribute set to select values from\n\n# Type\n\n```\nattrByPath :: [String] -> Any -> AttrSet -> Any\n```\n\n# Examples\n:::{.example}\n## `lib.attrsets.attrByPath` usage example\n\n```nix\nx = { a = { b = 3; }; }\n# [\"a\" \"b\"] is equivalent to x.a.b\n# 6 is a default value to return if the path does not exist in attrset\nattrByPath [\"a\" \"b\"] 6 x\n=> 3\nattrByPath [\"z\" \"z\"] 6 x\n=> 6\n```\n\n:::\n",
  "lib.attrNames": "\nReturn the names of the attributes in the set *set* in an\nalphabetically sorted list. For instance, `builtins.attrNames { y\n= 1; x = \"foo\"; }` evaluates to `[ \"x\" \"y\" ]`.\n",
  "lib.attrVals": "\nReturn the specified attributes from a set.\n\n\n# Inputs\n\n`nameList`\n\n: The list of attributes to fetch from `set`. Each attribute name must exist on the attrbitue set\n\n`set`\n\n: The set to get attribute values from\n\n# Type\n\n```\nattrVals :: [String] -> AttrSet -> [Any]\n```\n\n# Examples\n:::{.example}\n## `lib.attrsets.attrVals` usage example\n\n```nix\nattrVals [\"a\" \"b\" \"c\"] as\n=> [as.a as.b as.c]\n```\n\n:::\n",
  "lib.attrValues": "\nReturn the values of all attributes in the given set, sorted by\nattribute name.\n\n# Type\n\n```\nattrValues :: AttrSet -> [Any]\n```\n\n# Examples\n:::{.example}\n## `lib.attrsets.attrValues` usage example\n\n```nix\nattrValues {c = 3; a = 1; b = 2;}\n=> [1 2 3]\n```\n\n:::\n",
  "lib.attrsToList": "\nDeconstruct an attrset to a list of name-value pairs as expected by [`builtins.listToAttrs`](https://nixos.org/manual/nix/stable/language/builtins.html#builtins-listToAttrs).\nEach element of the resulting list is an attribute set with these attributes:\n- `name` (string): The name of the attribute\n- `value` (any): The value of the attribute\n\nThe following is always true:\n```nix\nbuiltins.listToAttrs (attrsToList attrs) == attrs\n```\n\n:::{.warning}\nThe opposite is not always true. In general expect that\n```nix\nattrsToList (builtins.listToAttrs list) != list\n```\n\nThis is because the `listToAttrs` removes duplicate names and doesn't preserve the order of the list.\n:::\n\n# Inputs\n\n`set`\n\n: The attribute set to deconstruct.\n\n# Type\n\n```\nattrsToList :: AttrSet -> [ { name :: String; value :: Any; } ]\n```\n\n# Examples\n:::{.example}\n## `lib.attrsets.attrsToList` usage example\n\n```nix\nattrsToList { foo = 1; bar = \"asdf\"; }\n=> [ { name = \"bar\"; value = \"asdf\"; } { name = \"foo\"; value = 1; } ]\n```\n\n:::\n",
  "lib.bitAnd": "\nReturn the bitwise AND of the integers *e1* and *e2*.\n",
  "lib.bitNot": "\nbitwise “not”\n",
  "lib.bitOr": "\nReturn the bitwise OR of the integers *e1* and *e2*.\n",
  "lib.bitXor": "\nReturn the bitwise XOR of the integers *e1* and *e2*.\n",
  "lib.boolToString": "\nConvert a boolean to a string.\n\nThis function uses the strings \"true\" and \"false\" to represent\nboolean values. Calling `toString` on a bool instead returns \"1\"\nand \"\" (sic!).\n\n\n# Inputs\n\n`b`\n\n: 1\\. Function argument\n\n# Type\n\n```\nboolToString :: bool -> string\n```\n",
  "lib.callPackageWith": "\nCall the package function in the file `fn` with the required\narguments automatically.  The function is called with the\narguments `args`, but any missing arguments are obtained from\n`autoArgs`.  This function is intended to be partially\nparameterised, e.g.,\n\n  ```nix\n  callPackage = callPackageWith pkgs;\n  pkgs = {\n    libfoo = callPackage ./foo.nix { };\n    libbar = callPackage ./bar.nix { };\n  };\n  ```\n\nIf the `libbar` function expects an argument named `libfoo`, it is\nautomatically passed as an argument.  Overrides or missing\narguments can be supplied in `args`, e.g.\n\n  ```nix\n  libbar = callPackage ./bar.nix {\n    libfoo = null;\n    enableX11 = true;\n  };\n  ```\n\n<!-- TODO: Apply \"Example:\" tag to the examples above -->\n\n# Inputs\n\n`autoArgs`\n\n: 1\\. Function argument\n\n`fn`\n\n: 2\\. Function argument\n\n`args`\n\n: 3\\. Function argument\n\n# Type\n\n```\ncallPackageWith :: AttrSet -> ((AttrSet -> a) | Path) -> AttrSet -> a\n```\n",
  "lib.callPackagesWith": "\nLike callPackage, but for a function that returns an attribute\nset of derivations. The override function is added to the\nindividual attributes.\n\n# Inputs\n\n`autoArgs`\n\n: 1\\. Function argument\n\n`fn`\n\n: 2\\. Function argument\n\n`args`\n\n: 3\\. Function argument\n\n# Type\n\n```\ncallPackagesWith :: AttrSet -> ((AttrSet -> AttrSet) | Path) -> AttrSet -> AttrSet\n```\n",
  "lib.canCleanSource": null,
  "lib.cartesianProduct": "\nReturn the cartesian product of attribute set value combinations.\n\n\n# Inputs\n\n`attrsOfLists`\n\n: Attribute set with attributes that are lists of values\n\n# Type\n\n```\ncartesianProduct :: AttrSet -> [AttrSet]\n```\n\n# Examples\n:::{.example}\n## `lib.attrsets.cartesianProduct` usage example\n\n```nix\ncartesianProduct { a = [ 1 2 ]; b = [ 10 20 ]; }\n=> [\n     { a = 1; b = 10; }\n     { a = 1; b = 20; }\n     { a = 2; b = 10; }\n     { a = 2; b = 20; }\n   ]\n```\n\n:::\n",
  "lib.cartesianProductOfSets": "\nReturn the cartesian product of attribute set value combinations.\n\n\n# Inputs\n\n`attrsOfLists`\n\n: Attribute set with attributes that are lists of values\n\n# Type\n\n```\ncartesianProduct :: AttrSet -> [AttrSet]\n```\n\n# Examples\n:::{.example}\n## `lib.attrsets.cartesianProduct` usage example\n\n```nix\ncartesianProduct { a = [ 1 2 ]; b = [ 10 20 ]; }\n=> [\n     { a = 1; b = 10; }\n     { a = 1; b = 20; }\n     { a = 2; b = 10; }\n     { a = 2; b = 20; }\n   ]\n```\n\n:::\n",
  "lib.catAttrs": "\nCollect each attribute named `attr` from a list of attribute\nsets.  Sets that don't contain the named attribute are ignored.\n\n# Inputs\n\n`attr`\n\n: The attribute name to get out of the sets.\n\n`list`\n\n: The list of attribute sets to go through\n\n# Type\n\n```\ncatAttrs :: String -> [AttrSet] -> [Any]\n```\n\n# Examples\n:::{.example}\n## `lib.attrsets.catAttrs` usage example\n\n```nix\ncatAttrs \"a\" [{a = 1;} {b = 0;} {a = 2;}]\n=> [1 2]\n```\n\n:::\n",
  "lib.checkFlag": "Return true only if there is an attribute and it is true.",
  "lib.checkListOfEnum": "\nCheck if the elements in a list are valid values from a enum, returning the identity function, or throwing an error message otherwise.\n\n\n# Inputs\n\n`msg`\n\n: 1\\. Function argument\n\n`valid`\n\n: 2\\. Function argument\n\n`given`\n\n: 3\\. Function argument\n\n# Type\n\n```\nString -> List ComparableVal -> List ComparableVal -> a -> a\n```\n\n# Examples\n:::{.example}\n## `lib.trivial.checkListOfEnum` usage example\n\n```nix\nlet colorVariants = [\"bright\" \"dark\" \"black\"]\nin checkListOfEnum \"color variants\" [ \"standard\" \"light\" \"dark\" ] colorVariants;\n=>\nerror: color variants: bright, black unexpected; valid ones: standard, light, dark\n```\n\n:::\n",
  "lib.checkReqs": "Output : are reqs satisfied? It's asserted.",
  "lib.chooseDevOutputs": "\nPick the outputs of packages to place in `buildInputs`\n\n# Inputs\n\n`pkgs`\n\n: List of packages.\n\n# Type\n\n```\nchooseDevOutputs :: [Derivation] -> [Derivation]\n```\n",
  "lib.cleanSource": "\nFilters a source tree removing version control files and directories using cleanSourceFilter.\n\n# Inputs\n\n`src`\n\n: 1\\. Function argument\n\n# Examples\n:::{.example}\n## `cleanSource` usage example\n\n```nix\ncleanSource ./.\n```\n\n:::\n",
  "lib.cleanSourceFilter": "\nA basic filter for `cleanSourceWith` that removes\ndirectories of version control system, backup files (*~)\nand some generated files.\n\n# Inputs\n\n`name`\n\n: 1\\. Function argument\n\n`type`\n\n: 2\\. Function argument\n",
  "lib.cleanSourceWith": "\nLike `builtins.filterSource`, except it will compose with itself,\nallowing you to chain multiple calls together without any\nintermediate copies being put in the nix store.\n\n# Examples\n:::{.example}\n## `cleanSourceWith` usage example\n\n```nix\nlib.cleanSourceWith {\n  filter = f;\n  src = lib.cleanSourceWith {\n    filter = g;\n    src = ./.;\n  };\n}\n# Succeeds!\n\nbuiltins.filterSource f (builtins.filterSource g ./.)\n# Fails!\n```\n\n:::\n",
  "lib.closePropagation": "See https://github.com/NixOS/nixpkgs/pull/194391 for details.",
  "lib.cmakeBool": "\nCreate a -D<condition>={TRUE,FALSE} string that can be passed to typical\nCMake invocations.\n\n\n# Inputs\n\n`condition`\n: The condition to be made true or false\n\n`flag`\n: The controlling flag of the condition\n\n# Type\n\n```\ncmakeBool :: string -> bool -> string\n```\n\n# Examples\n:::{.example}\n## `lib.strings.cmakeBool` usage example\n\n```nix\ncmakeBool \"ENABLE_STATIC_LIBS\" false\n=> \"-DENABLESTATIC_LIBS:BOOL=FALSE\"\n```\n\n:::\n",
  "lib.cmakeFeature": "\nCreate a -D<feature>:STRING=<value> string that can be passed to typical\nCMake invocations.\nThis is the most typical usage, so it deserves a special case.\n\n\n# Inputs\n\n`feature`\n: The feature to be set\n\n`value`\n: The desired value\n\n\n# Type\n\n```\ncmakeFeature :: string -> string -> string\n```\n\n# Examples\n:::{.example}\n## `lib.strings.cmakeFeature` usage example\n\n```nix\ncmakeFeature \"MODULES\" \"badblock\"\n=> \"-DMODULES:STRING=badblock\"\n```\n\n:::\n",
  "lib.cmakeOptionType": "\nCreate a `\"-D<feature>:<type>=<value>\"` string that can be passed to typical\nCMake invocations.\n\n# Inputs\n\n`feature`\n: The feature to be set\n\n`type`\n: The type of the feature to be set, as described in\n  https://cmake.org/cmake/help/latest/command/set.html\n  the possible values (case insensitive) are:\n  BOOL FILEPATH PATH STRING INTERNAL\n\n`value`\n: The desired value\n\n# Type\n\n```\ncmakeOptionType :: string -> string -> string -> string\n```\n\n# Examples\n:::{.example}\n## `lib.strings.cmakeOptionType` usage example\n\n```nix\ncmakeOptionType \"string\" \"ENGINE\" \"sdl2\"\n=> \"-DENGINE:STRING=sdl2\"\n```\n\n:::\n",
  "lib.collect": "\nRecursively collect sets that verify a given predicate named `pred`\nfrom the set `attrs`. The recursion is stopped when the predicate is\nverified.\n\n\n# Inputs\n\n`pred`\n\n: Given an attribute's value, determine if recursion should stop.\n\n`attrs`\n\n: The attribute set to recursively collect.\n\n# Type\n\n```\ncollect :: (AttrSet -> Bool) -> AttrSet -> [x]\n```\n\n# Examples\n:::{.example}\n## `lib.attrsets.collect` usage example\n\n```nix\ncollect isList { a = { b = [\"b\"]; }; c = [1]; }\n=> [[\"b\"] [1]]\n\ncollect (x: x ? outPath)\n   { a = { outPath = \"a/\"; }; b = { outPath = \"b/\"; }; }\n=> [{ outPath = \"a/\"; } { outPath = \"b/\"; }]\n```\n\n:::\n",
  "lib.commitIdFromGitRepo": "\nGet the commit id of a git repo.\n\n# Inputs\n\n`path`\n\n: 1\\. Function argument\n\n# Examples\n:::{.example}\n## `commitIdFromGitRepo` usage example\n\n```nix\ncommitIdFromGitRepo <nixpkgs/.git>\n```\n\n:::\n",
  "lib.compare": "\nC-style comparisons\n\na < b,  compare a b => -1\na == b, compare a b => 0\na > b,  compare a b => 1\n\n\n# Inputs\n\n`a`\n\n: 1\\. Function argument\n\n`b`\n\n: 2\\. Function argument\n",
  "lib.compareLists": "\nCompare two lists element-by-element with a comparison function `cmp`.\n\nList elements are compared pairwise in order by the provided comparison function `cmp`,\nthe first non-equal pair of elements determines the result.\n\n:::{.note}\nThe `<` operator can also be used to compare lists using a boolean condition. (e.g. `[1 2] < [1 3]` is `true`).\nSee also [language operators](https://nix.dev/manual/nix/stable/language/operators#comparison) for more information.\n:::\n\n# Inputs\n\n`cmp`\n\n: The comparison function `a: b: ...` must return:\n  - `0` if `a` and `b` are equal\n  - `1` if `a` is greater than `b`\n  - `-1` if `a` is less than `b`\n\n  See [lib.compare](#function-library-lib.trivial.compare) for a an example implementation.\n\n`a`\n\n: The first list\n\n`b`\n\n: The second list\n\n\n# Examples\n:::{.example}\n## `lib.lists.compareLists` usage examples\n\n```nix\ncompareLists lib.compare [] []\n=> 0\ncompareLists lib.compare [] [ \"a\" ]\n=> -1\ncompareLists lib.compare [ \"a\" ] []\n=> 1\ncompareLists lib.compare [ \"a\" \"b\" ] [ \"a\" \"c\" ]\n=> -1\n```\n\n:::\n",
  "lib.composeExtensions": "\nCompose two overlay functions and return a single overlay function that combines them.\nFor more details see: [composeManyExtensions](#function-library-lib.fixedPoints.composeManyExtensions).\n",
  "lib.composeManyExtensions": "\nComposes a list of [`overlays`](#chap-overlays) and returns a single overlay function that combines them.\n\n:::{.note}\nThe result is produced by using the update operator `//`.\nThis means nested values of previous overlays are not merged recursively.\nIn other words, previously defined attributes are replaced, ignoring the previous value, unless referenced by the overlay; for example `final: prev: { foo = final.foo + 1; }`.\n:::\n\n# Inputs\n\n`extensions`\n\n: A list of overlay functions\n  :::{.note}\n  The order of the overlays in the list is important.\n  :::\n\n: Each overlay function takes two arguments, by convention `final` and `prev`, and returns an attribute set.\n  - `final` is the result of the fixed-point function, with all overlays applied.\n  - `prev` is the result of the previous overlay function(s).\n\n# Type\n\n```\n# Pseudo code\nlet\n  #               final      prev\n  #                 ↓          ↓\n  OverlayFn = { ... } -> { ... } -> { ... };\nin\n  composeManyExtensions :: ListOf OverlayFn -> OverlayFn\n```\n\n# Examples\n:::{.example}\n## `lib.fixedPoints.composeManyExtensions` usage example\n\n```nix\nlet\n  # The \"original function\" that is extended by the overlays.\n  # Note that it doesn't have prev: as argument since no overlay function precedes it.\n  original = final: { a = 1; };\n\n  # Each overlay function has 'final' and 'prev' as arguments.\n  overlayA = final: prev: { b = final.c; c = 3; };\n  overlayB = final: prev: { c = 10; x = prev.c or 5; };\n\n  extensions = composeManyExtensions [ overlayA overlayB ];\n\n  # Caluculate the fixed point of all composed overlays.\n  fixedpoint = lib.fix (lib.extends extensions original );\n\nin fixedpoint\n=>\n{\n  a = 1;\n  b = 10;\n  c = 10;\n  x = 3;\n}\n```\n:::\n",
  "lib.concat": "\nConcatenate two lists\n\n\n# Inputs\n\n`x`\n\n: 1\\. Function argument\n\n`y`\n\n: 2\\. Function argument\n\n# Type\n\n```\nconcat :: [a] -> [a] -> [a]\n```\n\n# Examples\n:::{.example}\n## `lib.trivial.concat` usage example\n\n```nix\nconcat [ 1 2 ] [ 3 4 ]\n=> [ 1 2 3 4 ]\n```\n\n:::\n",
  "lib.concatImapStrings": "\nLike `concatMapStrings` except that the f functions also gets the\nposition as a parameter.\n\n\n# Inputs\n\n`f`\n: 1\\. Function argument\n\n`list`\n: 2\\. Function argument\n\n# Type\n\n```\nconcatImapStrings :: (int -> a -> string) -> [a] -> string\n```\n\n# Examples\n:::{.example}\n## `lib.strings.concatImapStrings` usage example\n\n```nix\nconcatImapStrings (pos: x: \"${toString pos}-${x}\") [\"foo\" \"bar\"]\n=> \"1-foo2-bar\"\n```\n\n:::\n",
  "lib.concatImapStringsSep": "\nSame as `concatMapStringsSep`, but the mapping function\nadditionally receives the position of its argument.\n\n\n# Inputs\n\n`sep`\n: Separator to add between elements\n\n`f`\n: Function that receives elements and their positions\n\n`list`\n: List of input strings\n\n# Type\n\n```\nconcatIMapStringsSep :: string -> (int -> a -> string) -> [a] -> string\n```\n\n# Examples\n:::{.example}\n## `lib.strings.concatImapStringsSep` usage example\n\n```nix\nconcatImapStringsSep \"-\" (pos: x: toString (x / pos)) [ 6 6 6 ]\n=> \"6-3-2\"\n```\n\n:::\n",
  "lib.concatLines": "\nConcatenate a list of strings, adding a newline at the end of each one.\nDefined as `concatMapStrings (s: s + \"\\n\")`.\n\n# Inputs\n\n`list`\n: List of strings. Any element that is not a string will be implicitly converted to a string.\n\n# Type\n\n```\nconcatLines :: [string] -> string\n```\n\n# Examples\n:::{.example}\n## `lib.strings.concatLines` usage example\n\n```nix\nconcatLines [ \"foo\" \"bar\" ]\n=> \"foo\\nbar\\n\"\n```\n\n:::\n",
  "lib.concatLists": "\nConcatenate a list of lists into a single list.\n",
  "lib.concatMap": "\nMap and concatenate the result.\n\n# Type\n\n```\nconcatMap :: (a -> [b]) -> [a] -> [b]\n```\n\n# Examples\n:::{.example}\n## `lib.lists.concatMap` usage example\n\n```nix\nconcatMap (x: [x] ++ [\"z\"]) [\"a\" \"b\"]\n=> [ \"a\" \"z\" \"b\" \"z\" ]\n```\n\n:::\n",
  "lib.concatMapAttrs": "\nMap each attribute in the given set and merge them into a new attribute set.\n\n\n# Inputs\n\n`f`\n\n: 1\\. Function argument\n\n`v`\n\n: 2\\. Function argument\n\n# Type\n\n```\nconcatMapAttrs :: (String -> a -> AttrSet) -> AttrSet -> AttrSet\n```\n\n# Examples\n:::{.example}\n## `lib.attrsets.concatMapAttrs` usage example\n\n```nix\nconcatMapAttrs\n  (name: value: {\n    ${name} = value;\n    ${name + value} = value;\n  })\n  { x = \"a\"; y = \"b\"; }\n=> { x = \"a\"; xa = \"a\"; y = \"b\"; yb = \"b\"; }\n```\n\n:::\n",
  "lib.concatMapAttrsStringSep": "\nLike [`concatMapStringsSep`](#function-library-lib.strings.concatMapStringsSep)\nbut takes an attribute set instead of a list.\n\n# Inputs\n\n`sep`\n: Separator to add between item strings\n\n`f`\n: Function that takes each key and value and return a string\n\n`attrs`\n: Attribute set to map from\n\n# Type\n\n```\nconcatMapAttrsStringSep :: String -> (String -> Any -> String) -> AttrSet -> String\n```\n\n# Examples\n\n:::{.example}\n## `lib.strings.concatMapAttrsStringSep` usage example\n\n```nix\nconcatMapAttrsStringSep \"\\n\" (name: value: \"${name}: foo-${value}\") { a = \"0.1.0\"; b = \"0.2.0\"; }\n=> \"a: foo-0.1.0\\nb: foo-0.2.0\"\n```\n\n:::\n",
  "lib.concatMapStrings": "\nMap a function over a list and concatenate the resulting strings.\n\n\n# Inputs\n\n`f`\n: 1\\. Function argument\n\n`list`\n: 2\\. Function argument\n\n# Type\n\n```\nconcatMapStrings :: (a -> string) -> [a] -> string\n```\n\n# Examples\n:::{.example}\n## `lib.strings.concatMapStrings` usage example\n\n```nix\nconcatMapStrings (x: \"a\" + x) [\"foo\" \"bar\"]\n=> \"afooabar\"\n```\n\n:::\n",
  "lib.concatMapStringsSep": "\nMaps a function over a list of strings and then concatenates the\nresult with the specified separator interspersed between\nelements.\n\n\n# Inputs\n\n`sep`\n: Separator to add between elements\n\n`f`\n: Function to map over the list\n\n`list`\n: List of input strings\n\n# Type\n\n```\nconcatMapStringsSep :: string -> (a -> string) -> [a] -> string\n```\n\n# Examples\n:::{.example}\n## `lib.strings.concatMapStringsSep` usage example\n\n```nix\nconcatMapStringsSep \"-\" (x: toUpper x)  [\"foo\" \"bar\" \"baz\"]\n=> \"FOO-BAR-BAZ\"\n```\n\n:::\n",
  "lib.concatStrings": "\nConcatenate a list of strings.\n\n# Type\n\n```\nconcatStrings :: [string] -> string\n```\n\n# Examples\n:::{.example}\n## `lib.strings.concatStrings` usage example\n\n```nix\nconcatStrings [\"foo\" \"bar\"]\n=> \"foobar\"\n```\n\n:::\n",
  "lib.concatStringsSep": "\nConcatenate a list of strings with a separator between each element\n\n# Inputs\n\n`sep`\n: Separator to add between elements\n\n`list`\n: List of input strings\n\n# Type\n\n```\nconcatStringsSep :: string -> [string] -> string\n```\n\n# Examples\n:::{.example}\n## `lib.strings.concatStringsSep` usage example\n\n```nix\nconcatStringsSep \"/\" [\"usr\" \"local\" \"bin\"]\n=> \"usr/local/bin\"\n```\n\n:::\n",
  "lib.condConcat": null,
  "lib.const": "\nThe constant function\n\nIgnores the second argument. If called with only one argument,\nconstructs a function that always returns a static value.\n\n\n# Inputs\n\n`x`\n\n: Value to return\n\n`y`\n\n: Value to ignore\n\n# Type\n\n```\nconst :: a -> b -> a\n```\n\n# Examples\n:::{.example}\n## `lib.trivial.const` usage example\n\n```nix\nlet f = const 5; in f 10\n=> 5\n```\n\n:::\n",
  "lib.converge": "\nReturn the fixpoint that `f` converges to when called iteratively, starting\nwith the input `x`.\n\n```\nnix-repl> converge (x: x / 2) 16\n0\n```\n\n# Inputs\n\n`f`\n\n: 1\\. Function argument\n\n`x`\n\n: 2\\. Function argument\n\n# Type\n\n```\n(a -> a) -> a -> a\n```\n",
  "lib.count": "\nCount how many elements of `list` match the supplied predicate\nfunction.\n\n# Inputs\n\n`pred`\n\n: Predicate\n\n# Type\n\n```\ncount :: (a -> bool) -> [a] -> int\n```\n\n# Examples\n:::{.example}\n## `lib.lists.count` usage example\n\n```nix\ncount (x: x == 3) [ 3 2 3 4 6 ]\n=> 2\n```\n\n:::\n",
  "lib.crossLists": "\nReturn the image of the cross product of some lists by a function.\n\n\n# Examples\n:::{.example}\n## `lib.lists.crossLists` usage example\n\n```nix\ncrossLists (x: y: \"${toString x}${toString y}\") [[1 2] [3 4]]\n=> [ \"13\" \"14\" \"23\" \"24\" ]\n```\n\nThe following function call is equivalent to the one deprecated above:\n\n```nix\nmapCartesianProduct (x: \"${toString x.a}${toString x.b}\") { a = [1 2]; b = [3 4]; }\n=> [ \"13\" \"14\" \"23\" \"24\" ]\n```\n:::\n",
  "lib.deepSeq": "\nThis is like `seq e1 e2`, except that *e1* is evaluated *deeply*:\nif it’s a list or set, its elements or attributes are also\nevaluated recursively.\n",
  "lib.defaultFunctor": "Default type functor",
  "lib.defaultMerge": null,
  "lib.defaultMergeArg": null,
  "lib.defaultTo": "\nReturn `maybeValue` if not null, otherwise return `default`.\n\n\n# Inputs\n\n`default`\n\n: 1\\. Function argument\n\n`maybeValue`\n\n: 2\\. Function argument\n\n\n# Examples\n:::{.example}\n## `lib.trivial.defaultTo` usage example\n\n```nix\ndefaultTo \"default\" null\n=> \"default\"\ndefaultTo \"default\" \"foo\"\n=> \"foo\"\ndefaultTo \"default\" false\n=> false\n```\n\n:::\n",
  "lib.defaultTypeMerge": "takes two type functors and return the merged type",
  "lib.dischargeProperties": "\nGiven a config value, expand mkMerge properties, and discharge\nany mkIf conditions.  That is, this is the place where mkIf\nconditions are actually evaluated.  The result is a list of\nconfig values.  For example, ‘mkIf false x’ yields ‘[]’,\n‘mkIf true x’ yields ‘[x]’, and\n\n  mkMerge [ 1 (mkIf true 2) (mkIf true (mkIf false 3)) ]\n\nyields ‘[ 1 2 ]’.\n\n\n# Inputs\n\n`def`\n\n: 1\\. Function argument\n",
  "lib.doRename": "\nReturn a module that help declares an option that has been renamed.\nWhen a value is defined for the old option, it is forwarded to the `to` option.\n",
  "lib.dontDistribute": "\nDisable Hydra builds of given derivation.\n\n# Inputs\n\n`drv`\n\n: 1\\. Function argument\n",
  "lib.dontRecurseIntoAttrs": "\nUndo the effect of recurseIntoAttrs.\n\n\n# Inputs\n\n`attrs`\n\n: An attribute set to not scan for derivations.\n\n# Type\n\n```\ndontRecurseIntoAttrs :: AttrSet -> AttrSet\n```\n",
  "lib.drop": "\nRemove the first (at most) N elements of a list.\n\n\n# Inputs\n\n`count`\n\n: Number of elements to drop\n\n`list`\n\n: Input list\n\n# Type\n\n```\ndrop :: int -> [a] -> [a]\n```\n\n# Examples\n:::{.example}\n## `lib.lists.drop` usage example\n\n```nix\ndrop 2 [ \"a\" \"b\" \"c\" \"d\" ]\n=> [ \"c\" \"d\" ]\ndrop 2 [ ]\n=> [ ]\n```\n\n:::\n",
  "lib.dropEnd": "\nRemove the last (at most) N elements of a list.\n\n\n# Inputs\n\n`count`\n\n: Number of elements to drop\n\n`list`\n\n: Input list\n\n# Type\n\n```\ndropEnd :: Int -> [a] -> [a]\n```\n\n# Examples\n\n:::{.example}\n## `lib.lists.dropEnd` usage example\n\n```nix\n  dropEnd 2 [ \"a\" \"b\" \"c\" \"d\" ]\n  => [ \"a\" \"b\" ]\n  dropEnd 2 [ ]\n  => [ ]\n```\n:::\n\n",
  "lib.elem": "\nReturn `true` if a value equal to *x* occurs in the list *xs*, and\n`false` otherwise.\n",
  "lib.elemAt": "\nReturn element *n* from the list *xs*. Elements are counted starting\nfrom 0. A fatal error occurs if the index is out of bounds.\n",
  "lib.enableFeature": "\nCreate an --{enable,disable}-<feature> string that can be passed to\nstandard GNU Autoconf scripts.\n\n\n# Inputs\n\n`flag`\n: 1\\. Function argument\n\n`feature`\n: 2\\. Function argument\n\n# Type\n\n```\nenableFeature :: bool -> string -> string\n```\n\n# Examples\n:::{.example}\n## `lib.strings.enableFeature` usage example\n\n```nix\nenableFeature true \"shared\"\n=> \"--enable-shared\"\nenableFeature false \"shared\"\n=> \"--disable-shared\"\n```\n\n:::\n",
  "lib.enableFeatureAs": "\nCreate an --{enable-<feature>=<value>,disable-<feature>} string that can be passed to\nstandard GNU Autoconf scripts.\n\n\n# Inputs\n\n`flag`\n: 1\\. Function argument\n\n`feature`\n: 2\\. Function argument\n\n`value`\n: 3\\. Function argument\n\n# Type\n\n```\nenableFeatureAs :: bool -> string -> string -> string\n```\n\n# Examples\n:::{.example}\n## `lib.strings.enableFeatureAs` usage example\n\n```nix\nenableFeatureAs true \"shared\" \"foo\"\n=> \"--enable-shared=foo\"\nenableFeatureAs false \"shared\" (throw \"ignored\")\n=> \"--disable-shared\"\n```\n\n:::\n",
  "lib.escape": "\nEscape occurrence of the elements of `list` in `string` by\nprefixing it with a backslash.\n\n\n# Inputs\n\n`list`\n: 1\\. Function argument\n\n`string`\n: 2\\. Function argument\n\n# Type\n\n```\nescape :: [string] -> string -> string\n```\n\n# Examples\n:::{.example}\n## `lib.strings.escape` usage example\n\n```nix\nescape [\"(\" \")\"] \"(foo)\"\n=> \"\\\\(foo\\\\)\"\n```\n\n:::\n",
  "lib.escapeRegex": "\nTurn a string `s` into an exact regular expression\n\n# Inputs\n\n`s`\n: 1\\. Function argument\n\n# Type\n\n```\nescapeRegex :: string -> string\n```\n\n# Examples\n:::{.example}\n## `lib.strings.escapeRegex` usage example\n\n```nix\nescapeRegex \"[^a-z]*\"\n=> \"\\\\[\\\\^a-z]\\\\*\"\n```\n\n:::\n",
  "lib.escapeShellArg": "\nQuote `string` to be used safely within the Bourne shell if it has any\nspecial characters.\n\n\n# Inputs\n\n`string`\n: 1\\. Function argument\n\n# Type\n\n```\nescapeShellArg :: string -> string\n```\n\n# Examples\n:::{.example}\n## `lib.strings.escapeShellArg` usage example\n\n```nix\nescapeShellArg \"esc'ape\\nme\"\n=> \"'esc'\\\\''ape\\nme'\"\n```\n\n:::\n",
  "lib.escapeShellArgs": "\nQuote all arguments that have special characters to be safely passed to the\nBourne shell.\n\n# Inputs\n\n`args`\n: 1\\. Function argument\n\n# Type\n\n```\nescapeShellArgs :: [string] -> string\n```\n\n# Examples\n:::{.example}\n## `lib.strings.escapeShellArgs` usage example\n\n```nix\nescapeShellArgs [\"one\" \"two three\" \"four'five\"]\n=> \"one 'two three' 'four'\\\\''five'\"\n```\n\n:::\n",
  "lib.escapeURL": "\nEscape the `string` so it can be safely placed inside a URL\nquery.\n\n# Inputs\n\n`string`\n: 1\\. Function argument\n\n# Type\n\n```\nescapeURL :: string -> string\n```\n\n# Examples\n:::{.example}\n## `lib.strings.escapeURL` usage example\n\n```nix\nescapeURL \"foo/bar baz\"\n=> \"foo%2Fbar%20baz\"\n```\n\n:::\n",
  "lib.escapeXML": "\nEscapes a string `s` such that it is safe to include verbatim in an XML\ndocument.\n\n# Inputs\n\n`s`\n: 1\\. Function argument\n\n# Type\n\n```\nescapeXML :: string -> string\n```\n\n# Examples\n:::{.example}\n## `lib.strings.escapeXML` usage example\n\n```nix\nescapeXML ''\"test\" 'test' < & >''\n=> \"&quot;test&quot; &apos;test&apos; &lt; &amp; &gt;\"\n```\n\n:::\n",
  "lib.evalModules": "\nSee https://nixos.org/manual/nixpkgs/unstable/#module-system-lib-evalModules\nor file://./../doc/module-system/module-system.chapter.md\n\n!!! Please think twice before adding to this argument list! The more\nthat is specified here instead of in the modules themselves the harder\nit is to transparently move a set of modules to be a submodule of another\nconfig (as the proper arguments need to be replicated at each call to\nevalModules) and the less declarative the module set is.\n",
  "lib.evalOptionValue": "\nMerge all the definitions of an option to produce the final\nconfig value.\n\n\n# Inputs\n\n`loc`\n\n: 1\\. Function argument\n\n`opt`\n\n: 2\\. Function argument\n\n`defs`\n\n: 3\\. Function argument\n",
  "lib.extend": "\nPatch the Nixpkgs library\n\nA function that applies patches onto the nixpkgs library.\nUsage is discouraged for most scenarios.\n\n:::{.note}\nThe name `extends` is a bit misleading, as it doesn't actually extend the library, but rather patches it.\nIt is merely a consequence of being implemented by `makeExtensible`.\n:::\n\n# Inputs\n\n- An \"extension function\" `f` that returns attributes that will be updated in the returned Nixpkgs library.\n\n# Output\n\nA patched Nixpkgs library.\n\n:::{.warning}\nThis functionality is intended as an escape hatch for when the provided version of the Nixpkgs library has a flaw.\n\nIf you were to use it to add new functionality, you will run into compatibility and interoperability issues.\n:::\n",
  "lib.extendDerivation": "\nAdd attributes to each output of a derivation without changing\nthe derivation itself and check a given condition when evaluating.\n\n# Inputs\n\n`condition`\n\n: 1\\. Function argument\n\n`passthru`\n\n: 2\\. Function argument\n\n`drv`\n\n: 3\\. Function argument\n\n# Type\n\n```\nextendDerivation :: Bool -> Any -> Derivation -> Derivation\n```\n",
  "lib.extendMkDerivation": "\nDefine a `mkDerivation`-like function based on another `mkDerivation`-like function.\n\n[`stdenv.mkDerivation`](#part-stdenv) gives access to\nits final set of derivation attributes when it is passed a function,\nor when it is passed an overlay-style function in `overrideAttrs`.\n\nInstead of composing new `stdenv.mkDerivation`-like build helpers\nusing normal function composition,\n`extendMkDerivation` makes sure that the returned build helper\nsupports such first class recursion like `mkDerivation` does.\n\n`extendMkDerivation` takes an extra attribute set to configure its behaviour.\nOne can optionally specify\n`transformDrv` to specify a function to apply to the result derivation,\nor `inheritFunctionArgs` to decide whether to inherit the `__functionArgs`\nfrom the base build helper.\n\n# Inputs\n\n`extendMkDerivation`-specific configurations\n: `constructDrv`: Base build helper, the `mkDerivation`-like build helper to extend.\n: `excludeDrvArgNames`: Argument names not to pass from the input fixed-point arguments to `constructDrv`. Note: It doesn't apply to the updating arguments returned by `extendDrvArgs`.\n: `extendDrvArgs` : An extension (overlay) of the argument set, like the one taken by [overrideAttrs](#sec-pkg-overrideAttrs) but applied before passing to `constructDrv`.\n: `inheritFunctionArgs`: Whether to inherit `__functionArgs` from the base build helper (default to `true`).\n: `transformDrv`: Function to apply to the result derivation (default to `lib.id`).\n\n# Type\n\n```\nextendMkDerivation ::\n  {\n    constructDrv :: ((FixedPointArgs | AttrSet) -> a)\n    excludeDrvArgNames :: [ String ],\n    extendDrvArgs :: (AttrSet -> AttrSet -> AttrSet)\n    inheritFunctionArgs :: Bool,\n    transformDrv :: a -> a,\n  }\n  -> (FixedPointArgs | AttrSet) -> a\n\nFixedPointArgs = AttrSet -> AttrSet\na = Derivation when defining a build helper\n```\n\n# Examples\n\n:::{.example}\n## `lib.customisation.extendMkDerivation` usage example\n```nix-repl\nmkLocalDerivation = lib.extendMkDerivation {\n  constructDrv = pkgs.stdenv.mkDerivation;\n  excludeDrvArgNames = [ \"specialArg\" ];\n  extendDrvArgs =\n    finalAttrs: args@{ preferLocalBuild ? true, allowSubstitute ? false, specialArg ? (_: false), ... }:\n    { inherit preferLocalBuild allowSubstitute; passthru = { inherit specialArg; } // args.passthru or { }; };\n}\n\nmkLocalDerivation.__functionArgs\n=> { allowSubstitute = true; preferLocalBuild = true; specialArg = true; }\n\nmkLocalDerivation { inherit (pkgs.hello) pname version src; specialArg = _: false; }\n=> «derivation /nix/store/xirl67m60ahg6jmzicx43a81g635g8z8-hello-2.12.1.drv»\n\nmkLocalDerivation (finalAttrs: { inherit (pkgs.hello) pname version src; specialArg = _: false; })\n=> «derivation /nix/store/xirl67m60ahg6jmzicx43a81g635g8z8-hello-2.12.1.drv»\n\n(mkLocalDerivation (finalAttrs: { inherit (pkgs.hello) pname version src; passthru = { foo = \"a\"; bar = \"${finalAttrs.passthru.foo}b\"; }; })).bar\n=> \"ab\"\n```\n:::\n\n:::{.note}\nIf `transformDrv` is specified,\nit should take care of existing attributes that perform overriding\n(e.g., [`overrideAttrs`](#sec-pkg-overrideAttrs))\nto ensure that the overriding functionality of the result derivation\nwork as expected.\nModifications that breaks the overriding include\ndirect [attribute set update](https://nixos.org/manual/nix/stable/language/operators#update)\nand [`lib.extendDerivation`](#function-library-lib.customisation.extendDerivation).\n:::\n",
  "lib.extends": "\nExtend a function using an overlay.\n\nOverlays allow modifying and extending fixed-point functions, specifically ones returning attribute sets.\nA fixed-point function is a function which is intended to be evaluated by passing the result of itself as the argument.\nThis is possible due to Nix's lazy evaluation.\n\nA fixed-point function returning an attribute set has the form\n\n```nix\nfinal: {\n  # attributes\n}\n```\n\nwhere `final` refers to the lazily evaluated attribute set returned by the fixed-point function.\n\nAn overlay to such a fixed-point function has the form\n\n```nix\nfinal: prev: {\n  # attributes\n}\n```\n\nwhere `prev` refers to the result of the original function to `final`, and `final` is the result of the composition of the overlay and the original function.\n\nApplying an overlay is done with `extends`:\n\n```nix\nlet\n  f = final: {\n    # attributes\n  };\n  overlay = final: prev: {\n    # attributes\n  };\nin extends overlay f;\n```\n\nTo get the value of `final`, use `lib.fix`:\n\n```nix\nlet\n  f = final: {\n    # attributes\n  };\n  overlay = final: prev: {\n    # attributes\n  };\n  g = extends overlay f;\nin fix g\n```\n\n:::{.note}\nThe argument to the given fixed-point function after applying an overlay will *not* refer to its own return value, but rather to the value after evaluating the overlay function.\n\nThe given fixed-point function is called with a separate argument than if it was evaluated with `lib.fix`.\n:::\n\n:::{.example}\n\n# Extend a fixed-point function with an overlay\n\nDefine a fixed-point function `f` that expects its own output as the argument `final`:\n\n```nix-repl\nf = final: {\n  # Constant value a\n  a = 1;\n\n  # b depends on the final value of a, available as final.a\n  b = final.a + 2;\n}\n```\n\nEvaluate this using [`lib.fix`](#function-library-lib.fixedPoints.fix) to get the final result:\n\n```nix-repl\nfix f\n=> { a = 1; b = 3; }\n```\n\nAn overlay represents a modification or extension of such a fixed-point function.\nHere's an example of an overlay:\n\n```nix-repl\noverlay = final: prev: {\n  # Modify the previous value of a, available as prev.a\n  a = prev.a + 10;\n\n  # Extend the attribute set with c, letting it depend on the final values of a and b\n  c = final.a + final.b;\n}\n```\n\nUse `extends overlay f` to apply the overlay to the fixed-point function `f`.\nThis produces a new fixed-point function `g` with the combined behavior of `f` and `overlay`:\n\n```nix-repl\ng = extends overlay f\n```\n\nThe result is a function, so we can't print it directly, but it's the same as:\n\n```nix-repl\ng' = final: {\n  # The constant from f, but changed with the overlay\n  a = 1 + 10;\n\n  # Unchanged from f\n  b = final.a + 2;\n\n  # Extended in the overlay\n  c = final.a + final.b;\n}\n```\n\nEvaluate this using [`lib.fix`](#function-library-lib.fixedPoints.fix) again to get the final result:\n\n```nix-repl\nfix g\n=> { a = 11; b = 13; c = 24; }\n```\n:::\n\n# Inputs\n\n`overlay`\n\n: The overlay to apply to the fixed-point function\n\n`f`\n\n: The fixed-point function\n\n# Type\n\n```\nextends :: (Attrs -> Attrs -> Attrs) # The overlay to apply to the fixed-point function\n        -> (Attrs -> Attrs) # A fixed-point function\n        -> (Attrs -> Attrs) # The resulting fixed-point function\n```\n\n# Examples\n:::{.example}\n## `lib.fixedPoints.extends` usage example\n\n```nix\nf = final: { a = 1; b = final.a + 2; }\n\nfix f\n=> { a = 1; b = 3; }\n\nfix (extends (final: prev: { a = prev.a + 10; }) f)\n=> { a = 11; b = 13; }\n\nfix (extends (final: prev: { b = final.a + 5; }) f)\n=> { a = 1; b = 6; }\n\nfix (extends (final: prev: { c = final.a + final.b; }) f)\n=> { a = 1; b = 3; c = 4; }\n```\n\n:::\n",
  "lib.fileContents": "\nRead the contents of a file removing the trailing \\n\n\n\n# Inputs\n\n`file`\n: 1\\. Function argument\n\n# Type\n\n```\nfileContents :: path -> string\n```\n\n# Examples\n:::{.example}\n## `lib.strings.fileContents` usage example\n\n```nix\n$ echo \"1.0\" > ./version\n\nfileContents ./version\n=> \"1.0\"\n```\n\n:::\n",
  "lib.filter": "\nReturn a list consisting of the elements of *list* for which the\nfunction *f* returns `true`.\n",
  "lib.filterAttrs": "\nFilter an attribute set by removing all attributes for which the\ngiven predicate return false.\n\n\n# Inputs\n\n`pred`\n\n: Predicate taking an attribute name and an attribute value, which returns `true` to include the attribute, or `false` to exclude the attribute.\n\n`set`\n\n: The attribute set to filter\n\n# Type\n\n```\nfilterAttrs :: (String -> Any -> Bool) -> AttrSet -> AttrSet\n```\n\n# Examples\n:::{.example}\n## `lib.attrsets.filterAttrs` usage example\n\n```nix\nfilterAttrs (n: v: n == \"foo\") { foo = 1; bar = 2; }\n=> { foo = 1; }\n```\n\n:::\n",
  "lib.filterAttrsRecursive": "\nFilter an attribute set recursively by removing all attributes for\nwhich the given predicate return false.\n\n\n# Inputs\n\n`pred`\n\n: Predicate taking an attribute name and an attribute value, which returns `true` to include the attribute, or `false` to exclude the attribute.\n\n`set`\n\n: The attribute set to filter\n\n# Type\n\n```\nfilterAttrsRecursive :: (String -> Any -> Bool) -> AttrSet -> AttrSet\n```\n\n# Examples\n:::{.example}\n## `lib.attrsets.filterAttrsRecursive` usage example\n\n```nix\nfilterAttrsRecursive (n: v: v != null) { foo = { bar = null; }; }\n=> { foo = {}; }\n```\n\n:::\n",
  "lib.filterOverrides": "\nGiven a list of config values, process the mkOverride properties,\nthat is, return the values that have the highest (that is,\nnumerically lowest) priority, and strip the mkOverride\nproperties.  For example,\n\n  [ { file = \"/1\"; value = mkOverride 10 \"a\"; }\n    { file = \"/2\"; value = mkOverride 20 \"b\"; }\n    { file = \"/3\"; value = \"z\"; }\n    { file = \"/4\"; value = mkOverride 10 \"d\"; }\n  ]\n\nyields\n\n  [ { file = \"/1\"; value = \"a\"; }\n    { file = \"/4\"; value = \"d\"; }\n  ]\n\nNote that \"z\" has the default priority 100.\n\n\n# Inputs\n\n`defs`\n\n: 1\\. Function argument\n",
  "lib.findFirst": "\nFind the first element in the list matching the specified\npredicate or return `default` if no such element exists.\n\n# Inputs\n\n`pred`\n\n: Predicate\n\n`default`\n\n: Default value to return\n\n`list`\n\n: Input list\n\n# Type\n\n```\nfindFirst :: (a -> bool) -> a -> [a] -> a\n```\n\n# Examples\n:::{.example}\n## `lib.lists.findFirst` usage example\n\n```nix\nfindFirst (x: x > 3) 7 [ 1 6 4 ]\n=> 6\nfindFirst (x: x > 9) 7 [ 1 6 4 ]\n=> 7\n```\n\n:::\n",
  "lib.findSingle": "\nFind the sole element in the list matching the specified\npredicate.\n\nReturns `default` if no such element exists, or\n`multiple` if there are multiple matching elements.\n\n\n# Inputs\n\n`pred`\n\n: Predicate\n\n`default`\n\n: Default value to return if element was not found.\n\n`multiple`\n\n: Default value to return if more than one element was found\n\n`list`\n\n: Input list\n\n# Type\n\n```\nfindSingle :: (a -> bool) -> a -> a -> [a] -> a\n```\n\n# Examples\n:::{.example}\n## `lib.lists.findSingle` usage example\n\n```nix\nfindSingle (x: x == 3) \"none\" \"multiple\" [ 1 3 3 ]\n=> \"multiple\"\nfindSingle (x: x == 3) \"none\" \"multiple\" [ 1 3 ]\n=> 3\nfindSingle (x: x == 3) \"none\" \"multiple\" [ 1 9 ]\n=> \"none\"\n```\n\n:::\n",
  "lib.fix": "\n`fix f` computes the fixed point of the given function `f`. In other words, the return value is `x` in `x = f x`.\n\n`f` must be a lazy function.\nThis means that `x` must be a value that can be partially evaluated,\nsuch as an attribute set, a list, or a function.\nThis way, `f` can use one part of `x` to compute another part.\n\n**Relation to syntactic recursion**\n\nThis section explains `fix` by refactoring from syntactic recursion to a call of `fix` instead.\n\nFor context, Nix lets you define attributes in terms of other attributes syntactically using the [`rec { }` syntax](https://nixos.org/manual/nix/stable/language/constructs.html#recursive-sets).\n\n```nix\nnix-repl> rec {\n  foo = \"foo\";\n  bar = \"bar\";\n  foobar = foo + bar;\n}\n{ bar = \"bar\"; foo = \"foo\"; foobar = \"foobar\"; }\n```\n\nThis is convenient when constructing a value to pass to a function for example,\nbut an equivalent effect can be achieved with the `let` binding syntax:\n\n```nix\nnix-repl> let self = {\n  foo = \"foo\";\n  bar = \"bar\";\n  foobar = self.foo + self.bar;\n}; in self\n{ bar = \"bar\"; foo = \"foo\"; foobar = \"foobar\"; }\n```\n\nBut in general you can get more reuse out of `let` bindings by refactoring them to a function.\n\n```nix\nnix-repl> f = self: {\n  foo = \"foo\";\n  bar = \"bar\";\n  foobar = self.foo + self.bar;\n}\n```\n\nThis is where `fix` comes in, it contains the syntactic recursion that's not in `f` anymore.\n\n```nix\nnix-repl> fix = f:\n  let self = f self; in self;\n```\n\nBy applying `fix` we get the final result.\n\n```nix\nnix-repl> fix f\n{ bar = \"bar\"; foo = \"foo\"; foobar = \"foobar\"; }\n```\n\nSuch a refactored `f` using `fix` is not useful by itself.\nSee [`extends`](#function-library-lib.fixedPoints.extends) for an example use case.\nThere `self` is also often called `final`.\n\n# Inputs\n\n`f`\n\n: 1\\. Function argument\n\n# Type\n\n```\nfix :: (a -> a) -> a\n```\n\n# Examples\n:::{.example}\n## `lib.fixedPoints.fix` usage example\n\n```nix\nfix (self: { foo = \"foo\"; bar = \"bar\"; foobar = self.foo + self.bar; })\n=> { bar = \"bar\"; foo = \"foo\"; foobar = \"foobar\"; }\n\nfix (self: [ 1 2 (elemAt self 0 + elemAt self 1) ])\n=> [ 1 2 3 ]\n```\n\n:::\n",
  "lib.fix' (Prime)": "\nA variant of `fix` that records the original recursive attribute set in the\nresult, in an attribute named `__unfix__`.\n\nThis is useful in combination with the `extends` function to\nimplement deep overriding.\n\n# Inputs\n\n`f`\n\n: 1\\. Function argument\n",
  "lib.fixMergeModules": "\nCompatibility.\n\n\n# Inputs\n\n`modules`\n\n: 1\\. Function argument\n\n`args`\n\n: 2\\. Function argument\n",
  "lib.fixedWidthNumber": "\nFormat a number adding leading zeroes up to fixed width.\n\n\n# Inputs\n\n`width`\n: 1\\. Function argument\n\n`n`\n: 2\\. Function argument\n\n# Type\n\n```\nfixedWidthNumber :: int -> int -> string\n```\n\n# Examples\n:::{.example}\n## `lib.strings.fixedWidthNumber` usage example\n\n```nix\nfixedWidthNumber 5 15\n=> \"00015\"\n```\n\n:::\n",
  "lib.fixedWidthString": "\nCreate a fixed width string with additional prefix to match\nrequired width.\n\nThis function will fail if the input string is longer than the\nrequested length.\n\n\n# Inputs\n\n`width`\n: 1\\. Function argument\n\n`filler`\n: 2\\. Function argument\n\n`str`\n: 3\\. Function argument\n\n# Type\n\n```\nfixedWidthString :: int -> string -> string -> string\n```\n\n# Examples\n:::{.example}\n## `lib.strings.fixedWidthString` usage example\n\n```nix\nfixedWidthString 5 \"0\" (toString 15)\n=> \"00015\"\n```\n\n:::\n",
  "lib.fixupOptionType": "TODO: Merge this into mergeOptionDecls",
  "lib.flatten": "\nFlatten the argument into a single list; that is, nested lists are\nspliced into the top-level lists.\n\n\n# Inputs\n\n`x`\n\n: 1\\. Function argument\n\n\n# Examples\n:::{.example}\n## `lib.lists.flatten` usage example\n\n```nix\nflatten [1 [2 [3] 4] 5]\n=> [1 2 3 4 5]\nflatten 1\n=> [1]\n```\n\n:::\n",
  "lib.flip": "\nFlip the order of the arguments of a binary function.\n\n\n# Inputs\n\n`f`\n\n: 1\\. Function argument\n\n`a`\n\n: 2\\. Function argument\n\n`b`\n\n: 3\\. Function argument\n\n# Type\n\n```\nflip :: (a -> b -> c) -> (b -> a -> c)\n```\n\n# Examples\n:::{.example}\n## `lib.trivial.flip` usage example\n\n```nix\nflip concat [1] [2]\n=> [ 2 1 ]\n```\n\n:::\n",
  "lib.fold": "\n`fold` is an alias of `foldr` for historic reasons\n",
  "lib.foldArgs": null,
  "lib.foldAttrs": "\nApply fold functions to values grouped by key.\n\n\n# Inputs\n\n`op`\n\n: A function, given a value and a collector combines the two.\n\n`nul`\n\n: The starting value.\n\n`list_of_attrs`\n\n: A list of attribute sets to fold together by key.\n\n# Type\n\n```\nfoldAttrs :: (Any -> Any -> Any) -> Any -> [AttrSets] -> Any\n```\n\n# Examples\n:::{.example}\n## `lib.attrsets.foldAttrs` usage example\n\n```nix\nfoldAttrs (item: acc: [item] ++ acc) [] [{ a = 2; } { a = 3; }]\n=> { a = [ 2 3 ]; }\n```\n\n:::\n",
  "lib.foldl": "\n“left fold”, like `foldr`, but from the left:\n\n`foldl op nul [x_1 x_2 ... x_n] == op (... (op (op nul x_1) x_2) ... x_n)`.\n\n# Inputs\n\n`op`\n\n: 1\\. Function argument\n\n`nul`\n\n: 2\\. Function argument\n\n`list`\n\n: 3\\. Function argument\n\n# Type\n\n```\nfoldl :: (b -> a -> b) -> b -> [a] -> b\n```\n\n# Examples\n:::{.example}\n## `lib.lists.foldl` usage example\n\n```nix\nlconcat = foldl (a: b: a + b) \"z\"\nlconcat [ \"a\" \"b\" \"c\" ]\n=> \"zabc\"\n# different types\nlstrange = foldl (str: int: str + toString (int + 1)) \"a\"\nlstrange [ 1 2 3 4 ]\n=> \"a2345\"\n```\n\n:::\n",
  "lib.foldl' (Prime)": "\nReduce a list by applying a binary operator from left to right,\nstarting with an initial accumulator.\n\nBefore each application of the operator, the accumulator value is evaluated.\nThis behavior makes this function stricter than [`foldl`](#function-library-lib.lists.foldl).\n\nUnlike [`builtins.foldl'`](https://nixos.org/manual/nix/unstable/language/builtins.html#builtins-foldl'),\nthe initial accumulator argument is evaluated before the first iteration.\n\nA call like\n\n```nix\nfoldl' op acc₀ [ x₀ x₁ x₂ ... xₙ₋₁ xₙ ]\n```\n\nis (denotationally) equivalent to the following,\nbut with the added benefit that `foldl'` itself will never overflow the stack.\n\n```nix\nlet\n  acc₁   = builtins.seq acc₀   (op acc₀   x₀  );\n  acc₂   = builtins.seq acc₁   (op acc₁   x₁  );\n  acc₃   = builtins.seq acc₂   (op acc₂   x₂  );\n  ...\n  accₙ   = builtins.seq accₙ₋₁ (op accₙ₋₁ xₙ₋₁);\n  accₙ₊₁ = builtins.seq accₙ   (op accₙ   xₙ  );\nin\naccₙ₊₁\n\n# Or ignoring builtins.seq\nop (op (... (op (op (op acc₀ x₀) x₁) x₂) ...) xₙ₋₁) xₙ\n```\n\n# Inputs\n\n`op`\n\n: The binary operation to run, where the two arguments are:\n\n1. `acc`: The current accumulator value: Either the initial one for the first iteration, or the result of the previous iteration\n2. `x`: The corresponding list element for this iteration\n\n`acc`\n\n: The initial accumulator value.\n\n  The accumulator value is evaluated in any case before the first iteration starts.\n\n  To avoid evaluation even before the `list` argument is given an eta expansion can be used:\n\n  ```nix\n  list: lib.foldl' op acc list\n  ```\n\n`list`\n\n: The list to fold\n\n# Type\n\n```\nfoldl' :: (acc -> x -> acc) -> acc -> [x] -> acc\n```\n\n# Examples\n:::{.example}\n## `lib.lists.foldl'` usage example\n\n```nix\nfoldl' (acc: x: acc + x) 0 [1 2 3]\n=> 6\n```\n\n:::\n",
  "lib.foldlAttrs": "\nLike [`lib.lists.foldl'`](#function-library-lib.lists.foldl-prime) but for attribute sets.\nIterates over every name-value pair in the given attribute set.\nThe result of the callback function is often called `acc` for accumulator. It is passed between callbacks from left to right and the final `acc` is the return value of `foldlAttrs`.\n\nAttention:\n\nThere is a completely different function `lib.foldAttrs`\nwhich has nothing to do with this function, despite the similar name.\n\n\n# Inputs\n\n`f`\n\n: 1\\. Function argument\n\n`init`\n\n: 2\\. Function argument\n\n`set`\n\n: 3\\. Function argument\n\n# Type\n\n```\nfoldlAttrs :: ( a -> String -> b -> a ) -> a -> { ... :: b } -> a\n```\n\n# Examples\n:::{.example}\n## `lib.attrsets.foldlAttrs` usage example\n\n```nix\nfoldlAttrs\n  (acc: name: value: {\n    sum = acc.sum + value;\n    names = acc.names ++ [name];\n  })\n  { sum = 0; names = []; }\n  {\n    foo = 1;\n    bar = 10;\n  }\n->\n  {\n    sum = 11;\n    names = [\"bar\" \"foo\"];\n  }\n\nfoldlAttrs\n  (throw \"function not needed\")\n  123\n  {};\n->\n  123\n\nfoldlAttrs\n  (acc: _: _: acc)\n  3\n  { z = throw \"value not needed\"; a = throw \"value not needed\"; };\n->\n  3\n\nThe accumulator doesn't have to be an attrset.\nIt can be as simple as a number or string.\n\nfoldlAttrs\n  (acc: _: v: acc * 10 + v)\n  1\n  { z = 1; a = 2; };\n->\n  121\n```\n\n:::\n",
  "lib.foldr": "\n`fold` is an alias of `foldr` for historic reasons\n",
  "lib.forEach": "\nApply the function to each element in the list.\nSame as `map`, but arguments flipped.\n\n# Inputs\n\n`xs`\n\n: 1\\. Function argument\n\n`f`\n\n: 2\\. Function argument\n\n# Type\n\n```\nforEach :: [a] -> (a -> b) -> [b]\n```\n\n# Examples\n:::{.example}\n## `lib.lists.forEach` usage example\n\n```nix\nforEach [ 1 2 ] (x:\n  toString x\n)\n=> [ \"1\" \"2\" ]\n```\n\n:::\n",
  "lib.fromHexString": "\nConvert a hexadecimal string to it's integer representation.\n\n# Type\n\n```\nfromHexString :: String -> [ String ]\n```\n\n# Examples\n\n```nix\nfromHexString \"FF\"\n=> 255\n\nfromHexString (builtins.hashString \"sha256\" \"test\")\n=> 9223372036854775807\n```\n",
  "lib.fullDepEntry": null,
  "lib.functionArgs": "\nExtract the expected function arguments from a function.\nThis works both with nix-native { a, b ? foo, ... }: style\nfunctions and functions with args set with 'setFunctionArgs'. It\nhas the same return type and semantics as builtins.functionArgs.\nsetFunctionArgs : (a → b) → Map String Bool.\n\n\n# Inputs\n\n`f`\n\n: 1\\. Function argument\n",
  "lib.genAttrs": "\nGenerate an attribute set by mapping a function over a list of\nattribute names.\n\n\n# Inputs\n\n`names`\n\n: Names of values in the resulting attribute set.\n\n`f`\n\n: A function, given the name of the attribute, returns the attribute's value.\n\n# Type\n\n```\ngenAttrs :: [ String ] -> (String -> Any) -> AttrSet\n```\n\n# Examples\n:::{.example}\n## `lib.attrsets.genAttrs` usage example\n\n```nix\ngenAttrs [ \"foo\" \"bar\" ] (name: \"x_\" + name)\n=> { foo = \"x_foo\"; bar = \"x_bar\"; }\n```\n\n:::\n",
  "lib.genList": "\nGenerate list of size *length*, with each element *i* equal to the\nvalue returned by *generator* `i`. For example,\n\n```nix\nbuiltins.genList (x: x * x) 5\n```\n\nreturns the list `[ 0 1 4 9 16 ]`.\n",
  "lib.genericClosure": "\n`builtins.genericClosure` iteratively computes the transitive closure over an arbitrary relation defined by a function.\n\nIt takes *attrset* with two attributes named `startSet` and `operator`, and returns a list of attribute sets:\n\n- `startSet`:\n  The initial list of attribute sets.\n\n- `operator`:\n  A function that takes an attribute set and returns a list of attribute sets.\n  It defines how each item in the current set is processed and expanded into more items.\n\nEach attribute set in the list `startSet` and the list returned by `operator` must have an attribute `key`, which must support equality comparison.\nThe value of `key` can be one of the following types:\n\n- [Int](@docroot@/language/types.md#type-int)\n- [Float](@docroot@/language/types.md#type-float)\n- [Boolean](@docroot@/language/types.md#type-boolean)\n- [String](@docroot@/language/types.md#type-string)\n- [Path](@docroot@/language/types.md#type-path)\n- [List](@docroot@/language/types.md#list)\n\nThe result is produced by calling the `operator` on each `item` that has not been called yet, including newly added items, until no new items are added.\nItems are compared by their `key` attribute.\n\nCommon usages are:\n\n- Generating unique collections of items, such as dependency graphs.\n- Traversing through structures that may contain cycles or loops.\n- Processing data structures with complex internal relationships.\n\n> **Example**\n>\n> ```nix\n> builtins.genericClosure {\n>   startSet = [ {key = 5;} ];\n>   operator = item: [{\n>     key = if (item.key / 2 ) * 2 == item.key\n>          then item.key / 2\n>          else 3 * item.key + 1;\n>   }];\n> }\n> ```\n>\n> evaluates to\n>\n> ```nix\n> [ { key = 5; } { key = 16; } { key = 8; } { key = 4; } { key = 2; } { key = 1; } ]\n> ```\n",
  "lib.getAttr": "\n`getAttr` returns the attribute named *s* from *set*. Evaluation\naborts if the attribute doesn’t exist. This is a dynamic version of\nthe `.` operator, since *s* is an expression rather than an\nidentifier.\n",
  "lib.getAttrFromPath": "\nLike `attrByPath`, but without a default value. If it doesn't find the\npath it will throw an error.\n\nNix has an [attribute selection operator](https://nixos.org/manual/nix/stable/language/operators#attribute-selection) which is sufficient for such queries, as long as the number of attributes is static. For example:\n\n```nix\nx.a.b == getAttrByPath [\"a\" \"b\"] x\n# and\nx.${f p}.\"example.com\" == getAttrByPath [ (f p) \"example.com\" ] x\n```\n\n\n# Inputs\n\n`attrPath`\n\n: A list of strings representing the attribute path to get from `set`\n\n`set`\n\n: The nested attribute set to find the value in.\n\n# Type\n\n```\ngetAttrFromPath :: [String] -> AttrSet -> Any\n```\n\n# Examples\n:::{.example}\n## `lib.attrsets.getAttrFromPath` usage example\n\n```nix\nx = { a = { b = 3; }; }\ngetAttrFromPath [\"a\" \"b\"] x\n=> 3\ngetAttrFromPath [\"z\" \"z\"] x\n=> error: cannot find attribute `z.z'\n```\n\n:::\n",
  "lib.getAttrs": "\nGiven a set of attribute names, return the set of the corresponding\nattributes from the given set.\n\n\n# Inputs\n\n`names`\n\n: A list of attribute names to get out of `set`\n\n`attrs`\n\n: The set to get the named attributes from\n\n# Type\n\n```\ngetAttrs :: [String] -> AttrSet -> AttrSet\n```\n\n# Examples\n:::{.example}\n## `lib.attrsets.getAttrs` usage example\n\n```nix\ngetAttrs [ \"a\" \"b\" ] { a = 1; b = 2; c = 3; }\n=> { a = 1; b = 2; }\n```\n\n:::\n",
  "lib.getBin": "\nGet a package's `bin` output.\nIf the output does not exist, fallback to `.out` and then to the default.\n\n# Inputs\n\n`pkg`\n\n: The package whose `bin` output will be retrieved.\n\n# Type\n\n```\ngetBin :: Derivation -> Derivation\n```\n\n# Examples\n:::{.example}\n## `lib.attrsets.getBin` usage example\n\n```nix\n\"${getBin pkgs.openssl}\"\n=> \"/nix/store/00000000000000000000000000000000-openssl-1.0.1r\"\n```\n\n:::\n",
  "lib.getDev": "\nGet a package's `dev` output.\nIf the output does not exist, fallback to `.out` and then to the default.\n\n# Inputs\n\n`pkg`\n\n: The package whose `dev` output will be retrieved.\n\n# Type\n\n```\ngetDev :: Derivation -> Derivation\n```\n\n# Examples\n:::{.example}\n## `lib.attrsets.getDev` usage example\n\n```nix\n\"${getDev pkgs.openssl}\"\n=> \"/nix/store/9rz8gxhzf8sw4kf2j2f1grr49w8zx5vj-openssl-1.0.1r-dev\"\n```\n\n:::\n",
  "lib.getExe": "\nGet the path to the main program of a package based on meta.mainProgram\n\n\n# Inputs\n\n`x`\n\n: 1\\. Function argument\n\n# Type\n\n```\ngetExe :: package -> string\n```\n\n# Examples\n:::{.example}\n## `lib.meta.getExe` usage example\n\n```nix\ngetExe pkgs.hello\n=> \"/nix/store/g124820p9hlv4lj8qplzxw1c44dxaw1k-hello-2.12/bin/hello\"\ngetExe pkgs.mustache-go\n=> \"/nix/store/am9ml4f4ywvivxnkiaqwr0hyxka1xjsf-mustache-go-1.3.0/bin/mustache\"\n```\n\n:::\n",
  "lib.getExe' (Prime)": "\nGet the path of a program of a derivation.\n\n\n# Inputs\n\n`x`\n\n: 1\\. Function argument\n\n`y`\n\n: 2\\. Function argument\n\n# Type\n\n```\ngetExe' :: derivation -> string -> string\n```\n\n# Examples\n:::{.example}\n## `lib.meta.getExe'` usage example\n\n```nix\ngetExe' pkgs.hello \"hello\"\n=> \"/nix/store/g124820p9hlv4lj8qplzxw1c44dxaw1k-hello-2.12/bin/hello\"\ngetExe' pkgs.imagemagick \"convert\"\n=> \"/nix/store/5rs48jamq7k6sal98ymj9l4k2bnwq515-imagemagick-7.1.1-15/bin/convert\"\n```\n\n:::\n",
  "lib.getFiles": "\nExtracts values of all \"file\" keys of the given list\n\n# Type\n\n```\ngetFiles :: [ { file :: a; } ] -> [a]\n```\n\n# Examples\n:::{.example}\n## `getFiles` usage example\n\n```nix\ngetFiles [ { file = \"file1\"; } { file = \"file2\"; } ] // => [ \"file1\" \"file2\" ]\ngetFiles [ ]                                         // => [ ]\n```\n\n:::\n",
  "lib.getFirstOutput": "\nGet the first of the `outputs` provided by the package, or the default.\nThis function is alligned with `_overrideFirst()` from the `multiple-outputs.sh` setup hook.\nLike `getOutput`, the function is idempotent.\n\n# Inputs\n\n`outputs`\n\n: 1\\. Function argument\n\n`pkg`\n\n: 2\\. Function argument\n\n# Type\n\n```\ngetFirstOutput :: [String] -> Derivation -> Derivation\n```\n\n# Examples\n:::{.example}\n## `lib.attrsets.getFirstOutput` usage example\n\n```nix\n\"${getFirstOutput [ \"include\" \"dev\" ] pkgs.openssl}\"\n=> \"/nix/store/00000000000000000000000000000000-openssl-1.0.1r-dev\"\n```\n\n:::\n",
  "lib.getInclude": "\nGet a package's `include` output.\nIf the output does not exist, fallback to `.dev`, then to `.out`, and then to the default.\n\n# Inputs\n\n`pkg`\n\n: The package whose `include` output will be retrieved.\n\n# Type\n\n```\ngetInclude :: Derivation -> Derivation\n```\n\n# Examples\n:::{.example}\n## `lib.attrsets.getInclude` usage example\n\n```nix\n\"${getInclude pkgs.openssl}\"\n=> \"/nix/store/00000000000000000000000000000000-openssl-1.0.1r-dev\"\n```\n\n:::\n",
  "lib.getLib": "\nGet a package's `lib` output.\nIf the output does not exist, fallback to `.out` and then to the default.\n\n# Inputs\n\n`pkg`\n\n: The package whose `lib` output will be retrieved.\n\n# Type\n\n```\ngetLib :: Derivation -> Derivation\n```\n\n# Examples\n:::{.example}\n## `lib.attrsets.getLib` usage example\n\n```nix\n\"${getLib pkgs.openssl}\"\n=> \"/nix/store/9rz8gxhzf8sw4kf2j2f1grr49w8zx5vj-openssl-1.0.1r-lib\"\n```\n\n:::\n",
  "lib.getLicenseFromSpdxId": "\nGet the corresponding attribute in lib.licenses from the SPDX ID\nor warn and fallback to `{ shortName = <license string>; }`.\n\nFor SPDX IDs, see https://spdx.org/licenses.\nNote that some SPDX licenses might be missing.\n\n# Type\n\n```\ngetLicenseFromSpdxId :: str -> AttrSet\n```\n\n# Examples\n:::{.example}\n## `lib.meta.getLicenseFromSpdxId` usage example\n\n```nix\nlib.getLicenseFromSpdxId \"MIT\" == lib.licenses.mit\n=> true\nlib.getLicenseFromSpdxId \"mIt\" == lib.licenses.mit\n=> true\nlib.getLicenseFromSpdxId \"MY LICENSE\"\n=> trace: warning: getLicenseFromSpdxId: No license matches the given SPDX ID: MY LICENSE\n=> { shortName = \"MY LICENSE\"; }\n```\n\n:::\n",
  "lib.getLicenseFromSpdxIdOr": "\nGet the corresponding attribute in lib.licenses from the SPDX ID\nor fallback to the given default value.\n\nFor SPDX IDs, see https://spdx.org/licenses.\nNote that some SPDX licenses might be missing.\n\n# Inputs\n\n`licstr`\n: 1\\. SPDX ID string to find a matching license\n\n`default`\n: 2\\. Fallback value when a match is not found\n\n# Type\n\n```\ngetLicenseFromSpdxIdOr :: str -> Any -> Any\n```\n\n# Examples\n:::{.example}\n## `lib.meta.getLicenseFromSpdxIdOr` usage example\n\n```nix\nlib.getLicenseFromSpdxIdOr \"MIT\" null == lib.licenses.mit\n=> true\nlib.getLicenseFromSpdxId \"mIt\" null == lib.licenses.mit\n=> true\nlib.getLicenseFromSpdxIdOr \"MY LICENSE\" lib.licenses.free == lib.licenses.free\n=> true\nlib.getLicenseFromSpdxIdOr \"MY LICENSE\" null\n=> null\nlib.getLicenseFromSpdxIdOr \"MY LICENSE\" (builtins.throw \"No SPDX ID matches MY LICENSE\")\n=> error: No SPDX ID matches MY LICENSE\n```\n:::\n",
  "lib.getMan": "\nGet a package's `man` output.\nIf the output does not exist, fallback to `.out` and then to the default.\n\n# Inputs\n\n`pkg`\n\n: The package whose `man` output will be retrieved.\n\n# Type\n\n```\ngetMan :: Derivation -> Derivation\n```\n\n# Examples\n:::{.example}\n## `lib.attrsets.getMan` usage example\n\n```nix\n\"${getMan pkgs.openssl}\"\n=> \"/nix/store/9rz8gxhzf8sw4kf2j2f1grr49w8zx5vj-openssl-1.0.1r-man\"\n```\n\n:::\n",
  "lib.getName": "\nThis function takes an argument `x` that's either a derivation or a\nderivation's \"name\" attribute and extracts the name part from that\nargument.\n\n# Inputs\n\n`x`\n: 1\\. Function argument\n\n# Type\n\n```\ngetName :: String | Derivation -> String\n```\n\n\n# Examples\n:::{.example}\n## `lib.strings.getName` usage example\n\n```nix\ngetName \"youtube-dl-2016.01.01\"\n=> \"youtube-dl\"\ngetName pkgs.youtube-dl\n=> \"youtube-dl\"\n```\n\n:::\n",
  "lib.getOutput": "\nGet a package output.\nIf no output is found, fallback to `.out` and then to the default.\nThe function is idempotent: `getOutput \"b\" (getOutput \"a\" p) == getOutput \"a\" p`.\n\n\n# Inputs\n\n`output`\n\n: 1\\. Function argument\n\n`pkg`\n\n: 2\\. Function argument\n\n# Type\n\n```\ngetOutput :: String -> :: Derivation -> Derivation\n```\n\n# Examples\n:::{.example}\n## `lib.attrsets.getOutput` usage example\n\n```nix\n\"${getOutput \"dev\" pkgs.openssl}\"\n=> \"/nix/store/9rz8gxhzf8sw4kf2j2f1grr49w8zx5vj-openssl-1.0.1r-dev\"\n```\n\n:::\n",
  "lib.getStatic": "\nGet a package's `static` output.\nIf the output does not exist, fallback to `.lib`, then to `.out`, and then to the default.\n\n# Inputs\n\n`pkg`\n\n: The package whose `static` output will be retrieved.\n\n# Type\n\n```\ngetStatic :: Derivation -> Derivation\n```\n\n# Examples\n:::{.example}\n## `lib.attrsets.getStatic` usage example\n\n```nix\n\"${lib.getStatic pkgs.glibc}\"\n=> \"/nix/store/00000000000000000000000000000000-glibc-2.39-52-static\"\n```\n\n:::\n",
  "lib.getValue": "Output : its value or default.",
  "lib.getValues": "\nExtracts values of all \"value\" keys of the given list.\n\n# Type\n\n```\ngetValues :: [ { value :: a; } ] -> [a]\n```\n\n# Examples\n:::{.example}\n## `getValues` usage example\n\n```nix\ngetValues [ { value = 1; } { value = 2; } ] // => [ 1 2 ]\ngetValues [ ]                               // => [ ]\n```\n\n:::\n",
  "lib.getVersion": "\nThis function takes an argument `x` that's either a derivation or a\nderivation's \"name\" attribute and extracts the version part from that\nargument.\n\n\n# Inputs\n\n`x`\n: 1\\. Function argument\n\n# Type\n\n```\ngetVersion :: String | Derivation -> String\n```\n\n# Examples\n:::{.example}\n## `lib.strings.getVersion` usage example\n\n```nix\ngetVersion \"youtube-dl-2016.01.01\"\n=> \"2016.01.01\"\ngetVersion pkgs.youtube-dl\n=> \"2016.01.01\"\n```\n\n:::\n",
  "lib.groupBy": "\nGroups elements of *list* together by the string returned from the\nfunction *f* called on each element. It returns an attribute set\nwhere each attribute value contains the elements of *list* that are\nmapped to the same corresponding attribute name returned by *f*.\n\nFor example,\n\n```nix\nbuiltins.groupBy (builtins.substring 0 1) [\"foo\" \"bar\" \"baz\"]\n```\n\nevaluates to\n\n```nix\n{ b = [ \"bar\" \"baz\" ]; f = [ \"foo\" ]; }\n```\n",
  "lib.groupBy' (Prime)": "\nSplits the elements of a list into many lists, using the return value of a predicate.\nPredicate should return a string which becomes keys of attrset `groupBy` returns.\n`groupBy'` allows to customise the combining function and initial value\n\n# Inputs\n\n`op`\n\n: 1\\. Function argument\n\n`nul`\n\n: 2\\. Function argument\n\n`pred`\n\n: 3\\. Function argument\n\n`lst`\n\n: 4\\. Function argument\n\n\n# Examples\n:::{.example}\n## `lib.lists.groupBy'` usage example\n\n```nix\ngroupBy (x: boolToString (x > 2)) [ 5 1 2 3 4 ]\n=> { true = [ 5 3 4 ]; false = [ 1 2 ]; }\ngroupBy (x: x.name) [ {name = \"icewm\"; script = \"icewm &\";}\n                      {name = \"xfce\";  script = \"xfce4-session &\";}\n                      {name = \"icewm\"; script = \"icewmbg &\";}\n                      {name = \"mate\";  script = \"gnome-session &\";}\n                    ]\n=> { icewm = [ { name = \"icewm\"; script = \"icewm &\"; }\n               { name = \"icewm\"; script = \"icewmbg &\"; } ];\n     mate  = [ { name = \"mate\";  script = \"gnome-session &\"; } ];\n     xfce  = [ { name = \"xfce\";  script = \"xfce4-session &\"; } ];\n   }\n\ngroupBy' builtins.add 0 (x: boolToString (x > 2)) [ 5 1 2 3 4 ]\n=> { true = 12; false = 3; }\n```\n\n:::\n",
  "lib.hasAttr": "\n`hasAttr` returns `true` if *set* has an attribute named *s*, and\n`false` otherwise. This is a dynamic version of the `?` operator,\nsince *s* is an expression rather than an identifier.\n",
  "lib.hasAttrByPath": "\nReturn if an attribute from nested attribute set exists.\n\nNix has a [has attribute operator `?`](https://nixos.org/manual/nix/stable/language/operators#has-attribute), which is sufficient for such queries, as long as the number of attributes is static. For example:\n\n```nix\n(x?a.b) == hasAttrByPath [\"a\" \"b\"] x\n# and\n(x?${f p}.\"example.com\") == hasAttrByPath [ (f p) \"example.com\" ] x\n```\n\n**Laws**:\n 1.  ```nix\n     hasAttrByPath [] x == true\n     ```\n\n\n# Inputs\n\n`attrPath`\n\n: A list of strings representing the attribute path to check from `set`\n\n`e`\n\n: The nested attribute set to check\n\n# Type\n\n```\nhasAttrByPath :: [String] -> AttrSet -> Bool\n```\n\n# Examples\n:::{.example}\n## `lib.attrsets.hasAttrByPath` usage example\n\n```nix\nx = { a = { b = 3; }; }\nhasAttrByPath [\"a\" \"b\"] x\n=> true\nhasAttrByPath [\"z\" \"z\"] x\n=> false\nhasAttrByPath [] (throw \"no need\")\n=> true\n```\n\n:::\n",
  "lib.hasInfix": "\nDetermine whether a string contains the given infix\n\n\n# Inputs\n\n`infix`\n: 1\\. Function argument\n\n`content`\n: 2\\. Function argument\n\n# Type\n\n```\nhasInfix :: string -> string -> bool\n```\n\n# Examples\n:::{.example}\n## `lib.strings.hasInfix` usage example\n\n```nix\nhasInfix \"bc\" \"abcd\"\n=> true\nhasInfix \"ab\" \"abcd\"\n=> true\nhasInfix \"cd\" \"abcd\"\n=> true\nhasInfix \"foo\" \"abcd\"\n=> false\n```\n\n:::\n",
  "lib.hasPrefix": "\nDetermine whether a string has given prefix.\n\n\n# Inputs\n\n`pref`\n: Prefix to check for\n\n`str`\n: Input string\n\n# Type\n\n```\nhasPrefix :: string -> string -> bool\n```\n\n# Examples\n:::{.example}\n## `lib.strings.hasPrefix` usage example\n\n```nix\nhasPrefix \"foo\" \"foobar\"\n=> true\nhasPrefix \"foo\" \"barfoo\"\n=> false\n```\n\n:::\n",
  "lib.hasSuffix": "\nDetermine whether a string has given suffix.\n\n\n# Inputs\n\n`suffix`\n: Suffix to check for\n\n`content`\n: Input string\n\n# Type\n\n```\nhasSuffix :: string -> string -> bool\n```\n\n# Examples\n:::{.example}\n## `lib.strings.hasSuffix` usage example\n\n```nix\nhasSuffix \"foo\" \"foobar\"\n=> false\nhasSuffix \"foo\" \"barfoo\"\n=> true\n```\n\n:::\n",
  "lib.head": "\nReturn the first element of a list; abort evaluation if the argument\nisn’t a list or is an empty list. You can test whether a list is\nempty by comparing it with `[]`.\n",
  "lib.hiPrio": "\nIncrease the nix-env priority of the package, i.e., this\nversion/variant of the package will be preferred.\n\n# Inputs\n\n`drv`\n\n: 1\\. Function argument\n",
  "lib.hiPrioSet": "\nApply hiPrio to an attrset with derivations.\n\n# Inputs\n\n`set`\n\n: 1\\. Function argument\n",
  "lib.hydraJob": "\nStrip a derivation of all non-essential attributes, returning\nonly those needed by hydra-eval-jobs. Also strictly evaluate the\nresult to ensure that there are no thunks kept alive to prevent\ngarbage collection.\n\n# Inputs\n\n`drv`\n\n: 1\\. Function argument\n\n# Type\n\n```\nhydraJob :: (Derivation | Null) -> (Derivation | Null)\n```\n",
  "lib.id": "\nThe identity function\nFor when you need a function that does “nothing”.\n\n\n# Inputs\n\n`x`\n\n: The value to return\n\n# Type\n\n```\nid :: a -> a\n```\n",
  "lib.ifEnable": "of the second argument.",
  "lib.ifilter0": "\nFilter a list for elements that satisfy a predicate function.\nThe predicate function is called with both the index and value for each element.\nIt must return `true`/`false` to include/exclude a given element in the result.\nThis function is strict in the result of the predicate function for each element.\nThis function has O(n) complexity.\n\nAlso see [`builtins.filter`](https://nixos.org/manual/nix/stable/language/builtins.html#builtins-filter) (available as `lib.lists.filter`),\nwhich can be used instead when the index isn't needed.\n\n# Inputs\n\n`ipred`\n\n: The predicate function, it takes two arguments:\n  - 1. (int): the index of the element.\n  - 2. (a): the value of the element.\n\n  It must return `true`/`false` to include/exclude a given element from the result.\n\n`list`\n\n: The list to filter using the predicate.\n\n# Type\n```\nifilter0 :: (int -> a -> bool) -> [a] -> [a]\n```\n\n# Examples\n:::{.example}\n## `lib.lists.ifilter0` usage example\n\n```nix\nifilter0 (i: v: i == 0 || v > 2) [ 1 2 3 ]\n=> [ 1 3 ]\n```\n:::\n",
  "lib.imap": "\nMap with index starting from 1\n\n\n# Inputs\n\n`f`\n\n: 1\\. Function argument\n\n`list`\n\n: 2\\. Function argument\n\n# Type\n\n```\nimap1 :: (int -> a -> b) -> [a] -> [b]\n```\n\n# Examples\n:::{.example}\n## `lib.lists.imap1` usage example\n\n```nix\nimap1 (i: v: \"${v}-${toString i}\") [\"a\" \"b\"]\n=> [ \"a-1\" \"b-2\" ]\n```\n\n:::\n",
  "lib.imap0": "\nMap with index starting from 0\n\n# Inputs\n\n`f`\n\n: 1\\. Function argument\n\n`list`\n\n: 2\\. Function argument\n\n# Type\n\n```\nimap0 :: (int -> a -> b) -> [a] -> [b]\n```\n\n# Examples\n:::{.example}\n## `lib.lists.imap0` usage example\n\n```nix\nimap0 (i: v: \"${v}-${toString i}\") [\"a\" \"b\"]\n=> [ \"a-0\" \"b-1\" ]\n```\n\n:::\n",
  "lib.imap1": "\nMap with index starting from 1\n\n\n# Inputs\n\n`f`\n\n: 1\\. Function argument\n\n`list`\n\n: 2\\. Function argument\n\n# Type\n\n```\nimap1 :: (int -> a -> b) -> [a] -> [b]\n```\n\n# Examples\n:::{.example}\n## `lib.lists.imap1` usage example\n\n```nix\nimap1 (i: v: \"${v}-${toString i}\") [\"a\" \"b\"]\n=> [ \"a-1\" \"b-2\" ]\n```\n\n:::\n",
  "lib.importJSON": "\nReads a JSON file.\n\n# Examples\n:::{.example}\n## `lib.trivial.importJSON` usage example\n\nexample.json\n```json\n{\n  \"title\": \"Example JSON\",\n  \"hello\": {\n    \"world\": \"foo\",\n    \"bar\": {\n      \"foobar\": true\n    }\n  }\n}\n```\n\n```nix\nimportJSON ./example.json\n=> {\n  title = \"Example JSON\";\n  hello = {\n    world = \"foo\";\n    bar = {\n      foobar = true;\n    };\n  };\n}\n```\n\n:::\n\n# Inputs\n\n`path`\n\n: 1\\. Function argument\n\n# Type\n\n```\nimportJSON :: path -> any\n```\n",
  "lib.importTOML": "\nReads a TOML file.\n\n# Examples\n:::{.example}\n## `lib.trivial.importTOML` usage example\n\nexample.toml\n```toml\ntitle = \"TOML Example\"\n\n[hello]\nworld = \"foo\"\n\n[hello.bar]\nfoobar = true\n```\n\n```nix\nimportTOML ./example.toml\n=> {\n  title = \"TOML Example\";\n  hello = {\n    world = \"foo\";\n    bar = {\n      foobar = true;\n    };\n  };\n}\n```\n\n:::\n\n# Inputs\n\n`path`\n\n: 1\\. Function argument\n\n# Type\n\n```\nimportTOML :: path -> any\n```\n",
  "lib.info": null,
  "lib.init": "\nReturn all elements but the last.\n\nThis function throws an error if the list is empty.\n\n\n# Inputs\n\n`list`\n\n: 1\\. Function argument\n\n# Type\n\n```\ninit :: [a] -> [a]\n```\n\n# Examples\n:::{.example}\n## `lib.lists.init` usage example\n\n```nix\ninit [ 1 2 3 ]\n=> [ 1 2 ]\n```\n\n:::\n",
  "lib.innerClosePropagation": null,
  "lib.innerModifySumArgs": null,
  "lib.intersectAttrs": "\nReturn a set consisting of the attributes in the set *e2* which have the\nsame name as some attribute in *e1*.\n\nPerforms in O(*n* log *m*) where *n* is the size of the smaller set and *m* the larger set's size.\n",
  "lib.intersectLists": "\nIntersects list 'list1' and another list (`list2`).\n\nO(nm) complexity.\n\n# Inputs\n\n`list1`\n\n: First list\n\n`list2`\n\n: Second list\n\n\n# Examples\n:::{.example}\n## `lib.lists.intersectLists` usage example\n\n```nix\nintersectLists [ 1 2 3 ] [ 6 3 2 ]\n=> [ 3 2 ]\n```\n\n:::\n",
  "lib.intersperse": "\nPlace an element between each element of a list\n\n\n# Inputs\n\n`separator`\n: Separator to add between elements\n\n`list`\n: Input list\n\n# Type\n\n```\nintersperse :: a -> [a] -> [a]\n```\n\n# Examples\n:::{.example}\n## `lib.strings.intersperse` usage example\n\n```nix\nintersperse \"/\" [\"usr\" \"local\" \"bin\"]\n=> [\"usr\" \"/\" \"local\" \"/\" \"bin\"].\n```\n\n:::\n",
  "lib.isAttrs": "\nReturn `true` if *e* evaluates to a set, and `false` otherwise.\n",
  "lib.isBool": "\nReturn `true` if *e* evaluates to a bool, and `false` otherwise.\n",
  "lib.isDerivation": "\nCheck whether the argument is a derivation. Any set with\n`{ type = \"derivation\"; }` counts as a derivation.\n\n\n# Inputs\n\n`value`\n\n: Value to check.\n\n# Type\n\n```\nisDerivation :: Any -> Bool\n```\n\n# Examples\n:::{.example}\n## `lib.attrsets.isDerivation` usage example\n\n```nix\nnixpkgs = import <nixpkgs> {}\nisDerivation nixpkgs.ruby\n=> true\nisDerivation \"foobar\"\n=> false\n```\n\n:::\n",
  "lib.isFloat": "\nReturn `true` if *e* evaluates to a float, and `false` otherwise.\n",
  "lib.isFunction": "\nCheck whether something is a function or something\nannotated with function args.\n\n\n# Inputs\n\n`f`\n\n: 1\\. Function argument\n",
  "lib.isInOldestRelease": "\nWhether a feature is supported in all supported releases (at the time of\nrelease branch-off, if applicable). See `oldestSupportedRelease`.\n\n\n# Inputs\n\n`release`\n\n: Release number of feature introduction as an integer, e.g. 2111 for 21.11.\nSet it to the upcoming release, matching the nixpkgs/.version file.\n",
  "lib.isInt": "\nReturn `true` if *e* evaluates to an integer, and `false` otherwise.\n",
  "lib.isList": "\nReturn `true` if *e* evaluates to a list, and `false` otherwise.\n",
  "lib.isOption": "\nReturns true when the given argument `a` is an option\n\n# Inputs\n\n`a`\n: Any value to check whether it is an option\n\n# Examples\n:::{.example}\n## `lib.options.isOption` usage example\n\n```nix\nisOption 1             // => false\nisOption (mkOption {}) // => true\n```\n\n:::\n\n# Type\n\n```\nisOption :: a -> Bool\n```\n\n",
  "lib.isOptionType": null,
  "lib.isPath": "\nReturn `true` if *e* evaluates to a path, and `false` otherwise.\n",
  "lib.isStorePath": "\nCheck whether a value `x` is a store path.\n\n\n# Inputs\n\n`x`\n: 1\\. Function argument\n\n# Type\n\n```\nisStorePath :: a -> bool\n```\n\n# Examples\n:::{.example}\n## `lib.strings.isStorePath` usage example\n\n```nix\nisStorePath \"/nix/store/d945ibfx9x185xf04b890y4f9g3cbb63-python-2.7.11/bin/python\"\n=> false\nisStorePath \"/nix/store/d945ibfx9x185xf04b890y4f9g3cbb63-python-2.7.11\"\n=> true\nisStorePath pkgs.python\n=> true\nisStorePath [] || isStorePath 42 || isStorePath {} || …\n=> false\n```\n\n:::\n",
  "lib.isString": "\nReturn `true` if *e* evaluates to a string, and `false` otherwise.\n",
  "lib.isStringLike": "\nCheck whether a value can be coerced to a string.\nThe value must be a string, path, or attribute set.\n\nString-like values can be used without explicit conversion in\nstring interpolations and in most functions that expect a string.\n\n\n# Inputs\n\n`x`\n: 1\\. Function argument\n\n# Type\n\n```\nisStringLike :: a -> bool\n```\n",
  "lib.isType": null,
  "lib.isValidPosixName": "\nTest whether the given `name` is a valid POSIX shell variable name.\n\n\n# Inputs\n\n`name`\n: 1\\. Function argument\n\n# Type\n\n```\nstring -> bool\n```\n\n# Examples\n:::{.example}\n## `lib.strings.isValidPosixName` usage example\n\n```nix\nisValidPosixName \"foo_bar000\"\n=> true\nisValidPosixName \"0-bad.jpg\"\n=> false\n```\n\n:::\n",
  "lib.last": "\nReturn the last element of a list.\n\nThis function throws an error if the list is empty.\n\n\n# Inputs\n\n`list`\n\n: 1\\. Function argument\n\n# Type\n\n```\nlast :: [a] -> a\n```\n\n# Examples\n:::{.example}\n## `lib.lists.last` usage example\n\n```nix\nlast [ 1 2 3 ]\n=> 3\n```\n\n:::\n",
  "lib.lazyDerivation": "\nRestrict a derivation to a predictable set of attribute names, so\nthat the returned attrset is not strict in the actual derivation,\nsaving a lot of computation when the derivation is non-trivial.\n\nThis is useful in situations where a derivation might only be used for its\npassthru attributes, improving evaluation performance.\n\nThe returned attribute set is lazy in `derivation`. Specifically, this\nmeans that the derivation will not be evaluated in at least the\nsituations below.\n\nFor illustration and/or testing, we define derivation such that its\nevaluation is very noticeable.\n\n    let derivation = throw \"This won't be evaluated.\";\n\nIn the following expressions, `derivation` will _not_ be evaluated:\n\n    (lazyDerivation { inherit derivation; }).type\n\n    attrNames (lazyDerivation { inherit derivation; })\n\n    (lazyDerivation { inherit derivation; } // { foo = true; }).foo\n\n    (lazyDerivation { inherit derivation; meta.foo = true; }).meta\n\nIn these expressions, `derivation` _will_ be evaluated:\n\n    \"${lazyDerivation { inherit derivation }}\"\n\n    (lazyDerivation { inherit derivation }).outPath\n\n    (lazyDerivation { inherit derivation }).meta\n\nAnd the following expressions are not valid, because the refer to\nimplementation details and/or attributes that may not be present on\nsome derivations:\n\n    (lazyDerivation { inherit derivation }).buildInputs\n\n    (lazyDerivation { inherit derivation }).passthru\n\n    (lazyDerivation { inherit derivation }).pythonPath\n\n# Inputs\n\nTakes an attribute set with the following attributes\n\n`derivation`\n: The derivation to be wrapped.\n\n`meta`\n: Optional meta attribute.\n\n  While this function is primarily about derivations, it can improve\n  the `meta` package attribute, which is usually specified through\n  `mkDerivation`.\n\n`passthru`\n: Optional extra values to add to the returned attrset.\n\n  This can be used for adding package attributes, such as `tests`.\n\n`outputs`\n: Optional list of assumed outputs. Default: [\"out\"]\n\n  This must match the set of outputs that the returned derivation has.\n  You must use this when the derivation has multiple outputs.\n",
  "lib.lazyGenericClosure": null,
  "lib.length": "\nReturn the length of the list *e*.\n",
  "lib.lessThan": "\nReturn `true` if the number *e1* is less than the number *e2*, and\n`false` otherwise. Evaluation aborts if either *e1* or *e2* does not\nevaluate to a number.\n",
  "lib.listDfs": "\nDepth-First Search (DFS) for lists `list != []`.\n\n`before a b == true` means that `b` depends on `a` (there's an\nedge from `b` to `a`).\n\n\n# Inputs\n\n`stopOnCycles`\n\n: 1\\. Function argument\n\n`before`\n\n: 2\\. Function argument\n\n`list`\n\n: 3\\. Function argument\n\n\n# Examples\n:::{.example}\n## `lib.lists.listDfs` usage example\n\n```nix\nlistDfs true hasPrefix [ \"/home/user\" \"other\" \"/\" \"/home\" ]\n  == { minimal = \"/\";                  # minimal element\n       visited = [ \"/home/user\" ];     # seen elements (in reverse order)\n       rest    = [ \"/home\" \"other\" ];  # everything else\n     }\n\nlistDfs true hasPrefix [ \"/home/user\" \"other\" \"/\" \"/home\" \"/\" ]\n  == { cycle   = \"/\";                  # cycle encountered at this element\n       loops   = [ \"/\" ];              # and continues to these elements\n       visited = [ \"/\" \"/home/user\" ]; # elements leading to the cycle (in reverse order)\n       rest    = [ \"/home\" \"other\" ];  # everything else\n```\n\n:::\n",
  "lib.listToAttrs": "\nConstruct a set from a list specifying the names and values of each\nattribute. Each element of the list should be a set consisting of a\nstring-valued attribute `name` specifying the name of the attribute,\nand an attribute `value` specifying its value.\n\nIn case of duplicate occurrences of the same name, the first\ntakes precedence.\n\nExample:\n\n```nix\nbuiltins.listToAttrs\n  [ { name = \"foo\"; value = 123; }\n    { name = \"bar\"; value = 456; }\n    { name = \"bar\"; value = 420; }\n  ]\n```\n\nevaluates to\n\n```nix\n{ foo = 123; bar = 456; }\n```\n",
  "lib.literalExample": "\nFor use in the `defaultText` and `example` option attributes. Causes the\ngiven string to be rendered verbatim in the documentation as Nix code. This\nis necessary for complex values, e.g. functions, or values that depend on\nother values or packages.\n\n\n# Inputs\n\n`text`\n\n: 1\\. Function argument\n",
  "lib.literalExpression": "\nFor use in the `defaultText` and `example` option attributes. Causes the\ngiven string to be rendered verbatim in the documentation as Nix code. This\nis necessary for complex values, e.g. functions, or values that depend on\nother values or packages.\n\n\n# Inputs\n\n`text`\n\n: 1\\. Function argument\n",
  "lib.literalMD": "\nFor use in the `defaultText` and `example` option attributes. Causes the\ngiven MD text to be inserted verbatim in the documentation, for when\na `literalExpression` would be too hard to read.\n\n\n# Inputs\n\n`text`\n\n: 1\\. Function argument\n",
  "lib.lowPrio": "\nDecrease the nix-env priority of the package, i.e., other\nversions/variants of the package will be preferred.\n\n# Inputs\n\n`drv`\n\n: 1\\. Function argument\n\n",
  "lib.lowPrioSet": "\nApply lowPrio to an attrset with derivations.\n\n# Inputs\n\n`set`\n\n: 1\\. Function argument\n",
  "lib.makeBinPath": "\nConstruct a binary search path (such as $PATH) containing the\nbinaries for a set of packages.\n\n# Inputs\n\n`packages`\n: List of packages\n\n# Type\n\n```\nmakeBinPath :: [package] -> string\n```\n\n# Examples\n:::{.example}\n## `lib.strings.makeBinPath` usage example\n\n```nix\nmakeBinPath [\"/root\" \"/usr\" \"/usr/local\"]\n=> \"/root/bin:/usr/bin:/usr/local/bin\"\n```\n\n:::\n",
  "lib.makeExtensible": "\nCreate an overridable, recursive attribute set. For example:\n\n```\nnix-repl> obj = makeExtensible (final: { })\n\nnix-repl> obj\n{ __unfix__ = «lambda»; extend = «lambda»; }\n\nnix-repl> obj = obj.extend (final: prev: { foo = \"foo\"; })\n\nnix-repl> obj\n{ __unfix__ = «lambda»; extend = «lambda»; foo = \"foo\"; }\n\nnix-repl> obj = obj.extend (final: prev: { foo = prev.foo + \" + \"; bar = \"bar\"; foobar = final.foo + final.bar; })\n\nnix-repl> obj\n{ __unfix__ = «lambda»; bar = \"bar\"; extend = «lambda»; foo = \"foo + \"; foobar = \"foo + bar\"; }\n```\n",
  "lib.makeExtensibleWithCustomName": "\nSame as `makeExtensible` but the name of the extending attribute is\ncustomized.\n\n# Inputs\n\n`extenderName`\n\n: 1\\. Function argument\n\n`rattrs`\n\n: 2\\. Function argument\n",
  "lib.makeIncludePath": "\nConstruct an include search path (such as C_INCLUDE_PATH) containing the\nheader files for a set of packages or paths.\n\n# Inputs\n\n`packages`\n: List of packages\n\n# Type\n\n```\nmakeIncludePath :: [package] -> string\n```\n\n# Examples\n:::{.example}\n## `lib.strings.makeIncludePath` usage example\n\n```nix\nmakeIncludePath [ \"/usr\" \"/usr/local\" ]\n=> \"/usr/include:/usr/local/include\"\npkgs = import <nixpkgs> { }\nmakeIncludePath [ pkgs.openssl pkgs.zlib ]\n=> \"/nix/store/9rz8gxhzf8sw4kf2j2f1grr49w8zx5vj-openssl-1.0.1r-dev/include:/nix/store/wwh7mhwh269sfjkm6k5665b5kgp7jrk2-zlib-1.2.8-dev/include\"\n```\n\n:::\n",
  "lib.makeLibraryPath": "\nConstruct a library search path (such as RPATH) containing the\nlibraries for a set of packages\n\n# Inputs\n\n`packages`\n: List of packages\n\n# Type\n\n```\nmakeLibraryPath :: [package] -> string\n```\n\n# Examples\n:::{.example}\n## `lib.strings.makeLibraryPath` usage example\n\n```nix\nmakeLibraryPath [ \"/usr\" \"/usr/local\" ]\n=> \"/usr/lib:/usr/local/lib\"\npkgs = import <nixpkgs> { }\nmakeLibraryPath [ pkgs.openssl pkgs.zlib ]\n=> \"/nix/store/9rz8gxhzf8sw4kf2j2f1grr49w8zx5vj-openssl-1.0.1r/lib:/nix/store/wwh7mhwh269sfjkm6k5665b5kgp7jrk2-zlib-1.2.8/lib\"\n```\n\n:::\n",
  "lib.makeOverridable": "\n`makeOverridable` takes a function from attribute set to attribute set and\ninjects `override` attribute which can be used to override arguments of\nthe function.\n\nPlease refer to  documentation on [`<pkg>.overrideDerivation`](#sec-pkg-overrideDerivation) to learn about `overrideDerivation` and caveats\nrelated to its use.\n\n# Inputs\n\n`f`\n\n: 1\\. Function argument\n\n# Type\n\n```\nmakeOverridable :: (AttrSet -> a) -> AttrSet -> a\n```\n\n# Examples\n:::{.example}\n## `lib.customisation.makeOverridable` usage example\n\n```nix\nnix-repl> x = {a, b}: { result = a + b; }\n\nnix-repl> y = lib.makeOverridable x { a = 1; b = 2; }\n\nnix-repl> y\n{ override = «lambda»; overrideDerivation = «lambda»; result = 3; }\n\nnix-repl> y.override { a = 10; }\n{ override = «lambda»; overrideDerivation = «lambda»; result = 12; }\n```\n\n:::\n",
  "lib.makeScope": "\nMake an attribute set (a \"scope\") from functions that take arguments from that same attribute set.\nSee [](#ex-makeScope) for how to use it.\n\n# Inputs\n\n1. `newScope` (`AttrSet -> ((AttrSet -> a) | Path) -> AttrSet -> a`)\n\n   A function that takes an attribute set `attrs` and returns what ends up as `callPackage` in the output.\n\n   Typical values are `callPackageWith` or the output attribute `newScope`.\n\n2. `f` (`AttrSet -> AttrSet`)\n\n   A function that takes an attribute set as returned by `makeScope newScope f` (a \"scope\") and returns any attribute set.\n\n   This function is used to compute the fixpoint of the resulting scope using `callPackage`.\n   Its argument is the lazily evaluated reference to the value of that fixpoint, and is typically called `self` or `final`.\n\n   See [](#ex-makeScope) for how to use it.\n   See [](#sec-functions-library-fixedPoints) for details on fixpoint computation.\n\n# Output\n\n`makeScope` returns an attribute set of a form called `scope`, which also contains the final attributes produced by `f`:\n\n```\nscope :: {\n  callPackage :: ((AttrSet -> a) | Path) -> AttrSet -> a\n  newScope = AttrSet -> scope\n  overrideScope = (scope -> scope -> AttrSet) -> scope\n  packages :: AttrSet -> AttrSet\n}\n```\n\n- `callPackage` (`((AttrSet -> a) | Path) -> AttrSet -> a`)\n\n  A function that\n\n  1. Takes a function `p`, or a path to a Nix file that contains a function `p`, which takes an attribute set and returns value of arbitrary type `a`,\n  2. Takes an attribute set `args` with explicit attributes to pass to `p`,\n  3. Calls `f` with attributes from the original attribute set `attrs` passed to `newScope` updated with `args`, i.e. `attrs // args`, if they match the attributes in the argument of `p`.\n\n  All such functions `p` will be called with the same value for `attrs`.\n\n  See [](#ex-makeScope-callPackage) for how to use it.\n\n- `newScope` (`AttrSet -> scope`)\n\n  Takes an attribute set `attrs` and returns a scope that extends the original scope.\n\n- `overrideScope` (`(scope -> scope -> AttrSet) -> scope`)\n\n  Takes a function `g` of the form `final: prev: { # attributes }` to act as an overlay on `f`, and returns a new scope with values determined by `extends g f`.\n  See [](https://nixos.org/manual/nixpkgs/unstable/#function-library-lib.fixedPoints.extends) for details.\n\n  This allows subsequent modification of the final attribute set in a consistent way, i.e. all functions `p` invoked with `callPackage` will be called with the modified values.\n\n- `packages` (`AttrSet -> AttrSet`)\n\n  The value of the argument `f` to `makeScope`.\n\n- final attributes\n\n  The final values returned by `f`.\n\n# Examples\n\n:::{#ex-makeScope .example}\n# Create an interdependent package set on top of `pkgs`\n\nThe functions in `foo.nix` and `bar.nix` can depend on each other, in the sense that `foo.nix` can contain a function that expects `bar` as an attribute in its argument.\n\n```nix\nlet\n  pkgs = import <nixpkgs> { };\nin\npkgs.lib.makeScope pkgs.newScope (self: {\n  foo = self.callPackage ./foo.nix { };\n  bar = self.callPackage ./bar.nix { };\n})\n```\n\nevaluates to\n\n```nix\n{\n  callPackage = «lambda»;\n  newScope = «lambda»;\n  overrideScope = «lambda»;\n  packages = «lambda»;\n  foo = «derivation»;\n  bar = «derivation»;\n}\n```\n:::\n\n:::{#ex-makeScope-callPackage .example}\n# Using `callPackage` from a scope\n\n```nix\nlet\n  pkgs = import <nixpkgs> { };\n  inherit (pkgs) lib;\n  scope = lib.makeScope lib.callPackageWith (self: { a = 1; b = 2; });\n  three = scope.callPackage ({ a, b }: a + b) { };\n  four = scope.callPackage ({ a, b }: a + b) { a = 2; };\nin\n[ three four ]\n```\n\nevaluates to\n\n```nix\n[ 3 4 ]\n```\n:::\n\n# Type\n\n```\nmakeScope :: (AttrSet -> ((AttrSet -> a) | Path) -> AttrSet -> a) -> (AttrSet -> AttrSet) -> scope\n```\n",
  "lib.makeScopeWithSplicing": "\nbackward compatibility with old uncurried form; deprecated\n\n# Inputs\n\n`splicePackages`\n\n: 1\\. Function argument\n\n`newScope`\n\n: 2\\. Function argument\n\n`otherSplices`\n\n: 3\\. Function argument\n\n`keep`\n\n: 4\\. Function argument\n\n`extra`\n\n: 5\\. Function argument\n\n`f`\n\n: 6\\. Function argument\n",
  "lib.makeScopeWithSplicing' (Prime)": "\nLike makeScope, but aims to support cross compilation. It's still ugly, but\nhopefully it helps a little bit.\n\n# Type\n\n```\nmakeScopeWithSplicing' ::\n  { splicePackages :: Splice -> AttrSet\n  , newScope :: AttrSet -> ((AttrSet -> a) | Path) -> AttrSet -> a\n  }\n  -> { otherSplices :: Splice, keep :: AttrSet -> AttrSet, extra :: AttrSet -> AttrSet }\n  -> AttrSet\n\nSplice ::\n  { pkgsBuildBuild :: AttrSet\n  , pkgsBuildHost :: AttrSet\n  , pkgsBuildTarget :: AttrSet\n  , pkgsHostHost :: AttrSet\n  , pkgsHostTarget :: AttrSet\n  , pkgsTargetTarget :: AttrSet\n  }\n```\n",
  "lib.makeSearchPath": "\nConstruct a Unix-style, colon-separated search path consisting of\nthe given `subDir` appended to each of the given paths.\n\n# Inputs\n\n`subDir`\n: Directory name to append\n\n`paths`\n: List of base paths\n\n# Type\n\n```\nmakeSearchPath :: string -> [string] -> string\n```\n\n# Examples\n:::{.example}\n## `lib.strings.makeSearchPath` usage example\n\n```nix\nmakeSearchPath \"bin\" [\"/root\" \"/usr\" \"/usr/local\"]\n=> \"/root/bin:/usr/bin:/usr/local/bin\"\nmakeSearchPath \"bin\" [\"\"]\n=> \"/bin\"\n```\n\n:::\n",
  "lib.makeSearchPathOutput": "\nConstruct a Unix-style search path by appending the given\n`subDir` to the specified `output` of each of the packages.\n\nIf no output by the given name is found, fallback to `.out` and then to\nthe default.\n\n\n# Inputs\n\n`output`\n: Package output to use\n\n`subDir`\n: Directory name to append\n\n`pkgs`\n: List of packages\n\n# Type\n\n```\nmakeSearchPathOutput :: string -> string -> [package] -> string\n```\n\n# Examples\n:::{.example}\n## `lib.strings.makeSearchPathOutput` usage example\n\n```nix\nmakeSearchPathOutput \"dev\" \"bin\" [ pkgs.openssl pkgs.zlib ]\n=> \"/nix/store/9rz8gxhzf8sw4kf2j2f1grr49w8zx5vj-openssl-1.0.1r-dev/bin:/nix/store/wwh7mhwh269sfjkm6k5665b5kgp7jrk2-zlib-1.2.8/bin\"\n```\n\n:::\n",
  "lib.map": "\nApply the function *f* to each element in the list *list*. For\nexample,\n\n```nix\nmap (x: \"foo\" + x) [ \"bar\" \"bla\" \"abc\" ]\n```\n\nevaluates to `[ \"foobar\" \"foobla\" \"fooabc\" ]`.\n",
  "lib.mapAttrs": "\nApply a function to each element in an attribute set, creating a new attribute set.\n\n# Inputs\n\n`f`\n\n: A function that takes an attribute name and its value, and returns the new value for the attribute.\n\n`attrset`\n\n: The attribute set to iterate through.\n\n# Type\n\n```\nmapAttrs :: (String -> Any -> Any) -> AttrSet -> AttrSet\n```\n\n# Examples\n:::{.example}\n## `lib.attrsets.mapAttrs` usage example\n\n```nix\nmapAttrs (name: value: name + \"-\" + value)\n   { x = \"foo\"; y = \"bar\"; }\n=> { x = \"x-foo\"; y = \"y-bar\"; }\n```\n\n:::\n",
  "lib.mapAttrs' (Prime)": "\nLike `mapAttrs`, but allows the name of each attribute to be\nchanged in addition to the value.  The applied function should\nreturn both the new name and value as a `nameValuePair`.\n\n\n# Inputs\n\n`f`\n\n: A function, given an attribute's name and value, returns a new `nameValuePair`.\n\n`set`\n\n: Attribute set to map over.\n\n# Type\n\n```\nmapAttrs' :: (String -> Any -> { name :: String; value :: Any; }) -> AttrSet -> AttrSet\n```\n\n# Examples\n:::{.example}\n## `lib.attrsets.mapAttrs'` usage example\n\n```nix\nmapAttrs' (name: value: nameValuePair (\"foo_\" + name) (\"bar-\" + value))\n   { x = \"a\"; y = \"b\"; }\n=> { foo_x = \"bar-a\"; foo_y = \"bar-b\"; }\n```\n\n:::\n",
  "lib.mapAttrsFlatten": "\nCall a function for each attribute in the given set and return\nthe result in a list.\n\n# Inputs\n\n`f`\n\n: A function, given an attribute's name and value, returns a new value.\n\n`attrs`\n\n: Attribute set to map over.\n\n# Type\n\n```\nmapAttrsToList :: (String -> a -> b) -> AttrSet -> [b]\n```\n\n# Examples\n:::{.example}\n## `lib.attrsets.mapAttrsToList` usage example\n\n```nix\nmapAttrsToList (name: value: name + value)\n   { x = \"a\"; y = \"b\"; }\n=> [ \"xa\" \"yb\" ]\n```\n\n:::\n",
  "lib.mapAttrsRecursive": "\nLike `mapAttrs`, except that it recursively applies itself to the *leaf* attributes of a potentially-nested attribute set:\nthe second argument of the function will never be an attrset.\nAlso, the first argument of the mapping function is a *list* of the attribute names that form the path to the leaf attribute.\n\nFor a function that gives you control over what counts as a leaf, see `mapAttrsRecursiveCond`.\n\n:::{#map-attrs-recursive-example .example}\n# Map over leaf attributes\n\n```nix\nmapAttrsRecursive (path: value: concatStringsSep \"-\" (path ++ [value]))\n  { n = { a = \"A\"; m = { b = \"B\"; c = \"C\"; }; }; d = \"D\"; }\n```\nevaluates to\n```nix\n{ n = { a = \"n-a-A\"; m = { b = \"n-m-b-B\"; c = \"n-m-c-C\"; }; }; d = \"d-D\"; }\n```\n:::\n\n# Type\n```\nmapAttrsRecursive :: ([String] -> a -> b) -> AttrSet -> AttrSet\n```\n",
  "lib.mapAttrsRecursiveCond": "\nLike `mapAttrsRecursive`, but it takes an additional predicate that tells it whether to recurse into an attribute set.\nIf the predicate returns false, `mapAttrsRecursiveCond` does not recurse, but instead applies the mapping function.\nIf the predicate returns true, it does recurse, and does not apply the mapping function.\n\n:::{#map-attrs-recursive-cond-example .example}\n# Map over an leaf attributes defined by a condition\n\nMap derivations to their `name` attribute.\nDerivatons are identified as attribute sets that contain `{ type = \"derivation\"; }`.\n```nix\nmapAttrsRecursiveCond\n  (as: !(as ? \"type\" && as.type == \"derivation\"))\n  (x: x.name)\n  attrs\n```\n:::\n\n# Type\n```\nmapAttrsRecursiveCond :: (AttrSet -> Bool) -> ([String] -> a -> b) -> AttrSet -> AttrSet\n```\n",
  "lib.mapAttrsToList": "\nCall a function for each attribute in the given set and return\nthe result in a list.\n\n# Inputs\n\n`f`\n\n: A function, given an attribute's name and value, returns a new value.\n\n`attrs`\n\n: Attribute set to map over.\n\n# Type\n\n```\nmapAttrsToList :: (String -> a -> b) -> AttrSet -> [b]\n```\n\n# Examples\n:::{.example}\n## `lib.attrsets.mapAttrsToList` usage example\n\n```nix\nmapAttrsToList (name: value: name + value)\n   { x = \"a\"; y = \"b\"; }\n=> [ \"xa\" \"yb\" ]\n```\n\n:::\n",
  "lib.mapCartesianProduct": "\nReturn the result of function f applied to the cartesian product of attribute set value combinations.\nEquivalent to using cartesianProduct followed by map.\n\n# Inputs\n\n`f`\n\n: A function, given an attribute set, it returns a new value.\n\n`attrsOfLists`\n\n: Attribute set with attributes that are lists of values\n\n# Type\n\n```\nmapCartesianProduct :: (AttrSet -> a) -> AttrSet -> [a]\n```\n\n# Examples\n:::{.example}\n## `lib.attrsets.mapCartesianProduct` usage example\n\n```nix\nmapCartesianProduct ({a, b}: \"${a}-${b}\") { a = [ \"1\" \"2\" ]; b = [ \"3\" \"4\" ]; }\n=> [ \"1-3\" \"1-4\" \"2-3\" \"2-4\" ]\n```\n\n:::\n\n",
  "lib.mapDerivationAttrset": "\nApply a function to each derivation and only to derivations in an attrset.\n\n\n# Inputs\n\n`f`\n\n: 1\\. Function argument\n\n`set`\n\n: 2\\. Function argument\n",
  "lib.mapNullable": "\nApply function if the supplied argument is non-null.\n\n\n# Inputs\n\n`f`\n\n: Function to call\n\n`a`\n\n: Argument to check for null before passing it to `f`\n\n\n# Examples\n:::{.example}\n## `lib.trivial.mapNullable` usage example\n\n```nix\nmapNullable (x: x+1) null\n=> null\nmapNullable (x: x+1) 22\n=> 23\n```\n\n:::\n",
  "lib.match": "\nReturns a list if the [extended POSIX regular\nexpression](http://pubs.opengroup.org/onlinepubs/9699919799/basedefs/V1_chap09.html#tag_09_04)\n*regex* matches *str* precisely, otherwise returns `null`. Each item\nin the list is a regex group.\n\n```nix\nbuiltins.match \"ab\" \"abc\"\n```\n\nEvaluates to `null`.\n\n```nix\nbuiltins.match \"abc\" \"abc\"\n```\n\nEvaluates to `[ ]`.\n\n```nix\nbuiltins.match \"a(b)(c)\" \"abc\"\n```\n\nEvaluates to `[ \"b\" \"c\" ]`.\n\n```nix\nbuiltins.match \"[[:space:]]+([[:upper:]]+)[[:space:]]+\" \"  FOO   \"\n```\n\nEvaluates to `[ \"FOO\" ]`.\n",
  "lib.matchAttrs": "\nRecurse into every attribute set of the first argument and check that:\n- Each attribute path also exists in the second argument.\n- If the attribute's value is not a nested attribute set, it must have the same value in the right argument.\n\n\n# Inputs\n\n`pattern`\n\n: Attribute set structure to match\n\n`attrs`\n\n: Attribute set to check\n\n# Type\n\n```\nmatchAttrs :: AttrSet -> AttrSet -> Bool\n```\n\n# Examples\n:::{.example}\n## `lib.attrsets.matchAttrs` usage example\n\n```nix\nmatchAttrs { cpu = {}; } { cpu = { bits = 64; }; }\n=> true\n```\n\n:::\n",
  "lib.max": "\nReturn maximum of two numbers.\n\n\n# Inputs\n\n`x`\n\n: 1\\. Function argument\n\n`y`\n\n: 2\\. Function argument\n",
  "lib.maybeAttr": "shortcut for attrByPath [\"name\"] default attrs",
  "lib.maybeAttrNullable": "shortcut for attrByPath [\"name\"] default attrs",
  "lib.maybeEnv": "returns default if env var is not set",
  "lib.mergeAttrByFunc": "foldArgs, composedArgsAndFun or applyAndFun. Example: composableDerivation in all-packages.nix",
  "lib.mergeAttrs": "\nMerge two attribute sets shallowly, right side trumps left\n\nmergeAttrs :: attrs -> attrs -> attrs\n\n\n# Inputs\n\n`x`\n\n: Left attribute set\n\n`y`\n\n: Right attribute set (higher precedence for equal keys)\n\n\n# Examples\n:::{.example}\n## `lib.trivial.mergeAttrs` usage example\n\n```nix\nmergeAttrs { a = 1; b = 2; } { b = 3; c = 4; }\n=> { a = 1; b = 3; c = 4; }\n```\n\n:::\n",
  "lib.mergeAttrsByFuncDefaults": null,
  "lib.mergeAttrsByFuncDefaultsClean": null,
  "lib.mergeAttrsConcatenateValues": null,
  "lib.mergeAttrsList": "\nMerge a list of attribute sets together using the `//` operator.\nIn case of duplicate attributes, values from later list elements take precedence over earlier ones.\nThe result is the same as `foldl mergeAttrs { }`, but the performance is better for large inputs.\nFor n list elements, each with an attribute set containing m unique attributes, the complexity of this operation is O(nm log n).\n\n\n# Inputs\n\n`list`\n\n: 1\\. Function argument\n\n# Type\n\n```\nmergeAttrsList :: [ Attrs ] -> Attrs\n```\n\n# Examples\n:::{.example}\n## `lib.attrsets.mergeAttrsList` usage example\n\n```nix\nmergeAttrsList [ { a = 0; b = 1; } { c = 2; d = 3; } ]\n=> { a = 0; b = 1; c = 2; d = 3; }\nmergeAttrsList [ { a = 0; } { a = 1; } ]\n=> { a = 1; }\n```\n\n:::\n",
  "lib.mergeAttrsNoOverride": "! deprecated, use mergeAttrByFunc instead",
  "lib.mergeAttrsWithFunc": "exists in both sets",
  "lib.mergeDefaultOption": "\nA merge function that merges multiple definitions of an option into a single value\n\n:::{.caution}\nThis function is used as the default merge operation in `lib.types.mkOptionType`. In most cases, explicit usage of this function is unnecessary.\n:::\n\n# Inputs\n\n`loc`\n: location of the option in the configuration as a list of strings.\n\n  e.g. `[\"boot\" \"loader \"grub\" \"enable\"]`\n\n`defs`\n: list of definition values and locations.\n\n  e.g. `[ { file = \"/foo.nix\"; value = 1; } { file = \"/bar.nix\"; value = 2 } ]`\n\n# Example\n:::{.example}\n## `lib.options.mergeDefaultOption` usage example\n\n```nix\nmyType = mkOptionType {\n  name = \"myType\";\n  merge = mergeDefaultOption; # <- This line is redundant. It is the default aready.\n};\n```\n\n:::\n\n# Merge behavior\n\nMerging requires all definition values to have the same type.\n\n- If all definitions are booleans, the result of a `foldl'` with the `or` operation is returned.\n- If all definitions are strings, they are concatenated. (`lib.concatStrings`)\n- If all definitions are integers and all are equal, the first one is returned.\n- If all definitions are lists, they are concatenated. (`++`)\n- If all definitions are attribute sets, they are merged. (`lib.mergeAttrs`)\n- If all definitions are functions, the first function is applied to the result of the second function. (`f -> x: f x`)\n- Otherwise, an error is thrown.\n\n",
  "lib.mergeDefinitions": "Merge definitions of a value of a given type.",
  "lib.mergeEqualOption": "\n\"Merge\" option definitions by checking that they all have the same value.\n\n\n# Inputs\n\n`loc`\n\n: 1\\. Function argument\n\n`defs`\n\n: 2\\. Function argument\n",
  "lib.mergeModules": "\nMerge a list of modules.  This will recurse over the option\ndeclarations in all modules, combining them into a single set.\nAt the same time, for each option declaration, it will merge the\ncorresponding option definitions in all machines, returning them\nin the ‘value’ attribute of each option.\n\nThis returns a set like\n  {\n    # A recursive set of options along with their final values\n    matchedOptions = {\n      foo = { _type = \"option\"; value = \"option value of foo\"; ... };\n      bar.baz = { _type = \"option\"; value = \"option value of bar.baz\"; ... };\n      ...\n    };\n    # A list of definitions that weren't matched by any option\n    unmatchedDefns = [\n      { file = \"file.nix\"; prefix = [ \"qux\" ]; value = \"qux\"; }\n      ...\n    ];\n  }\n\n\n# Inputs\n\n`prefix`\n\n: 1\\. Function argument\n\n`modules`\n\n: 2\\. Function argument\n",
  "lib.mergeModules' (Prime)": null,
  "lib.mergeOneOption": "\nRequire a single definition.\n\nWARNING: Does not perform nested checks, as this does not run the merge function!\n",
  "lib.mergeOptionDecls": "\nMerge multiple option declarations into a single declaration.  In\ngeneral, there should be only one declaration of each option.\nThe exception is the ‘options’ attribute, which specifies\nsub-options.  These can be specified multiple times to allow one\nmodule to add sub-options to an option declared somewhere else\n(e.g. multiple modules define sub-options for ‘fileSystems’).\n\n'loc' is the list of attribute names where the option is located.\n\n'opts' is a list of modules.  Each module has an options attribute which\ncorrespond to the definition of 'loc' in 'opt.file'.\n\n\n# Inputs\n\n`loc`\n\n: 1\\. Function argument\n\n`opts`\n\n: 2\\. Function argument\n",
  "lib.mergeUniqueOption": "\nRequire a single definition.\n\nNOTE: When the type is not checked completely by check, pass a merge function for further checking (of sub-attributes, etc).\n\n\n# Inputs\n\n`loc`\n\n: 2\\. Function argument\n\n`defs`\n\n: 3\\. Function argument\n",
  "lib.mesonBool": "\nCreate a -D<condition>={true,false} string that can be passed to typical\nMeson invocations.\n\n\n# Inputs\n\n`condition`\n: The condition to be made true or false\n\n`flag`\n: The controlling flag of the condition\n\n# Type\n\n```\nmesonBool :: string -> bool -> string\n```\n\n# Examples\n:::{.example}\n## `lib.strings.mesonBool` usage example\n\n```nix\nmesonBool \"hardened\" true\n=> \"-Dhardened=true\"\nmesonBool \"static\" false\n=> \"-Dstatic=false\"\n```\n\n:::\n",
  "lib.mesonEnable": "\nCreate a -D<feature>={enabled,disabled} string that can be passed to\ntypical Meson invocations.\n\n\n# Inputs\n\n`feature`\n: The feature to be enabled or disabled\n\n`flag`\n: The controlling flag\n\n# Type\n\n```\nmesonEnable :: string -> bool -> string\n```\n\n# Examples\n:::{.example}\n## `lib.strings.mesonEnable` usage example\n\n```nix\nmesonEnable \"docs\" true\n=> \"-Ddocs=enabled\"\nmesonEnable \"savage\" false\n=> \"-Dsavage=disabled\"\n```\n\n:::\n",
  "lib.mesonOption": "\nCreate a -D<feature>=<value> string that can be passed to typical Meson\ninvocations.\n\n\n# Inputs\n\n`feature`\n: The feature to be set\n\n`value`\n: The desired value\n\n# Type\n\n```\nmesonOption :: string -> string -> string\n```\n\n# Examples\n:::{.example}\n## `lib.strings.mesonOption` usage example\n\n```nix\nmesonOption \"engine\" \"opengl\"\n=> \"-Dengine=opengl\"\n```\n\n:::\n",
  "lib.min": "\nReturn minimum of two numbers.\n\n\n# Inputs\n\n`x`\n\n: 1\\. Function argument\n\n`y`\n\n: 2\\. Function argument\n",
  "lib.mirrorFunctionArgs": "\n`mirrorFunctionArgs f g` creates a new function `g'` with the same behavior as `g` (`g' x == g x`)\nbut its function arguments mirroring `f` (`lib.functionArgs g' == lib.functionArgs f`).\n\n\n# Inputs\n\n`f`\n\n: Function to provide the argument metadata\n\n`g`\n\n: Function to set the argument metadata to\n\n# Type\n\n```\nmirrorFunctionArgs :: (a -> b) -> (a -> c) -> (a -> c)\n```\n\n# Examples\n:::{.example}\n## `lib.trivial.mirrorFunctionArgs` usage example\n\n```nix\naddab = {a, b}: a + b\naddab { a = 2; b = 4; }\n=> 6\nlib.functionArgs addab\n=> { a = false; b = false; }\naddab1 = attrs: addab attrs + 1\naddab1 { a = 2; b = 4; }\n=> 7\nlib.functionArgs addab1\n=> { }\naddab1' = lib.mirrorFunctionArgs addab addab1\naddab1' { a = 2; b = 4; }\n=> 7\nlib.functionArgs addab1'\n=> { a = false; b = false; }\n```\n\n:::\n",
  "lib.mkAfter": null,
  "lib.mkAliasAndWrapDefinitions": null,
  "lib.mkAliasDefinitions": null,
  "lib.mkAliasOptionModule": "\nLike ‘mkRenamedOptionModule’, but doesn't show a warning.\n\n\n# Inputs\n\n`from`\n\n: 1\\. Function argument\n\n`to`\n\n: 2\\. Function argument\n",
  "lib.mkAliasOptionModuleMD": "\nLike ‘mkRenamedOptionModule’, but doesn't show a warning.\n\n\n# Inputs\n\n`from`\n\n: 1\\. Function argument\n\n`to`\n\n: 2\\. Function argument\n",
  "lib.mkAssert": null,
  "lib.mkBefore": null,
  "lib.mkChangedOptionModule": "\nSingle \"from\" version of mkMergedOptionModule.\nReturn a module that causes a warning to be shown if the \"from\" option is\ndefined; the defined value can be used in the \"mergeFn\" to set the \"to\"\nvalue.\nThis function can be used to change an option into another that has a\ndifferent type.\n\n\"mergeFn\" takes the module \"config\" as a parameter and must return a value of\n\"to\" option type.\n\n  mkChangedOptionModule [ \"a\" \"b\" \"c\" ] [ \"x\" \"y\" \"z\" ]\n    (config:\n      let value = getAttrFromPath [ \"a\" \"b\" \"c\" ] config;\n      in\n      if   value > 100 then \"high\"\n      else \"normal\")\n\n- options.a.b.c is a removed int option\n- options.x.y.z is a new str option that supersedes a.b.c\n\nThis show a warning if a.b.c is set, and set the value of x.y.z to the\nresult of the change function\n\n\n# Inputs\n\n`from`\n\n: 1\\. Function argument\n\n`to`\n\n: 2\\. Function argument\n\n`changeFn`\n\n: 3\\. Function argument\n",
  "lib.mkDefault": null,
  "lib.mkDerivedConfig": "\nmkDerivedConfig : Option a -> (a -> Definition b) -> Definition b\n\nCreate config definitions with the same priority as the definition of another option.\nThis should be used for option definitions where one option sets the value of another as a convenience.\nFor instance a config file could be set with a `text` or `source` option, where text translates to a `source`\nvalue using `mkDerivedConfig options.text (pkgs.writeText \"filename.conf\")`.\n\nIt takes care of setting the right priority using `mkOverride`.\n\n\n# Inputs\n\n`opt`\n\n: 1\\. Function argument\n\n`f`\n\n: 2\\. Function argument\n",
  "lib.mkEnableOption": "\nCreates an option declaration with a default value of ´false´, and can be defined to ´true´.\n\n# Inputs\n\n`name`\n\n: Name for the created option\n\n# Examples\n:::{.example}\n## `lib.options.mkEnableOption` usage example\n\n```nix\n# module\nlet\n  eval = lib.evalModules {\n    modules = [\n      {\n        options.foo.enable = mkEnableOption \"foo\";\n\n        config.foo.enable = true;\n      }\n    ]:\n  }\nin\neval.config\n=> { foo.enable = true; }\n```\n\n:::\n",
  "lib.mkFixStrictness": "\nThe identity function\nFor when you need a function that does “nothing”.\n\n\n# Inputs\n\n`x`\n\n: The value to return\n\n# Type\n\n```\nid :: a -> a\n```\n",
  "lib.mkForce": null,
  "lib.mkIf": "\nProperties.\n\n\n# Inputs\n\n`condition`\n\n: 1\\. Function argument\n\n`content`\n\n: 2\\. Function argument\n",
  "lib.mkImageMediaOverride": null,
  "lib.mkMerge": null,
  "lib.mkMergedOptionModule": "\nReturn a module that causes a warning to be shown if any of the \"from\"\noption is defined; the defined values can be used in the \"mergeFn\" to set\nthe \"to\" value.\nThis function can be used to merge multiple options into one that has a\ndifferent type.\n\n\"mergeFn\" takes the module \"config\" as a parameter and must return a value\nof \"to\" option type.\n\n  mkMergedOptionModule\n    [ [ \"a\" \"b\" \"c\" ]\n      [ \"d\" \"e\" \"f\" ] ]\n    [ \"x\" \"y\" \"z\" ]\n    (config:\n      let value = p: getAttrFromPath p config;\n      in\n      if      (value [ \"a\" \"b\" \"c\" ]) == true then \"foo\"\n      else if (value [ \"d\" \"e\" \"f\" ]) == true then \"bar\"\n      else \"baz\")\n\n- options.a.b.c is a removed boolean option\n- options.d.e.f is a removed boolean option\n- options.x.y.z is a new str option that combines a.b.c and d.e.f\n  functionality\n\nThis show a warning if any a.b.c or d.e.f is set, and set the value of\nx.y.z to the result of the merge function\n\n\n# Inputs\n\n`from`\n\n: 1\\. Function argument\n\n`to`\n\n: 2\\. Function argument\n\n`mergeFn`\n\n: 3\\. Function argument\n",
  "lib.mkOption": "\nCreates an Option attribute set. mkOption accepts an attribute set with the following keys:\n\n# Inputs\n\nStructured attribute set\n: Attribute set containing none or some of the following attributes.\n\n  `default`\n  : Optional default value used when no definition is given in the configuration.\n\n  `defaultText`\n  : Substitute for documenting the `default`, if evaluating the default value during documentation rendering is not possible.\n  : Can be any nix value that evaluates.\n  : Usage with `lib.literalMD` or `lib.literalExpression` is supported\n\n\n  `example`\n  : Optional example value used in the manual.\n  : Can be any nix value that evaluates.\n  : Usage with `lib.literalMD` or `lib.literalExpression` is supported\n\n  `description`\n  : Optional string describing the option. This is required if option documentation is generated.\n\n  `relatedPackages`\n  : Optional related packages used in the manual (see `genRelatedPackages` in `../nixos/lib/make-options-doc/default.nix`).\n\n  `type`\n  : Optional option type, providing type-checking and value merging.\n\n  `apply`\n  : Optional function that converts the option value to something else.\n\n  `internal`\n  : Optional boolean indicating whether the option is for NixOS developers only.\n\n  `visible`\n  : Optional boolean indicating whether the option shows up in the manual. Default: true. Use false to hide the option and any sub-options from submodules. Use \"shallow\" to hide only sub-options.\n\n  `readOnly`\n  : Optional boolean indicating whether the option can be set only once.\n\n  `...` (any other attribute)\n  : Any other attribute is passed through to the resulting option attribute set.\n\n# Examples\n:::{.example}\n## `lib.options.mkOption` usage example\n\n```nix\nmkOption { }  // => { _type = \"option\"; }\nmkOption { default = \"foo\"; } // => { _type = \"option\"; default = \"foo\"; }\n```\n\n:::\n",
  "lib.mkOptionDefault": null,
  "lib.mkOptionType": null,
  "lib.mkOrder": null,
  "lib.mkOverride": null,
  "lib.mkPackageOption": "\nCreates an Option attribute set for an option that specifies the\npackage a module should use for some purpose.\n\nThe package is specified in the third argument under `default` as a list of strings\nrepresenting its attribute path in nixpkgs (or another package set).\nBecause of this, you need to pass nixpkgs itself (usually `pkgs` in a module;\nalternatively to nixpkgs itself, another package set) as the first argument.\n\nIf you pass another package set you should set the `pkgsText` option.\nThis option is used to display the expression for the package set. It is `\"pkgs\"` by default.\nIf your expression is complex you should parenthesize it, as the `pkgsText` argument\nis usually immediately followed by an attribute lookup (`.`).\n\nThe second argument may be either a string or a list of strings.\nIt provides the display name of the package in the description of the generated option\n(using only the last element if the passed value is a list)\nand serves as the fallback value for the `default` argument.\n\nTo include extra information in the description, pass `extraDescription` to\nappend arbitrary text to the generated description.\n\nYou can also pass an `example` value, either a literal string or an attribute path.\n\nThe `default` argument can be omitted if the provided name is\nan attribute of pkgs (if `name` is a string) or a valid attribute path in pkgs (if `name` is a list).\nYou can also set `default` to just a string in which case it is interpreted as an attribute name\n(a singleton attribute path, if you will).\n\nIf you wish to explicitly provide no default, pass `null` as `default`.\n\nIf you want users to be able to set no package, pass `nullable = true`.\nIn this mode a `default = null` will not be interpreted as no default and is interpreted literally.\n\n\n# Inputs\n\n`pkgs`\n\n: Package set (an instantiation of nixpkgs such as pkgs in modules or another package set)\n\n`name`\n\n: Name for the package, shown in option description\n\nStructured function argument\n: Attribute set containing the following attributes.\n\n  `nullable`\n  : Optional whether the package can be null, for example to disable installing a package altogether. Default: `false`\n\n  `default`\n  : Optional attribute path where the default package is located. Default: `name`\n    If omitted will be copied from `name`\n\n  `example`\n  : Optional string or an attribute path to use as an example. Default: `null`\n\n  `extraDescription`\n  : Optional additional text to include in the option description. Default: `\"\"`\n\n  `pkgsText`\n  : Optional representation of the package set passed as pkgs. Default: `\"pkgs\"`\n\n# Type\n\n```\nmkPackageOption :: pkgs -> (string|[string]) -> { nullable? :: bool, default? :: string|[string], example? :: null|string|[string], extraDescription? :: string, pkgsText? :: string } -> option\n```\n\n# Examples\n:::{.example}\n## `lib.options.mkPackageOption` usage example\n\n```nix\nmkPackageOption pkgs \"hello\" { }\n=> { ...; default = pkgs.hello; defaultText = literalExpression \"pkgs.hello\"; description = \"The hello package to use.\"; type = package; }\n\n\nmkPackageOption pkgs \"GHC\" {\n  default = [ \"ghc\" ];\n  example = \"pkgs.haskell.packages.ghc92.ghc.withPackages (hkgs: [ hkgs.primes ])\";\n}\n=> { ...; default = pkgs.ghc; defaultText = literalExpression \"pkgs.ghc\"; description = \"The GHC package to use.\"; example = literalExpression \"pkgs.haskell.packages.ghc92.ghc.withPackages (hkgs: [ hkgs.primes ])\"; type = package; }\n\n\nmkPackageOption pkgs [ \"python3Packages\" \"pytorch\" ] {\n  extraDescription = \"This is an example and doesn't actually do anything.\";\n}\n=> { ...; default = pkgs.python3Packages.pytorch; defaultText = literalExpression \"pkgs.python3Packages.pytorch\"; description = \"The pytorch package to use. This is an example and doesn't actually do anything.\"; type = package; }\n\n\nmkPackageOption pkgs \"nushell\" {\n  nullable = true;\n}\n=> { ...; default = pkgs.nushell; defaultText = literalExpression \"pkgs.nushell\"; description = \"The nushell package to use.\"; type = nullOr package; }\n\n\nmkPackageOption pkgs \"coreutils\" {\n  default = null;\n}\n=> { ...; description = \"The coreutils package to use.\"; type = package; }\n\n\nmkPackageOption pkgs \"dbus\" {\n  nullable = true;\n  default = null;\n}\n=> { ...; default = null; description = \"The dbus package to use.\"; type = nullOr package; }\n\n\nmkPackageOption pkgs.javaPackages \"OpenJFX\" {\n  default = \"openjfx20\";\n  pkgsText = \"pkgs.javaPackages\";\n}\n=> { ...; default = pkgs.javaPackages.openjfx20; defaultText = literalExpression \"pkgs.javaPackages.openjfx20\"; description = \"The OpenJFX package to use.\"; type = package; }\n```\n\n:::\n",
  "lib.mkPackageOptionMD": "\nCreates an Option attribute set for an option that specifies the\npackage a module should use for some purpose.\n\nThe package is specified in the third argument under `default` as a list of strings\nrepresenting its attribute path in nixpkgs (or another package set).\nBecause of this, you need to pass nixpkgs itself (usually `pkgs` in a module;\nalternatively to nixpkgs itself, another package set) as the first argument.\n\nIf you pass another package set you should set the `pkgsText` option.\nThis option is used to display the expression for the package set. It is `\"pkgs\"` by default.\nIf your expression is complex you should parenthesize it, as the `pkgsText` argument\nis usually immediately followed by an attribute lookup (`.`).\n\nThe second argument may be either a string or a list of strings.\nIt provides the display name of the package in the description of the generated option\n(using only the last element if the passed value is a list)\nand serves as the fallback value for the `default` argument.\n\nTo include extra information in the description, pass `extraDescription` to\nappend arbitrary text to the generated description.\n\nYou can also pass an `example` value, either a literal string or an attribute path.\n\nThe `default` argument can be omitted if the provided name is\nan attribute of pkgs (if `name` is a string) or a valid attribute path in pkgs (if `name` is a list).\nYou can also set `default` to just a string in which case it is interpreted as an attribute name\n(a singleton attribute path, if you will).\n\nIf you wish to explicitly provide no default, pass `null` as `default`.\n\nIf you want users to be able to set no package, pass `nullable = true`.\nIn this mode a `default = null` will not be interpreted as no default and is interpreted literally.\n\n\n# Inputs\n\n`pkgs`\n\n: Package set (an instantiation of nixpkgs such as pkgs in modules or another package set)\n\n`name`\n\n: Name for the package, shown in option description\n\nStructured function argument\n: Attribute set containing the following attributes.\n\n  `nullable`\n  : Optional whether the package can be null, for example to disable installing a package altogether. Default: `false`\n\n  `default`\n  : Optional attribute path where the default package is located. Default: `name`\n    If omitted will be copied from `name`\n\n  `example`\n  : Optional string or an attribute path to use as an example. Default: `null`\n\n  `extraDescription`\n  : Optional additional text to include in the option description. Default: `\"\"`\n\n  `pkgsText`\n  : Optional representation of the package set passed as pkgs. Default: `\"pkgs\"`\n\n# Type\n\n```\nmkPackageOption :: pkgs -> (string|[string]) -> { nullable? :: bool, default? :: string|[string], example? :: null|string|[string], extraDescription? :: string, pkgsText? :: string } -> option\n```\n\n# Examples\n:::{.example}\n## `lib.options.mkPackageOption` usage example\n\n```nix\nmkPackageOption pkgs \"hello\" { }\n=> { ...; default = pkgs.hello; defaultText = literalExpression \"pkgs.hello\"; description = \"The hello package to use.\"; type = package; }\n\n\nmkPackageOption pkgs \"GHC\" {\n  default = [ \"ghc\" ];\n  example = \"pkgs.haskell.packages.ghc92.ghc.withPackages (hkgs: [ hkgs.primes ])\";\n}\n=> { ...; default = pkgs.ghc; defaultText = literalExpression \"pkgs.ghc\"; description = \"The GHC package to use.\"; example = literalExpression \"pkgs.haskell.packages.ghc92.ghc.withPackages (hkgs: [ hkgs.primes ])\"; type = package; }\n\n\nmkPackageOption pkgs [ \"python3Packages\" \"pytorch\" ] {\n  extraDescription = \"This is an example and doesn't actually do anything.\";\n}\n=> { ...; default = pkgs.python3Packages.pytorch; defaultText = literalExpression \"pkgs.python3Packages.pytorch\"; description = \"The pytorch package to use. This is an example and doesn't actually do anything.\"; type = package; }\n\n\nmkPackageOption pkgs \"nushell\" {\n  nullable = true;\n}\n=> { ...; default = pkgs.nushell; defaultText = literalExpression \"pkgs.nushell\"; description = \"The nushell package to use.\"; type = nullOr package; }\n\n\nmkPackageOption pkgs \"coreutils\" {\n  default = null;\n}\n=> { ...; description = \"The coreutils package to use.\"; type = package; }\n\n\nmkPackageOption pkgs \"dbus\" {\n  nullable = true;\n  default = null;\n}\n=> { ...; default = null; description = \"The dbus package to use.\"; type = nullOr package; }\n\n\nmkPackageOption pkgs.javaPackages \"OpenJFX\" {\n  default = \"openjfx20\";\n  pkgsText = \"pkgs.javaPackages\";\n}\n=> { ...; default = pkgs.javaPackages.openjfx20; defaultText = literalExpression \"pkgs.javaPackages.openjfx20\"; description = \"The OpenJFX package to use.\"; type = package; }\n```\n\n:::\n",
  "lib.mkRemovedOptionModule": "\nReturn a module that causes a warning to be shown if the\nspecified option is defined. For example,\n\n  mkRemovedOptionModule [ \"boot\" \"loader\" \"grub\" \"bootDevice\" ] \"<replacement instructions>\"\n\ncauses a assertion if the user defines boot.loader.grub.bootDevice.\n\nreplacementInstructions is a string that provides instructions on\nhow to achieve the same functionality without the removed option,\nor alternatively a reasoning why the functionality is not needed.\nreplacementInstructions SHOULD be provided!\n\n\n# Inputs\n\n`optionName`\n\n: 1\\. Function argument\n\n`replacementInstructions`\n\n: 2\\. Function argument\n",
  "lib.mkRenamedOptionModule": "\nReturn a module that causes a warning to be shown if the\nspecified \"from\" option is defined; the defined value is however\nforwarded to the \"to\" option. This can be used to rename options\nwhile providing backward compatibility. For example,\n\n  mkRenamedOptionModule [ \"boot\" \"copyKernels\" ] [ \"boot\" \"loader\" \"grub\" \"copyKernels\" ]\n\nforwards any definitions of boot.copyKernels to\nboot.loader.grub.copyKernels while printing a warning.\n\nThis also copies over the priority from the aliased option to the\nnon-aliased option.\n\n\n# Inputs\n\n`from`\n\n: 1\\. Function argument\n\n`to`\n\n: 2\\. Function argument\n",
  "lib.mkRenamedOptionModuleWith": null,
  "lib.mkSinkUndeclaredOptions": "\nThis option accepts arbitrary definitions, but it does not produce an option value.\n\nThis is useful for sharing a module across different module sets\nwithout having to implement similar features as long as the\nvalues of the options are not accessed.\n\n\n# Inputs\n\n`attrs`\n\n: Attribute set whose attributes override the argument to `mkOption`.\n",
  "lib.mkVMOverride": null,
  "lib.mod": "\nInteger modulus\n\n\n# Inputs\n\n`base`\n\n: 1\\. Function argument\n\n`int`\n\n: 2\\. Function argument\n\n\n# Examples\n:::{.example}\n## `lib.trivial.mod` usage example\n\n```nix\nmod 11 10\n=> 1\nmod 1 10\n=> 1\n```\n\n:::\n",
  "lib.modifySumArgs": null,
  "lib.mutuallyExclusive": "\nTest if two lists have no common element.\nIt should be slightly more efficient than (intersectLists a b == [])\n\n# Inputs\n\n`a`\n\n: 1\\. Function argument\n\n`b`\n\n: 2\\. Function argument\n",
  "lib.nameFromURL": "\nExtract name and version from a URL as shown in the examples.\n\nSeparator `sep` is used to determine the end of the extension.\n\n\n# Inputs\n\n`url`\n: 1\\. Function argument\n\n`sep`\n: 2\\. Function argument\n\n# Type\n\n```\nnameFromURL :: String -> String\n```\n\n# Examples\n:::{.example}\n## `lib.strings.nameFromURL` usage example\n\n```nix\nnameFromURL \"https://nixos.org/releases/nix/nix-1.7/nix-1.7-x86_64-linux.tar.bz2\" \"-\"\n=> \"nix\"\nnameFromURL \"https://nixos.org/releases/nix/nix-1.7/nix-1.7-x86_64-linux.tar.bz2\" \"_\"\n=> \"nix-1.7-x86\"\n```\n\n:::\n",
  "lib.nameValuePair": "\nUtility function that creates a `{name, value}` pair as expected by `builtins.listToAttrs`.\n\n\n# Inputs\n\n`name`\n\n: Attribute name\n\n`value`\n\n: Attribute value\n\n# Type\n\n```\nnameValuePair :: String -> Any -> { name :: String; value :: Any; }\n```\n\n# Examples\n:::{.example}\n## `lib.attrsets.nameValuePair` usage example\n\n```nix\nnameValuePair \"some\" 6\n=> { name = \"some\"; value = 6; }\n```\n\n:::\n",
  "lib.naturalSort": "\nSort list using \"Natural sorting\".\nNumeric portions of strings are sorted in numeric order.\n\n\n# Inputs\n\n`lst`\n\n: 1\\. Function argument\n\n\n# Examples\n:::{.example}\n## `lib.lists.naturalSort` usage example\n\n```nix\nnaturalSort [\"disk11\" \"disk8\" \"disk100\" \"disk9\"]\n=> [\"disk8\" \"disk9\" \"disk11\" \"disk100\"]\nnaturalSort [\"10.46.133.149\" \"10.5.16.62\" \"10.54.16.25\"]\n=> [\"10.5.16.62\" \"10.46.133.149\" \"10.54.16.25\"]\nnaturalSort [\"v0.2\" \"v0.15\" \"v0.0.9\"]\n=> [ \"v0.0.9\" \"v0.2\" \"v0.15\" ]\n```\n\n:::\n",
  "lib.nixType": null,
  "lib.noDepEntry": null,
  "lib.nvs": "attribute set containing one attribute",
  "lib.oldestSupportedReleaseIsAtLeast": "\nWhether a feature is supported in all supported releases (at the time of\nrelease branch-off, if applicable). See `oldestSupportedRelease`.\n\n\n# Inputs\n\n`release`\n\n: Release number of feature introduction as an integer, e.g. 2111 for 21.11.\nSet it to the upcoming release, matching the nixpkgs/.version file.\n",
  "lib.optionAttrSetToDocList": null,
  "lib.optionAttrSetToDocList' (Prime)": null,
  "lib.optional": "\nReturn a singleton list or an empty list, depending on a boolean\nvalue.  Useful when building lists with optional elements\n(e.g. `++ optional (system == \"i686-linux\") firefox`).\n\n# Inputs\n\n`cond`\n\n: 1\\. Function argument\n\n`elem`\n\n: 2\\. Function argument\n\n# Type\n\n```\noptional :: bool -> a -> [a]\n```\n\n# Examples\n:::{.example}\n## `lib.lists.optional` usage example\n\n```nix\noptional true \"foo\"\n=> [ \"foo\" ]\noptional false \"foo\"\n=> [ ]\n```\n\n:::\n",
  "lib.optionalAttrs": "\nIf `cond` is true, return the attribute set `as`,\notherwise an empty attribute set.\n\n\n# Inputs\n\n`cond`\n\n: Condition under which the `as` attribute set is returned.\n\n`as`\n\n: The attribute set to return if `cond` is `true`.\n\n# Type\n\n```\noptionalAttrs :: Bool -> AttrSet -> AttrSet\n```\n\n# Examples\n:::{.example}\n## `lib.attrsets.optionalAttrs` usage example\n\n```nix\noptionalAttrs (true) { my = \"set\"; }\n=> { my = \"set\"; }\noptionalAttrs (false) { my = \"set\"; }\n=> { }\n```\n\n:::\n",
  "lib.optionalDrvAttr": "\nConditionally set a derivation attribute.\n\nBecause `mkDerivation` sets `__ignoreNulls = true`, a derivation\nattribute set to `null` will not impact the derivation output hash.\nThus, this function passes through its `value` argument if the `cond`\nis `true`, but returns `null` if not.\n\n# Inputs\n\n`cond`\n\n: Condition\n\n`value`\n\n: Attribute value\n\n# Type\n\n```\noptionalDrvAttr :: Bool -> a -> a | Null\n```\n\n# Examples\n:::{.example}\n## `lib.derivations.optionalDrvAttr` usage example\n\n```nix\n(stdenv.mkDerivation {\n  name = \"foo\";\n  x = optionalDrvAttr true 1;\n  y = optionalDrvAttr false 1;\n}).drvPath == (stdenv.mkDerivation {\n  name = \"foo\";\n  x = 1;\n}).drvPath\n=> true\n```\n\n:::\n",
  "lib.optionalString": "\nDepending on the boolean `cond', return either the given string\nor the empty string. Useful to concatenate against a bigger string.\n\n\n# Inputs\n\n`cond`\n: Condition\n\n`string`\n: String to return if condition is true\n\n# Type\n\n```\noptionalString :: bool -> string -> string\n```\n\n# Examples\n:::{.example}\n## `lib.strings.optionalString` usage example\n\n```nix\noptionalString true \"some-string\"\n=> \"some-string\"\noptionalString false \"some-string\"\n=> \"\"\n```\n\n:::\n",
  "lib.optionals": "\nReturn a list or an empty list, depending on a boolean value.\n\n# Inputs\n\n`cond`\n\n: Condition\n\n`elems`\n\n: List to return if condition is true\n\n# Type\n\n```\noptionals :: bool -> [a] -> [a]\n```\n\n# Examples\n:::{.example}\n## `lib.lists.optionals` usage example\n\n```nix\noptionals true [ 2 3 ]\n=> [ 2 3 ]\noptionals false [ 2 3 ]\n=> [ ]\n```\n\n:::\n",
  "lib.or": "\nboolean “or”\n\n\n# Inputs\n\n`x`\n\n: 1\\. Function argument\n\n`y`\n\n: 2\\. Function argument\n",
  "lib.overrideDerivation": "\n`overrideDerivation drv f` takes a derivation (i.e., the result\nof a call to the builtin function `derivation`) and returns a new\nderivation in which the attributes of the original are overridden\naccording to the function `f`.  The function `f` is called with\nthe original derivation attributes.\n\n`overrideDerivation` allows certain \"ad-hoc\" customisation\nscenarios (e.g. in ~/.config/nixpkgs/config.nix).  For instance,\nif you want to \"patch\" the derivation returned by a package\nfunction in Nixpkgs to build another version than what the\nfunction itself provides.\n\nFor another application, see build-support/vm, where this\nfunction is used to build arbitrary derivations inside a QEMU\nvirtual machine.\n\nNote that in order to preserve evaluation errors, the new derivation's\noutPath depends on the old one's, which means that this function cannot\nbe used in circular situations when the old derivation also depends on the\nnew one.\n\nYou should in general prefer `drv.overrideAttrs` over this function;\nsee the nixpkgs manual for more information on overriding.\n\n# Inputs\n\n`drv`\n\n: 1\\. Function argument\n\n`f`\n\n: 2\\. Function argument\n\n# Type\n\n```\noverrideDerivation :: Derivation -> ( Derivation -> AttrSet ) -> Derivation\n```\n\n# Examples\n:::{.example}\n## `lib.customisation.overrideDerivation` usage example\n\n```nix\nmySed = overrideDerivation pkgs.gnused (oldAttrs: {\n  name = \"sed-4.2.2-pre\";\n  src = fetchurl {\n    url = ftp://alpha.gnu.org/gnu/sed/sed-4.2.2-pre.tar.bz2;\n    hash = \"sha256-MxBJRcM2rYzQYwJ5XKxhXTQByvSg5jZc5cSHEZoB2IY=\";\n  };\n  patches = [];\n});\n```\n\n:::\n",
  "lib.overrideExisting": "\nOverride only the attributes that are already present in the old set\nuseful for deep-overriding.\n\n\n# Inputs\n\n`old`\n\n: Original attribute set\n\n`new`\n\n: Attribute set with attributes to override in `old`.\n\n# Type\n\n```\noverrideExisting :: AttrSet -> AttrSet -> AttrSet\n```\n\n# Examples\n:::{.example}\n## `lib.attrsets.overrideExisting` usage example\n\n```nix\noverrideExisting {} { a = 1; }\n=> {}\noverrideExisting { b = 2; } { a = 1; }\n=> { b = 2; }\noverrideExisting { a = 3; b = 2; } { a = 1; }\n=> { a = 1; b = 2; }\n```\n\n:::\n",
  "lib.packEntry": null,
  "lib.packagesFromDirectoryRecursive": "\nTransform a directory tree containing package files suitable for\n`callPackage` into a matching nested attribute set of derivations.\n\nFor a directory tree like this:\n\n```\nmy-packages\n├── a.nix\n├── b.nix\n├── c\n│  ├── my-extra-feature.patch\n│  ├── package.nix\n│  └── support-definitions.nix\n└── my-namespace\n   ├── d.nix\n   ├── e.nix\n   └── f\n      └── package.nix\n```\n\n`packagesFromDirectoryRecursive` will produce an attribute set like this:\n\n```nix\n# packagesFromDirectoryRecursive {\n#   callPackage = pkgs.callPackage;\n#   directory = ./my-packages;\n# }\n{\n  a = pkgs.callPackage ./my-packages/a.nix { };\n  b = pkgs.callPackage ./my-packages/b.nix { };\n  c = pkgs.callPackage ./my-packages/c/package.nix { };\n  my-namespace = {\n    d = pkgs.callPackage ./my-packages/my-namespace/d.nix { };\n    e = pkgs.callPackage ./my-packages/my-namespace/e.nix { };\n    f = pkgs.callPackage ./my-packages/my-namespace/f/package.nix { };\n  };\n}\n```\n\nIn particular:\n- If the input directory contains a `package.nix` file, then\n  `callPackage <directory>/package.nix { }` is returned.\n- Otherwise, the input directory's contents are listed and transformed into\n  an attribute set.\n  - If a file name has the `.nix` extension, it is turned into attribute\n    where:\n    - The attribute name is the file name without the `.nix` extension\n    - The attribute value is `callPackage <file path> { }`\n  - Other files are ignored.\n  - Directories are turned into an attribute where:\n    - The attribute name is the name of the directory\n    - The attribute value is the result of calling\n      `packagesFromDirectoryRecursive { ... }` on the directory.\n\n    As a result, directories with no `.nix` files (including empty\n    directories) will be transformed into empty attribute sets.\n\n# Type\n\n```\npackagesFromDirectoryRecursive :: {\n  callPackage :: Path -> {} -> a,\n  directory :: Path,\n  ...\n} -> AttrSet\n```\n\n# Inputs\n\n`callPackage`\n: The function used to convert a Nix file's path into a leaf of the attribute set.\n  It is typically the `callPackage` function, taken from either `pkgs` or a new scope corresponding to the `directory`.\n\n`directory`\n: The directory to read package files from.\n\n\n# Examples\n:::{.example}\n## Basic use of `lib.packagesFromDirectoryRecursive`\n\n```nix\npackagesFromDirectoryRecursive {\n  inherit (pkgs) callPackage;\n  directory = ./my-packages;\n}\n=> { ... }\n```\n\nIn this case, `callPackage` will only search `pkgs` for a file's input parameters.\nIn other words, a file cannot refer to another file in the directory in its input parameters.\n:::\n\n::::{.example}\n## Create a scope for the nix files found in a directory\n```nix\nlib.makeScope pkgs.newScope (\n  self: packagesFromDirectoryRecursive {\n    inherit (self) callPackage;\n    directory = ./my-packages;\n  }\n)\n=> { ... }\n```\n\nFor example, take the following directory structure:\n```\nmy-packages\n├── a.nix    → { b }: assert b ? b1; ...\n└── b\n   ├── b1.nix  → { a }: ...\n   └── b2.nix\n```\n\nHere, `b1.nix` can specify `{ a }` as a parameter, which `callPackage` will resolve as expected.\nLikewise, `a.nix` receive an attrset corresponding to the contents of the `b` directory.\n\n:::{.note}\n`a.nix` cannot directly take as inputs packages defined in a child directory, such as `b1`.\n:::\n\n:::{.warning}\nAs of now, `lib.packagesFromDirectoryRecursive` cannot create nested scopes for sub-directories.\n\nIn particular, files under `b/` can only require (as inputs) other files under `my-packages`,\nbut not to those in the same directory, nor those in a parent directory; e.g, `b2.nix` cannot directly\nrequire `b1`.\n:::\n::::\n",
  "lib.partition": "\nSplits the elements of a list in two lists, `right` and\n`wrong`, depending on the evaluation of a predicate.\n\n# Inputs\n\n`pred`\n\n: Predicate\n\n`list`\n\n: Input list\n\n# Type\n\n```\n(a -> bool) -> [a] -> { right :: [a]; wrong :: [a]; }\n```\n\n# Examples\n:::{.example}\n## `lib.lists.partition` usage example\n\n```nix\npartition (x: x > 2) [ 5 1 2 3 4 ]\n=> { right = [ 5 3 4 ]; wrong = [ 1 2 ]; }\n```\n\n:::\n",
  "lib.pathExists": "\nReturn `true` if the path *path* exists at evaluation time, and\n`false` otherwise.\n",
  "lib.pathHasContext": "\nReturn `true` if string *s* has a non-empty context.\nThe context can be obtained with\n[`getContext`](#builtins-getContext).\n\n> **Example**\n>\n> Many operations require a string context to be empty because they are intended only to work with \"regular\" strings, and also to help users avoid unintentionally loosing track of string context elements.\n> `builtins.hasContext` can help create better domain-specific errors in those case.\n>\n> ```nix\n> name: meta:\n>\n> if builtins.hasContext name\n> then throw \"package name cannot contain string context\"\n> else { ${name} = meta; }\n> ```\n",
  "lib.pathIsDirectory": "\nWhether a path exists and is a directory.\n\n\n# Inputs\n\n`path`\n\n: 1\\. Function argument\n\n# Type\n\n```\npathIsDirectory :: Path -> Bool\n```\n\n# Examples\n:::{.example}\n## `lib.filesystem.pathIsDirectory` usage example\n\n```nix\npathIsDirectory /.\n=> true\n\npathIsDirectory /this/does/not/exist\n=> false\n\npathIsDirectory /some/file.nix\n=> false\n```\n\n:::\n",
  "lib.pathIsGitRepo": null,
  "lib.pathIsRegularFile": "\nWhether a path exists and is a regular file, meaning not a symlink or any other special file type.\n\n\n# Inputs\n\n`path`\n\n: 1\\. Function argument\n\n# Type\n\n```\npathIsRegularFile :: Path -> Bool\n```\n\n# Examples\n:::{.example}\n## `lib.filesystem.pathIsRegularFile` usage example\n\n```nix\npathIsRegularFile /.\n=> false\n\npathIsRegularFile /this/does/not/exist\n=> false\n\npathIsRegularFile /some/file.nix\n=> true\n```\n\n:::\n",
  "lib.pathType": "\nThe type of a path. The path needs to exist and be accessible.\nThe result is either \"directory\" for a directory, \"regular\" for a regular file, \"symlink\" for a symlink, or \"unknown\" for anything else.\n\n# Inputs\n\npath\n\n: The path to query\n\n# Type\n\n```\npathType :: Path -> String\n```\n\n# Examples\n:::{.example}\n## `lib.filesystem.pathType` usage example\n\n```nix\npathType /.\n=> \"directory\"\n\npathType /some/file.nix\n=> \"regular\"\n```\n\n:::\n",
  "lib.pipe": "\nPipes a value through a list of functions, left to right.\n\n# Inputs\n\n`value`\n\n: Value to start piping.\n\n`fns`\n\n: List of functions to apply sequentially.\n\n# Type\n\n```\npipe :: a -> [<functions>] -> <return type of last function>\n```\n\n# Examples\n:::{.example}\n## `lib.trivial.pipe` usage example\n\n```nix\npipe 2 [\n    (x: x + 2)  # 2 + 2 = 4\n    (x: x * 2)  # 4 * 2 = 8\n  ]\n=> 8\n\n# ideal to do text transformations\npipe [ \"a/b\" \"a/c\" ] [\n\n  # create the cp command\n  (map (file: ''cp \"${src}/${file}\" $out\\n''))\n\n  # concatenate all commands into one string\n  lib.concatStrings\n\n  # make that string into a nix derivation\n  (pkgs.runCommand \"copy-to-out\" {})\n\n]\n=> <drv which copies all files to $out>\n\nThe output type of each function has to be the input type\nof the next function, and the last function returns the\nfinal value.\n```\n\n:::\n",
  "lib.pushDownProperties": "\nGiven a config set, expand mkMerge properties, and push down the\nother properties into the children.  The result is a list of\nconfig sets that do not have properties at top-level.  For\nexample,\n\n  mkMerge [ { boot = set1; } (mkIf cond { boot = set2; services = set3; }) ]\n\nis transformed into\n\n  [ { boot = set1; } { boot = mkIf cond set2; services = mkIf cond set3; } ].\n\nThis transform is the critical step that allows mkIf conditions\nto refer to the full configuration without creating an infinite\nrecursion.\n\n\n# Inputs\n\n`cfg`\n\n: 1\\. Function argument\n",
  "lib.range": "\nReturn a list of integers from `first` up to and including `last`.\n\n# Inputs\n\n`first`\n\n: First integer in the range\n\n`last`\n\n: Last integer in the range\n\n# Type\n\n```\nrange :: int -> int -> [int]\n```\n\n# Examples\n:::{.example}\n## `lib.lists.range` usage example\n\n```nix\nrange 2 4\n=> [ 2 3 4 ]\nrange 3 2\n=> [ ]\n```\n\n:::\n",
  "lib.readFile": "\nReturn the contents of the file *path* as a string.\n",
  "lib.readPathsFromFile": "\nRead a list of paths from `file`, relative to the `rootPath`.\nLines beginning with `#` are treated as comments and ignored.\nWhitespace is significant.\n\n:::{.warning}\nThis function is deprecated and should be avoided.\n:::\n\n:::{.note}\nThis function is not performant and should be avoided.\n:::\n\n# Inputs\n\n`rootPath`\n: 1\\. Function argument\n\n`file`\n: 2\\. Function argument\n\n# Type\n\n```\nreadPathsFromFile :: string -> string -> [string]\n```\n\n# Examples\n:::{.example}\n## `lib.strings.readPathsFromFile` usage example\n\n```nix\nreadPathsFromFile /prefix\n  ./pkgs/development/libraries/qt-5/5.4/qtbase/series\n=> [ \"/prefix/dlopen-resolv.patch\" \"/prefix/tzdir.patch\"\n     \"/prefix/dlopen-libXcursor.patch\" \"/prefix/dlopen-openssl.patch\"\n     \"/prefix/dlopen-dbus.patch\" \"/prefix/xdg-config-dirs.patch\"\n     \"/prefix/nix-profiles-library-paths.patch\"\n     \"/prefix/compose-search-path.patch\" ]\n```\n\n:::\n",
  "lib.recurseIntoAttrs": "\nMake various Nix tools consider the contents of the resulting\nattribute set when looking for what to build, find, etc.\n\nThis function only affects a single attribute set; it does not\napply itself recursively for nested attribute sets.\n\n\n# Inputs\n\n`attrs`\n\n: An attribute set to scan for derivations.\n\n# Type\n\n```\nrecurseIntoAttrs :: AttrSet -> AttrSet\n```\n\n# Examples\n:::{.example}\n## `lib.attrsets.recurseIntoAttrs` usage example\n\n```nix\n{ pkgs ? import <nixpkgs> {} }:\n{\n  myTools = pkgs.lib.recurseIntoAttrs {\n    inherit (pkgs) hello figlet;\n  };\n}\n```\n\n:::\n",
  "lib.recursiveUpdate": "\nA recursive variant of the update operator ‘//’.  The recursion\nstops when one of the attribute values is not an attribute set,\nin which case the right hand side value takes precedence over the\nleft hand side value.\n\n\n# Inputs\n\n`lhs`\n\n: Left attribute set of the merge.\n\n`rhs`\n\n: Right attribute set of the merge.\n\n# Type\n\n```\nrecursiveUpdate :: AttrSet -> AttrSet -> AttrSet\n```\n\n# Examples\n:::{.example}\n## `lib.attrsets.recursiveUpdate` usage example\n\n```nix\nrecursiveUpdate {\n  boot.loader.grub.enable = true;\n  boot.loader.grub.device = \"/dev/hda\";\n} {\n  boot.loader.grub.device = \"\";\n}\n\nreturns: {\n  boot.loader.grub.enable = true;\n  boot.loader.grub.device = \"\";\n}\n```\n\n:::\n",
  "lib.recursiveUpdateUntil": "\nDoes the same as the update operator '//' except that attributes are\nmerged until the given predicate is verified.  The predicate should\naccept 3 arguments which are the path to reach the attribute, a part of\nthe first attribute set and a part of the second attribute set.  When\nthe predicate is satisfied, the value of the first attribute set is\nreplaced by the value of the second attribute set.\n\n\n# Inputs\n\n`pred`\n\n: Predicate, taking the path to the current attribute as a list of strings for attribute names, and the two values at that path from the original arguments.\n\n`lhs`\n\n: Left attribute set of the merge.\n\n`rhs`\n\n: Right attribute set of the merge.\n\n# Type\n\n```\nrecursiveUpdateUntil :: ( [ String ] -> AttrSet -> AttrSet -> Bool ) -> AttrSet -> AttrSet -> AttrSet\n```\n\n# Examples\n:::{.example}\n## `lib.attrsets.recursiveUpdateUntil` usage example\n\n```nix\nrecursiveUpdateUntil (path: l: r: path == [\"foo\"]) {\n  # first attribute set\n  foo.bar = 1;\n  foo.baz = 2;\n  bar = 3;\n} {\n  #second attribute set\n  foo.bar = 1;\n  foo.quz = 2;\n  baz = 4;\n}\n\n=> {\n  foo.bar = 1; # 'foo.*' from the second set\n  foo.quz = 2; #\n  bar = 3;     # 'bar' from the first set\n  baz = 4;     # 'baz' from the second set\n}\n```\n\n:::\n",
  "lib.remove": "\nRemove elements equal to 'e' from a list.  Useful for buildInputs.\n\n\n# Inputs\n\n`e`\n\n: Element to remove from `list`\n\n`list`\n\n: The list\n\n# Type\n\n```\nremove :: a -> [a] -> [a]\n```\n\n# Examples\n:::{.example}\n## `lib.lists.remove` usage example\n\n```nix\nremove 3 [ 1 3 4 3 ]\n=> [ 1 4 ]\n```\n\n:::\n",
  "lib.removeAttrs": "\nRemove the attributes listed in *list* from *set*. The attributes\ndon’t have to exist in *set*. For instance,\n\n```nix\nremoveAttrs { x = 1; y = 2; z = 3; } [ \"a\" \"x\" \"z\" ]\n```\n\nevaluates to `{ y = 2; }`.\n",
  "lib.removePrefix": "\nReturn a string without the specified prefix, if the prefix matches.\n\n# Inputs\n\n`prefix`\n: Prefix to remove if it matches\n\n`str`\n: Input string\n\n# Type\n\n```\nremovePrefix :: string -> string -> string\n```\n\n# Examples\n:::{.example}\n## `lib.strings.removePrefix` usage example\n\n```nix\nremovePrefix \"foo.\" \"foo.bar.baz\"\n=> \"bar.baz\"\nremovePrefix \"xxx\" \"foo.bar.baz\"\n=> \"foo.bar.baz\"\n```\n\n:::\n",
  "lib.removeSuffix": "\nReturn a string without the specified suffix, if the suffix matches.\n\n\n# Inputs\n\n`suffix`\n: Suffix to remove if it matches\n\n`str`\n: Input string\n\n# Type\n\n```\nremoveSuffix :: string -> string -> string\n```\n\n# Examples\n:::{.example}\n## `lib.strings.removeSuffix` usage example\n\n```nix\nremoveSuffix \"front\" \"homefront\"\n=> \"home\"\nremoveSuffix \"xxx\" \"homefront\"\n=> \"homefront\"\n```\n\n:::\n",
  "lib.replaceChars": "\nGiven string *s*, replace every occurrence of the strings in *from*\nwith the corresponding string in *to*.\n\nThe argument *to* is lazy, that is, it is only evaluated when its corresponding pattern in *from* is matched in the string *s*\n\nExample:\n\n```nix\nbuiltins.replaceStrings [\"oo\" \"a\"] [\"a\" \"i\"] \"foobar\"\n```\n\nevaluates to `\"fabir\"`.\n",
  "lib.replaceStrings": "\nGiven string *s*, replace every occurrence of the strings in *from*\nwith the corresponding string in *to*.\n\nThe argument *to* is lazy, that is, it is only evaluated when its corresponding pattern in *from* is matched in the string *s*\n\nExample:\n\n```nix\nbuiltins.replaceStrings [\"oo\" \"a\"] [\"a\" \"i\"] \"foobar\"\n```\n\nevaluates to `\"fabir\"`.\n",
  "lib.replicate": "\nReturn a list with `n` copies of an element.\n\n# Inputs\n\n`n`\n\n: 1\\. Function argument\n\n`elem`\n\n: 2\\. Function argument\n\n# Type\n\n```\nreplicate :: int -> a -> [a]\n```\n\n# Examples\n:::{.example}\n## `lib.lists.replicate` usage example\n\n```nix\nreplicate 3 \"a\"\n=> [ \"a\" \"a\" \"a\" ]\nreplicate 2 true\n=> [ true true ]\n```\n\n:::\n",
  "lib.reverseList": "\nReverse the order of the elements of a list.\n\n# Inputs\n\n`xs`\n\n: 1\\. Function argument\n\n# Type\n\n```\nreverseList :: [a] -> [a]\n```\n\n# Examples\n:::{.example}\n## `lib.lists.reverseList` usage example\n\n```nix\nreverseList [ \"b\" \"o\" \"j\" ]\n=> [ \"j\" \"o\" \"b\" ]\n```\n\n:::\n",
  "lib.runTests": "\nEvaluates a set of tests.\n\nA test is an attribute set `{expr, expected}`,\ndenoting an expression and its expected result.\n\nThe result is a `list` of __failed tests__, each represented as\n`{name, expected, result}`,\n\n- expected\n  - What was passed as `expected`\n- result\n  - The actual `result` of the test\n\nUsed for regression testing of the functions in lib; see\ntests.nix for more examples.\n\nImportant: Only attributes that start with `test` are executed.\n\n- If you want to run only a subset of the tests add the attribute `tests = [\"testName\"];`\n\n# Inputs\n\n`tests`\n\n: Tests to run\n\n# Type\n\n```\nrunTests :: {\n  tests = [ String ];\n  ${testName} :: {\n    expr :: a;\n    expected :: a;\n  };\n}\n->\n[\n  {\n    name :: String;\n    expected :: a;\n    result :: a;\n  }\n]\n```\n\n# Examples\n:::{.example}\n## `lib.debug.runTests` usage example\n\n```nix\nrunTests {\n  testAndOk = {\n    expr = lib.and true false;\n    expected = false;\n  };\n  testAndFail = {\n    expr = lib.and true false;\n    expected = true;\n  };\n}\n->\n[\n  {\n    name = \"testAndFail\";\n    expected = true;\n    result = false;\n  }\n]\n```\n\n:::\n",
  "lib.scrubOptionValue": "\nThis function recursively removes all derivation attributes from\n`x` except for the `name` attribute.\n\nThis is to make the generation of `options.xml` much more\nefficient: the XML representation of derivations is very large\n(on the order of megabytes) and is not actually used by the\nmanual generator.\n\nThis function was made obsolete by renderOptionValue and is kept for\ncompatibility with out-of-tree code.\n\n\n# Inputs\n\n`x`\n\n: 1\\. Function argument\n",
  "lib.seq": "\nEvaluate *e1*, then evaluate and return *e2*. This ensures that a\ncomputation is strict in the value of *e1*.\n",
  "lib.setAttr": "adds / replaces an attribute of an attribute set",
  "lib.setAttrByPath": "\nCreate a new attribute set with `value` set at the nested attribute location specified in `attrPath`.\n\n\n# Inputs\n\n`attrPath`\n\n: A list of strings representing the attribute path to set\n\n`value`\n\n: The value to set at the location described by `attrPath`\n\n# Type\n\n```\nsetAttrByPath :: [String] -> Any -> AttrSet\n```\n\n# Examples\n:::{.example}\n## `lib.attrsets.setAttrByPath` usage example\n\n```nix\nsetAttrByPath [\"a\" \"b\"] 3\n=> { a = { b = 3; }; }\n```\n\n:::\n",
  "lib.setAttrMerge": "setAttrMerge \"a\" [] {         } (x: x ++ [3]) -> { a = [  3]; }",
  "lib.setDefaultModuleLocation": "\nWrap a module with a default location for reporting errors.\n\n\n# Inputs\n\n`file`\n\n: 1\\. Function argument\n\n`m`\n\n: 2\\. Function argument\n",
  "lib.setFunctionArgs": "\nAdd metadata about expected function arguments to a function.\nThe metadata should match the format given by\nbuiltins.functionArgs, i.e. a set from expected argument to a bool\nrepresenting whether that argument has a default or not.\nsetFunctionArgs : (a → b) → Map String Bool → (a → b)\n\nThis function is necessary because you can't dynamically create a\nfunction of the { a, b ? foo, ... }: format, but some facilities\nlike callPackage expect to be able to query expected arguments.\n\n\n# Inputs\n\n`f`\n\n: 1\\. Function argument\n\n`args`\n\n: 2\\. Function argument\n",
  "lib.setName": "\nChange the [symbolic name of a derivation](https://nixos.org/manual/nix/stable/language/derivations.html#attr-name).\n\n:::{.warning}\nDependent derivations will be rebuilt when the symbolic name is changed.\n:::\n\n# Inputs\n\n`name`\n\n: 1\\. Function argument\n\n`drv`\n\n: 2\\. Function argument\n",
  "lib.setPrio": "\nSet the nix-env priority of the package. Note that higher values are lower priority, and vice versa.\n\n# Inputs\n\n`priority`\n: 1\\. The priority to set.\n\n`drv`\n: 2\\. Function argument\n",
  "lib.setType": null,
  "lib.showAttrPath": "\nTurns a list of strings into a human-readable description of those\nstrings represented as an attribute path. The result of this function is\nnot intended to be machine-readable.\nCreate a new attribute set with `value` set at the nested attribute location specified in `attrPath`.\n\n\n# Inputs\n\n`path`\n\n: Attribute path to render to a string\n\n# Type\n\n```\nshowAttrPath :: [String] -> String\n```\n\n# Examples\n:::{.example}\n## `lib.attrsets.showAttrPath` usage example\n\n```nix\nshowAttrPath [ \"foo\" \"10\" \"bar\" ]\n=> \"foo.\\\"10\\\".bar\"\nshowAttrPath []\n=> \"<root attribute path>\"\n```\n\n:::\n",
  "lib.showFiles": null,
  "lib.showOption": "\nConvert an option, described as a list of the option parts to a\nhuman-readable version.\n\n\n# Inputs\n\n`parts`\n\n: 1\\. Function argument\n\n\n# Examples\n:::{.example}\n## `showOption` usage example\n\n```nix\n(showOption [\"foo\" \"bar\" \"baz\"]) == \"foo.bar.baz\"\n  (showOption [\"foo\" \"bar.baz\" \"tux\"]) == \"foo.\\\"bar.baz\\\".tux\"\n  (showOption [\"windowManager\" \"2bwm\" \"enable\"]) == \"windowManager.\\\"2bwm\\\".enable\"\n\nPlaceholders will not be quoted as they are not actual values:\n  (showOption [\"foo\" \"*\" \"bar\"]) == \"foo.*.bar\"\n  (showOption [\"foo\" \"<name>\" \"bar\"]) == \"foo.<name>.bar\"\n  (showOption [\"foo\" \"<myPlaceholder>\" \"bar\"]) == \"foo.<myPlaceholder>.bar\"\n```\n\n:::\n",
  "lib.showOptionWithDefLocs": "\nPretty prints all option definition locations\n\n# Inputs\n\n`option`\n: The option to pretty print\n\n# Examples\n:::{.example}\n## `lib.options.showOptionWithDefLocs` usage example\n\n\n```nix\nshowOptionWithDefLocs { loc = [\"x\" \"y\" ]; files = [ \"foo.nix\" \"bar.nix\" ];  }\n\"x.y, with values defined in:\\n  - foo.nix\\n  - bar.nix\\n\"\n```\n\n```nix\nnix-repl> eval = lib.evalModules {\n    modules = [\n      {\n        options = {\n          foo = lib.mkEnableOption \"foo\";\n        };\n      }\n    ];\n  }\n\nnix-repl> lib.options.showOptionWithDefLocs eval.options.foo\n\"foo, with values defined in:\\n  - <unknown-file>\\n\"\n```\n\n:::\n\n# Type\n\n```\nshowDefsSep :: { files :: [ String ]; loc :: [ String ]; ... } -> string\n```\n",
  "lib.showWarnings": null,
  "lib.singleton": "\nCreate a list consisting of a single element. `singleton x` is\nsometimes more convenient with respect to indentation than `[x]`\nwhen x spans multiple lines.\n\n# Inputs\n\n`x`\n\n: 1\\. Function argument\n\n# Type\n\n```\nsingleton :: a -> [a]\n```\n\n# Examples\n:::{.example}\n## `lib.lists.singleton` usage example\n\n```nix\nsingleton \"foo\"\n=> [ \"foo\" ]\n```\n\n:::\n",
  "lib.sort": "\nSort a list based on a comparator function which compares two\nelements and returns true if the first argument is strictly below\nthe second argument.  The returned list is sorted in an increasing\norder.  The implementation does a quick-sort.\n\nSee also [`sortOn`](#function-library-lib.lists.sortOn), which applies the\ndefault comparison on a function-derived property, and may be more efficient.\n\n# Inputs\n\n`comparator`\n\n: 1\\. Function argument\n\n`list`\n\n: 2\\. Function argument\n\n# Type\n\n```\nsort :: (a -> a -> Bool) -> [a] -> [a]\n```\n\n# Examples\n:::{.example}\n## `lib.lists.sort` usage example\n\n```nix\nsort (p: q: p < q) [ 5 3 7 ]\n=> [ 3 5 7 ]\n```\n\n:::\n",
  "lib.sortOn": "\nSort a list based on the default comparison of a derived property `b`.\n\nThe items are returned in `b`-increasing order.\n\n**Performance**:\n\nThe passed function `f` is only evaluated once per item,\nunlike an unprepared [`sort`](#function-library-lib.lists.sort) using\n`f p < f q`.\n\n**Laws**:\n```nix\nsortOn f == sort (p: q: f p < f q)\n```\n\n\n# Inputs\n\n`f`\n\n: 1\\. Function argument\n\n`list`\n\n: 2\\. Function argument\n\n# Type\n\n```\nsortOn :: (a -> b) -> [a] -> [a], for comparable b\n```\n\n# Examples\n:::{.example}\n## `lib.lists.sortOn` usage example\n\n```nix\nsortOn stringLength [ \"aa\" \"b\" \"cccc\" ]\n=> [ \"b\" \"aa\" \"cccc\" ]\n```\n\n:::\n",
  "lib.sortProperties": "\nSort a list of properties.  The sort priority of a property is\ndefaultOrderPriority by default, but can be overridden by wrapping the property\nusing mkOrder.\n\n\n# Inputs\n\n`defs`\n\n: 1\\. Function argument\n",
  "lib.sourceByRegex": "\nFilter sources by a list of regular expressions.\n\n# Inputs\n\n`src`\n\n: 1\\. Function argument\n\n`regexes`\n\n: 2\\. Function argument\n\n# Examples\n:::{.example}\n## `sourceByRegex` usage example\n\n```nix\nsrc = sourceByRegex ./my-subproject [\".*\\.py$\" \"^database.sql$\"]\n```\n\n:::\n",
  "lib.sourceFilesBySuffices": "\nGet all files ending with the specified suffices from the given\nsource directory or its descendants, omitting files that do not match\nany suffix. The result of the example below will include files like\n`./dir/module.c` and `./dir/subdir/doc.xml` if present.\n\n# Inputs\n\n`src`\n\n: Path or source containing the files to be returned\n\n`exts`\n\n: A list of file suffix strings\n\n# Type\n\n```\nsourceLike -> [String] -> Source\n```\n\n# Examples\n:::{.example}\n## `sourceFilesBySuffices` usage example\n\n```nix\nsourceFilesBySuffices ./. [ \".xml\" \".c\" ]\n```\n\n:::\n",
  "lib.split": "\nReturns a list composed of non matched strings interleaved with the\nlists of the [extended POSIX regular\nexpression](http://pubs.opengroup.org/onlinepubs/9699919799/basedefs/V1_chap09.html#tag_09_04)\n*regex* matches of *str*. Each item in the lists of matched\nsequences is a regex group.\n\n```nix\nbuiltins.split \"(a)b\" \"abc\"\n```\n\nEvaluates to `[ \"\" [ \"a\" ] \"c\" ]`.\n\n```nix\nbuiltins.split \"([ac])\" \"abc\"\n```\n\nEvaluates to `[ \"\" [ \"a\" ] \"b\" [ \"c\" ] \"\" ]`.\n\n```nix\nbuiltins.split \"(a)|(c)\" \"abc\"\n```\n\nEvaluates to `[ \"\" [ \"a\" null ] \"b\" [ null \"c\" ] \"\" ]`.\n\n```nix\nbuiltins.split \"([[:upper:]]+)\" \" FOO \"\n```\n\nEvaluates to `[ \" \" [ \"FOO\" ] \" \" ]`.\n",
  "lib.splitByAndCompare": "\nSplit type into two subtypes by predicate `p`, take all elements\nof the first subtype to be less than all the elements of the\nsecond subtype, compare elements of a single subtype with `yes`\nand `no` respectively.\n\n\n# Inputs\n\n`p`\n\n: Predicate\n\n`yes`\n\n: Comparison function if predicate holds for both values\n\n`no`\n\n: Comparison function if predicate holds for neither value\n\n`a`\n\n: First value to compare\n\n`b`\n\n: Second value to compare\n\n# Type\n\n```\n(a -> bool) -> (a -> a -> int) -> (a -> a -> int) -> (a -> a -> int)\n```\n\n# Examples\n:::{.example}\n## `lib.trivial.splitByAndCompare` usage example\n\n```nix\nlet cmp = splitByAndCompare (hasPrefix \"foo\") compare compare; in\n\ncmp \"a\" \"z\" => -1\ncmp \"fooa\" \"fooz\" => -1\n\ncmp \"f\" \"a\" => 1\ncmp \"fooa\" \"a\" => -1\n# while\ncompare \"fooa\" \"a\" => 1\n```\n\n:::\n",
  "lib.splitString": "\nCut a string with a separator and produces a list of strings which\nwere separated by this separator.\n\n# Inputs\n\n`sep`\n: 1\\. Function argument\n\n`s`\n: 2\\. Function argument\n\n# Type\n\n```\nsplitString :: string -> string -> [string]\n```\n\n# Examples\n:::{.example}\n## `lib.strings.splitString` usage example\n\n```nix\nsplitString \".\" \"foo.bar.baz\"\n=> [ \"foo\" \"bar\" \"baz\" ]\nsplitString \"/\" \"/usr/local/bin\"\n=> [ \"\" \"usr\" \"local\" \"bin\" ]\n```\n\n:::\n",
  "lib.splitVersion": "\nBreak a version string into its component parts.\n\n# Examples\n:::{.example}\n## `splitVersion` usage example\n\n```nix\nsplitVersion \"1.2.3\"\n=> [\"1\" \"2\" \"3\"]\n```\n\n:::\n",
  "lib.stringAfter": null,
  "lib.stringAsChars": "\nManipulate a string character by character and replace them by\nstrings before concatenating the results.\n\n\n# Inputs\n\n`f`\n: Function to map over each individual character\n\n`s`\n: Input string\n\n# Type\n\n```\nstringAsChars :: (string -> string) -> string -> string\n```\n\n# Examples\n:::{.example}\n## `lib.strings.stringAsChars` usage example\n\n```nix\nstringAsChars (x: if x == \"a\" then \"i\" else x) \"nax\"\n=> \"nix\"\n```\n\n:::\n",
  "lib.stringLength": "\nReturn the number of bytes of the string *e*. If *e* is not a string,\nevaluation is aborted.\n",
  "lib.stringToCharacters": "\nConvert a string `s` to a list of characters (i.e. singleton strings).\nThis allows you to, e.g., map a function over each character.  However,\nnote that this will likely be horribly inefficient; Nix is not a\ngeneral purpose programming language. Complex string manipulations\nshould, if appropriate, be done in a derivation.\nAlso note that Nix treats strings as a list of bytes and thus doesn't\nhandle unicode.\n\n\n# Inputs\n\n`s`\n: 1\\. Function argument\n\n# Type\n\n```\nstringToCharacters :: string -> [string]\n```\n\n# Examples\n:::{.example}\n## `lib.strings.stringToCharacters` usage example\n\n```nix\nstringToCharacters \"\"\n=> [ ]\nstringToCharacters \"abc\"\n=> [ \"a\" \"b\" \"c\" ]\nstringToCharacters \"🦄\"\n=> [ \"�\" \"�\" \"�\" \"�\" ]\n```\n\n:::\n",
  "lib.sub": "\nReturn the difference between the numbers *e1* and *e2*.\n",
  "lib.sublist": "\nReturn a list consisting of at most `count` elements of `list`,\nstarting at index `start`.\n\n# Inputs\n\n`start`\n\n: Index at which to start the sublist\n\n`count`\n\n: Number of elements to take\n\n`list`\n\n: Input list\n\n# Type\n\n```\nsublist :: int -> int -> [a] -> [a]\n```\n\n# Examples\n:::{.example}\n## `lib.lists.sublist` usage example\n\n```nix\nsublist 1 3 [ \"a\" \"b\" \"c\" \"d\" \"e\" ]\n=> [ \"b\" \"c\" \"d\" ]\nsublist 1 3 [ ]\n=> [ ]\n```\n\n:::\n",
  "lib.substring": "\nReturn the substring of *s* from byte position *start*\n(zero-based) up to but not including *start + len*. If *start* is\ngreater than the length of the string, an empty string is returned.\nIf *start + len* lies beyond the end of the string or *len* is `-1`,\nonly the substring up to the end of the string is returned.\n*start* must be non-negative.\nFor example,\n\n```nix\nbuiltins.substring 0 3 \"nixos\"\n```\n\nevaluates to `\"nix\"`.\n",
  "lib.subtractLists": "\nSubtracts list 'e' from another list (`list2`).\n\nO(nm) complexity.\n\n# Inputs\n\n`e`\n\n: First list\n\n`list2`\n\n: Second list\n\n\n# Examples\n:::{.example}\n## `lib.lists.subtractLists` usage example\n\n```nix\nsubtractLists [ 3 2 ] [ 1 2 3 4 5 3 ]\n=> [ 1 4 5 ]\n```\n\n:::\n",
  "lib.tail": "\nReturn the list without its first item; abort evaluation if\nthe argument isn’t a list or is an empty list.\n\n> **Warning**\n>\n> This function should generally be avoided since it's inefficient:\n> unlike Haskell's `tail`, it takes O(n) time, so recursing over a\n> list by repeatedly calling `tail` takes O(n^2) time.\n",
  "lib.take": "\nReturn the first (at most) N elements of a list.\n\n\n# Inputs\n\n`count`\n\n: Number of elements to take\n\n`list`\n\n: Input list\n\n# Type\n\n```\ntake :: int -> [a] -> [a]\n```\n\n# Examples\n:::{.example}\n## `lib.lists.take` usage example\n\n```nix\ntake 2 [ \"a\" \"b\" \"c\" \"d\" ]\n=> [ \"a\" \"b\" ]\ntake 2 [ ]\n=> [ ]\n```\n\n:::\n",
  "lib.testAllTrue": "\nCreate a test assuming that list elements are `true`.\n\n# Inputs\n\n`expr`\n\n: 1\\. Function argument\n\n# Examples\n:::{.example}\n## `lib.debug.testAllTrue` usage example\n\n```nix\n{ testX = allTrue [ true ]; }\n```\n\n:::\n",
  "lib.textClosureList": "\nTopologically sort a collection of dependent strings.\nOnly the values to keys listed in `arg` and their dependencies will be included in the result.\n\n::: {.note}\nThis function doesn't formally fulfill the definition of topological sorting, but it's good enough for our purposes in Nixpkgs.\n:::\n\n# Inputs\n\n`predefined` (attribute set)\n\n: strings with annotated dependencies (strings or attribute set)\n  A value can be a simple string if it has no dependencies.\n  Otherwise, is can be an attribute set with the following attributes:\n  - `deps` (list of strings)\n  - `text` (Any\n\n`arg` (list of strings)\n\n: Keys for which the values in the dependency closure will be included in the result\n\n# Type\n\n```\ntextClosureList :: { ${phase} :: { deps :: [String]; text :: String; } | String; } -> [String] -> [String]\n```\n\n# Examples\n:::{.example}\n## `lib.stringsWithDeps.textClosureList` usage example\n\n```nix\ntextClosureList {\n  a = {\n    deps = [ \"b\" \"c\" \"e\" ];\n    text = \"a: depends on b, c and e\";\n  };\n  b = {\n    deps = [ ];\n    text = \"b: no dependencies\";\n  };\n  c = {\n    deps = [ \"b\" ];\n    text = \"c: depends on b\";\n  };\n  d = {\n    deps = [ \"c\" ];\n    text = \"d: not being depended on by anything in `arg`\";\n  };\n  e = {\n    deps = [ \"c\" ];\n    text = \"e: depends on c, depended on by a, not in `arg`\";\n  };\n} [\n  \"a\"\n  \"b\"\n  \"c\"\n]\n=> [\n  \"b: no dependencies\"\n  \"c: depends on b\"\n  \"e: depends on c, depended on by a, not in `arg`\"\n  \"a: depends on b, c and e\"\n]\n```\n:::\n\nCommon real world usages are:\n- Ordering the dependent phases of `system.activationScripts`\n- Ordering the dependent phases of `system.userActivationScripts`\n\nFor further examples see: [NixOS activation script](https://nixos.org/manual/nixos/stable/#sec-activation-script)\n\n",
  "lib.textClosureMap": null,
  "lib.throwIf": "\nLike throwIfNot, but negated (throw if the first argument is `true`).\n\n\n# Inputs\n\n`cond`\n\n: 1\\. Function argument\n\n`msg`\n\n: 2\\. Function argument\n\n# Type\n\n```\nbool -> string -> a -> a\n```\n",
  "lib.throwIfNot": "\nLike the `assert b; e` expression, but with a custom error message and\nwithout the semicolon.\n\nIf true, return the identity function, `r: r`.\n\nIf false, throw the error message.\n\nCalls can be juxtaposed using function application, as `(r: r) a = a`, so\n`(r: r) (r: r) a = a`, and so forth.\n\n\n# Inputs\n\n`cond`\n\n: 1\\. Function argument\n\n`msg`\n\n: 2\\. Function argument\n\n# Type\n\n```\nbool -> string -> a -> a\n```\n\n# Examples\n:::{.example}\n## `lib.trivial.throwIfNot` usage example\n\n```nix\nthrowIfNot (lib.isList overlays) \"The overlays argument to nixpkgs must be a list.\"\nlib.foldr (x: throwIfNot (lib.isFunction x) \"All overlays passed to nixpkgs must be functions.\") (r: r) overlays\npkgs\n```\n\n:::\n",
  "lib.toBaseDigits": "\n`toBaseDigits base i` converts the positive integer i to a list of its\ndigits in the given base. For example:\n\ntoBaseDigits 10 123 => [ 1 2 3 ]\n\ntoBaseDigits 2 6 => [ 1 1 0 ]\n\ntoBaseDigits 16 250 => [ 15 10 ]\n\n\n# Inputs\n\n`base`\n\n: 1\\. Function argument\n\n`i`\n\n: 2\\. Function argument\n",
  "lib.toDerivation": "\nConverts a store path to a fake derivation.\n\n\n# Inputs\n\n`path`\n\n: A store path to convert to a derivation.\n\n# Type\n\n```\ntoDerivation :: Path -> Derivation\n```\n",
  "lib.toExtension": "\nConvert to an extending function (overlay).\n\n`toExtension` is the `toFunction` for extending functions (a.k.a. extensions or overlays).\nIt converts a non-function or a single-argument function to an extending function,\nwhile returning a two-argument function as-is.\n\nThat is, it takes a value of the shape `x`, `prev: x`, or `final: prev: x`,\nand returns `final: prev: x`, assuming `x` is not a function.\n\nThis function takes care of the input to `stdenv.mkDerivation`'s\n`overrideAttrs` function.\nIt bridges the gap between `<pkg>.overrideAttrs`\nbefore and after the overlay-style support.\n\n# Inputs\n\n`f`\n: The function or value to convert to an extending function.\n\n# Type\n\n```\ntoExtension ::\n  b' -> Any -> Any -> b'\nor\ntoExtension ::\n  (a -> b') -> Any -> a -> b'\nor\ntoExtension ::\n  (a -> a -> b) -> a -> a -> b\nwhere b' = ! Callable\n\nSet a = b = b' = AttrSet & ! Callable to make toExtension return an extending function.\n```\n\n# Examples\n:::{.example}\n## `lib.fixedPoints.toExtension` usage example\n\n```nix\nfix (final: { a = 0; c = final.a; })\n=> { a = 0; c = 0; };\n\nfix (extends (toExtension { a = 1; b = 2; }) (final: { a = 0; c = final.a; }))\n=> { a = 1; b = 2; c = 1; };\n\nfix (extends (toExtension (prev: { a = 1; b = prev.a; })) (final: { a = 0; c = final.a; }))\n=> { a = 1; b = 0; c = 1; };\n\nfix (extends (toExtension (final: prev: { a = 1; b = prev.a; c = final.a + 1 })) (final: { a = 0; c = final.a; }))\n=> { a = 1; b = 0; c = 2; };\n```\n:::\n",
  "lib.toFunction": "\nTurns any non-callable values into constant functions.\nReturns callable values as is.\n\n\n# Inputs\n\n`v`\n\n: Any value\n\n\n# Examples\n:::{.example}\n## `lib.trivial.toFunction` usage example\n\n```nix\nnix-repl> lib.toFunction 1 2\n1\n\nnix-repl> lib.toFunction (x: x + 1) 2\n3\n```\n\n:::\n",
  "lib.toHexString": "\nConvert the given positive integer to a string of its hexadecimal\nrepresentation. For example:\n\ntoHexString 0 => \"0\"\n\ntoHexString 16 => \"10\"\n\ntoHexString 250 => \"FA\"\n",
  "lib.toInt": "\nParse a string as an int. Does not support parsing of integers with preceding zero due to\nambiguity between zero-padded and octal numbers. See toIntBase10.\n\n# Inputs\n\n`str`\n: A string to be interpreted as an int.\n\n# Type\n\n```\ntoInt :: string -> int\n```\n\n# Examples\n:::{.example}\n## `lib.strings.toInt` usage example\n\n```nix\ntoInt \"1337\"\n=> 1337\n\ntoInt \"-4\"\n=> -4\n\ntoInt \" 123 \"\n=> 123\n\ntoInt \"00024\"\n=> error: Ambiguity in interpretation of 00024 between octal and zero padded integer.\n\ntoInt \"3.14\"\n=> error: floating point JSON numbers are not supported\n```\n\n:::\n",
  "lib.toIntBase10": "\nParse a string as a base 10 int. This supports parsing of zero-padded integers.\n\n# Inputs\n\n`str`\n: A string to be interpreted as an int.\n\n# Type\n\n```\ntoIntBase10 :: string -> int\n```\n\n# Examples\n:::{.example}\n## `lib.strings.toIntBase10` usage example\n\n```nix\ntoIntBase10 \"1337\"\n=> 1337\n\ntoIntBase10 \"-4\"\n=> -4\n\ntoIntBase10 \" 123 \"\n=> 123\n\ntoIntBase10 \"00024\"\n=> 24\n\ntoIntBase10 \"3.14\"\n=> error: floating point JSON numbers are not supported\n```\n\n:::\n",
  "lib.toList": "\nIf argument is a list, return it; else, wrap it in a singleton\nlist. If you're using this, you should almost certainly\nreconsider if there isn't a more \"well-typed\" approach.\n\n# Inputs\n\n`x`\n\n: 1\\. Function argument\n\n# Examples\n:::{.example}\n## `lib.lists.toList` usage example\n\n```nix\ntoList [ 1 2 ]\n=> [ 1 2 ]\ntoList \"hi\"\n=> [ \"hi \"]\n```\n\n:::\n",
  "lib.toLower": "\nConverts an ASCII string `s` to lower-case.\n\n# Inputs\n\n`s`\n: The string to convert to lower-case.\n\n# Type\n\n```\ntoLower :: string -> string\n```\n\n# Examples\n:::{.example}\n## `lib.strings.toLower` usage example\n\n```nix\ntoLower \"HOME\"\n=> \"home\"\n```\n\n:::\n",
  "lib.toSentenceCase": "\nConverts the first character of a string `s` to upper-case.\n\n# Inputs\n\n`str`\n: The string to convert to sentence case.\n\n# Type\n\n```\ntoSentenceCase :: string -> string\n```\n\n# Examples\n:::{.example}\n## `lib.strings.toSentenceCase` usage example\n\n```nix\ntoSentenceCase \"home\"\n=> \"Home\"\n```\n\n:::\n",
  "lib.toShellVar": "\nTranslate a Nix value into a shell variable declaration, with proper escaping.\n\nThe value can be a string (mapped to a regular variable), a list of strings\n(mapped to a Bash-style array) or an attribute set of strings (mapped to a\nBash-style associative array). Note that \"string\" includes string-coercible\nvalues like paths or derivations.\n\nStrings are translated into POSIX sh-compatible code; lists and attribute sets\nassume a shell that understands Bash syntax (e.g. Bash or ZSH).\n\n\n# Inputs\n\n`name`\n: 1\\. Function argument\n\n`value`\n: 2\\. Function argument\n\n# Type\n\n```\nstring -> ( string | [string] | { ${name} :: string; } ) -> string\n```\n\n# Examples\n:::{.example}\n## `lib.strings.toShellVar` usage example\n\n```nix\n''\n  ${toShellVar \"foo\" \"some string\"}\n  [[ \"$foo\" == \"some string\" ]]\n''\n```\n\n:::\n",
  "lib.toShellVars": "\nTranslate an attribute set `vars` into corresponding shell variable declarations\nusing `toShellVar`.\n\n\n# Inputs\n\n`vars`\n: 1\\. Function argument\n\n# Type\n\n```\ntoShellVars :: {\n  ${name} :: string | [ string ] | { ${key} :: string; };\n} -> string\n```\n\n# Examples\n:::{.example}\n## `lib.strings.toShellVars` usage example\n\n```nix\nlet\n  foo = \"value\";\n  bar = foo;\nin ''\n  ${toShellVars { inherit foo bar; }}\n  [[ \"$foo\" == \"$bar\" ]]\n''\n```\n\n:::\n",
  "lib.toUpper": "\nConverts an ASCII string `s` to upper-case.\n\n# Inputs\n\n`s`\n: The string to convert to upper-case.\n\n\n# Type\n\n```\ntoUpper :: string -> string\n```\n\n# Examples\n:::{.example}\n## `lib.strings.toUpper` usage example\n\n```nix\ntoUpper \"home\"\n=> \"HOME\"\n```\n\n:::\n",
  "lib.toposort": "\nSort a list based on a partial ordering using DFS. This\nimplementation is O(N^2), if your ordering is linear, use `sort`\ninstead.\n\n`before a b == true` means that `b` should be after `a`\nin the result.\n\n\n# Inputs\n\n`before`\n\n: 1\\. Function argument\n\n`list`\n\n: 2\\. Function argument\n\n\n# Examples\n:::{.example}\n## `lib.lists.toposort` usage example\n\n```nix\ntoposort hasPrefix [ \"/home/user\" \"other\" \"/\" \"/home\" ]\n  == { result = [ \"/\" \"/home\" \"/home/user\" \"other\" ]; }\n\ntoposort hasPrefix [ \"/home/user\" \"other\" \"/\" \"/home\" \"/\" ]\n  == { cycle = [ \"/home/user\" \"/\" \"/\" ]; # path leading to a cycle\n       loops = [ \"/\" ]; }                # loops back to these elements\n\ntoposort hasPrefix [ \"other\" \"/home/user\" \"/home\" \"/\" ]\n  == { result = [ \"other\" \"/\" \"/home\" \"/home/user\" ]; }\n\ntoposort (a: b: a < b) [ 3 2 1 ] == { result = [ 1 2 3 ]; }\n```\n\n:::\n",
  "lib.trace": "\nEvaluate *e1* and print its abstract syntax representation on\nstandard error. Then return *e2*. This function is useful for\ndebugging.\n\nIf the\n[`debugger-on-trace`](@docroot@/command-ref/conf-file.md#conf-debugger-on-trace)\noption is set to `true` and the `--debugger` flag is given, the\ninteractive debugger will be started when `trace` is called (like\n[`break`](@docroot@/language/builtins.md#builtins-break)).\n",
  "lib.traceFnSeqN": "\nTrace the input and output of a function `f` named `name`,\nboth down to `depth`.\n\nThis is useful for adding around a function call,\nto see the before/after of values as they are transformed.\n\n# Inputs\n\n`depth`\n\n: 1\\. Function argument\n\n`name`\n\n: 2\\. Function argument\n\n`f`\n\n: 3\\. Function argument\n\n`v`\n\n: 4\\. Function argument\n\n# Examples\n:::{.example}\n## `lib.debug.traceFnSeqN` usage example\n\n```nix\ntraceFnSeqN 2 \"id\" (x: x) { a.b.c = 3; }\ntrace: { fn = \"id\"; from = { a.b = {…}; }; to = { a.b = {…}; }; }\n=> { a.b.c = 3; }\n```\n\n:::\n",
  "lib.traceIf": "\nConditionally trace the supplied message, based on a predicate.\n\n# Inputs\n\n`pred`\n\n: Predicate to check\n\n`msg`\n\n: Message that should be traced\n\n`x`\n\n: Value to return\n\n# Type\n\n```\ntraceIf :: bool -> string -> a -> a\n```\n\n# Examples\n:::{.example}\n## `lib.debug.traceIf` usage example\n\n```nix\ntraceIf true \"hello\" 3\ntrace: hello\n=> 3\n```\n\n:::\n",
  "lib.traceSeq": "\n`builtins.trace`, but the value is `builtins.deepSeq`ed first.\n\n# Inputs\n\n`x`\n\n: The value to trace\n\n`y`\n\n: The value to return\n\n# Type\n\n```\ntraceSeq :: a -> b -> b\n```\n\n# Examples\n:::{.example}\n## `lib.debug.traceSeq` usage example\n\n```nix\ntrace { a.b.c = 3; } null\ntrace: { a = <CODE>; }\n=> null\ntraceSeq { a.b.c = 3; } null\ntrace: { a = { b = { c = 3; }; }; }\n=> null\n```\n\n:::\n",
  "lib.traceSeqN": "\nLike `traceSeq`, but only evaluate down to depth n.\nThis is very useful because lots of `traceSeq` usages\nlead to an infinite recursion.\n\n# Inputs\n\n`depth`\n\n: 1\\. Function argument\n\n`x`\n\n: 2\\. Function argument\n\n`y`\n\n: 3\\. Function argument\n\n# Type\n\n```\ntraceSeqN :: Int -> a -> b -> b\n```\n\n# Examples\n:::{.example}\n## `lib.debug.traceSeqN` usage example\n\n```nix\ntraceSeqN 2 { a.b.c = 3; } null\ntrace: { a = { b = {…}; }; }\n=> null\n```\n\n:::\n",
  "lib.traceVal": "\nTrace the supplied value and return it.\n\n# Inputs\n\n`x`\n\n: Value to trace and return\n\n# Type\n\n```\ntraceVal :: a -> a\n```\n\n# Examples\n:::{.example}\n## `lib.debug.traceVal` usage example\n\n```nix\ntraceVal 42\n# trace: 42\n=> 42\n```\n\n:::\n",
  "lib.traceValFn": "\nTrace the supplied value after applying a function to it, and\nreturn the original value.\n\n# Inputs\n\n`f`\n\n: Function to apply\n\n`x`\n\n: Value to trace and return\n\n# Type\n\n```\ntraceValFn :: (a -> b) -> a -> a\n```\n\n# Examples\n:::{.example}\n## `lib.debug.traceValFn` usage example\n\n```nix\ntraceValFn (v: \"mystring ${v}\") \"foo\"\ntrace: mystring foo\n=> \"foo\"\n```\n\n:::\n",
  "lib.traceValSeq": "\nA combination of `traceVal` and `traceSeq`.\n\n# Inputs\n\n`v`\n\n: Value to trace\n",
  "lib.traceValSeqFn": "\nA combination of `traceVal` and `traceSeq` that applies a\nprovided function to the value to be traced after `deepSeq`ing\nit.\n\n# Inputs\n\n`f`\n\n: Function to apply\n\n`v`\n\n: Value to trace\n",
  "lib.traceValSeqN": "\nA combination of `traceVal` and `traceSeqN`.\n\n# Inputs\n\n`depth`\n\n: 1\\. Function argument\n\n`v`\n\n: Value to trace\n",
  "lib.traceValSeqNFn": "\nA combination of `traceVal` and `traceSeqN` that applies a\nprovided function to the value to be traced.\n\n# Inputs\n\n`f`\n\n: Function to apply\n\n`depth`\n\n: 2\\. Function argument\n\n`v`\n\n: Value to trace\n",
  "lib.trim": "\nRemove leading and trailing whitespace from a string `s`.\n\nWhitespace is defined as any of the following characters:\n  \" \", \"\\t\" \"\\r\" \"\\n\"\n\n# Inputs\n\n`s`\n: The string to trim\n\n# Type\n\n```\ntrim :: string -> string\n```\n\n# Examples\n:::{.example}\n## `lib.strings.trim` usage example\n\n```nix\ntrim \"   hello, world!   \"\n=> \"hello, world!\"\n```\n\n:::\n",
  "lib.trimWith": "\nRemove leading and/or trailing whitespace from a string `s`.\n\nTo remove both leading and trailing whitespace, you can also use [`trim`](#function-library-lib.strings.trim)\n\nWhitespace is defined as any of the following characters:\n  \" \", \"\\t\" \"\\r\" \"\\n\"\n\n# Inputs\n\n`config` (Attribute set)\n: `start`\n  : Whether to trim leading whitespace (`false` by default)\n\n: `end`\n  : Whether to trim trailing whitespace (`false` by default)\n\n`s`\n: The string to trim\n\n# Type\n\n```\ntrimWith :: { start :: Bool; end :: Bool } -> String -> String\n```\n\n# Examples\n:::{.example}\n## `lib.strings.trimWith` usage example\n\n```nix\ntrimWith { start = true; } \"   hello, world!   \"}\n=> \"hello, world!   \"\n\ntrimWith { end = true; } \"   hello, world!   \"}\n=> \"   hello, world!\"\n```\n:::\n",
  "lib.typeOf": "\nReturn a string representing the type of the value *e*, namely\n`\"int\"`, `\"bool\"`, `\"string\"`, `\"path\"`, `\"null\"`, `\"set\"`,\n`\"list\"`, `\"lambda\"` or `\"float\"`.\n",
  "lib.unifyModuleSyntax": "\nMassage a module into canonical form, that is, a set consisting\nof ‘options’, ‘config’ and ‘imports’ attributes.\n\n\n# Inputs\n\n`file`\n\n: 1\\. Function argument\n\n`key`\n\n: 2\\. Function argument\n\n`m`\n\n: 3\\. Function argument\n",
  "lib.uniqList": "This function has O(n^2) performance.",
  "lib.uniqListExt": null,
  "lib.unique": "\nRemove duplicate elements from the `list`. O(n^2) complexity.\n\n\n# Inputs\n\n`list`\n\n: Input list\n\n# Type\n\n```\nunique :: [a] -> [a]\n```\n\n# Examples\n:::{.example}\n## `lib.lists.unique` usage example\n\n```nix\nunique [ 3 2 3 4 ]\n=> [ 3 2 4 ]\n```\n\n:::\n",
  "lib.unsafeGetAttrPos": null,
  "lib.updateManyAttrsByPath": "\nUpdate or set specific paths of an attribute set.\n\nTakes a list of updates to apply and an attribute set to apply them to,\nand returns the attribute set with the updates applied. Updates are\nrepresented as `{ path = ...; update = ...; }` values, where `path` is a\nlist of strings representing the attribute path that should be updated,\nand `update` is a function that takes the old value at that attribute path\nas an argument and returns the new\nvalue it should be.\n\nProperties:\n\n- Updates to deeper attribute paths are applied before updates to more\n  shallow attribute paths\n\n- Multiple updates to the same attribute path are applied in the order\n  they appear in the update list\n\n- If any but the last `path` element leads into a value that is not an\n  attribute set, an error is thrown\n\n- If there is an update for an attribute path that doesn't exist,\n  accessing the argument in the update function causes an error, but\n  intermediate attribute sets are implicitly created as needed\n\n# Type\n\n```\nupdateManyAttrsByPath :: [{ path :: [String]; update :: (Any -> Any); }] -> AttrSet -> AttrSet\n```\n\n# Examples\n:::{.example}\n## `lib.attrsets.updateManyAttrsByPath` usage example\n\n```nix\nupdateManyAttrsByPath [\n  {\n    path = [ \"a\" \"b\" ];\n    update = old: { d = old.c; };\n  }\n  {\n    path = [ \"a\" \"b\" \"c\" ];\n    update = old: old + 1;\n  }\n  {\n    path = [ \"x\" \"y\" ];\n    update = old: \"xy\";\n  }\n] { a.b.c = 0; }\n=> { a = { b = { d = 1; }; }; x = { y = \"xy\"; }; }\n```\n\n:::\n",
  "lib.updateName": "\nLike `setName`, but takes the previous name as an argument.\n\n# Inputs\n\n`updater`\n\n: 1\\. Function argument\n\n`drv`\n\n: 2\\. Function argument\n\n\n# Examples\n:::{.example}\n## `lib.meta.updateName` usage example\n\n```nix\nupdateName (oldName: oldName + \"-experimental\") somePkg\n```\n\n:::\n",
  "lib.versionAtLeast": "\nReturn true if string v1 denotes a version equal to or newer than v2.\n\n\n# Inputs\n\n`v1`\n: 1\\. Function argument\n\n`v2`\n: 2\\. Function argument\n\n# Type\n\n```\nversionAtLeast :: String -> String -> Bool\n```\n\n# Examples\n:::{.example}\n## `lib.strings.versionAtLeast` usage example\n\n```nix\nversionAtLeast \"1.1\" \"1.0\"\n=> true\nversionAtLeast \"1.1\" \"1.1\"\n=> true\nversionAtLeast \"1.1\" \"1.2\"\n=> false\n```\n\n:::\n",
  "lib.versionOlder": "\nReturn true if string `v1` denotes a version older than `v2`.\n\n\n# Inputs\n\n`v1`\n: 1\\. Function argument\n\n`v2`\n: 2\\. Function argument\n\n# Type\n\n```\nversionOlder :: String -> String -> Bool\n```\n\n# Examples\n:::{.example}\n## `lib.strings.versionOlder` usage example\n\n```nix\nversionOlder \"1.1\" \"1.2\"\n=> true\nversionOlder \"1.1\" \"1.1\"\n=> false\n```\n\n:::\n",
  "lib.warn": "\n\n`warn` *`message`* *`value`*\n\nPrint a warning before returning the second argument.\n\nSee [`builtins.warn`](https://nix.dev/manual/nix/latest/language/builtins.html#builtins-warn) (Nix >= 2.23).\nOn older versions, the Nix 2.23 behavior is emulated with [`builtins.trace`](https://nix.dev/manual/nix/latest/language/builtins.html#builtins-warn), including the [`NIX_ABORT_ON_WARN`](https://nix.dev/manual/nix/latest/command-ref/conf-file#conf-abort-on-warn) behavior, but not the `nix.conf` setting or command line option.\n\n# Inputs\n\n*`message`* (String)\n\n: Warning message to print before evaluating *`value`*.\n\n*`value`* (any value)\n\n: Value to return as-is.\n\n# Type\n\n```\nString -> a -> a\n```\n",
  "lib.warnIf": "\n\n`warnIf` *`condition`* *`message`* *`value`*\n\nLike `warn`, but only warn when the first argument is `true`.\n\n# Inputs\n\n*`condition`* (Boolean)\n\n: `true` to trigger the warning before continuing with *`value`*.\n\n*`message`* (String)\n\n: Warning message to print before evaluating\n\n*`value`* (any value)\n\n: Value to return as-is.\n\n# Type\n\n```\nBool -> String -> a -> a\n```\n",
  "lib.warnIfNot": "\n\n`warnIfNot` *`condition`* *`message`* *`value`*\n\nLike `warnIf`, but negated: warn if the first argument is `false`.\n\n# Inputs\n\n*`condition`*\n\n: `false` to trigger the warning before continuing with `val`.\n\n*`message`*\n\n: Warning message to print before evaluating *`value`*.\n\n*`value`*\n\n: Value to return as-is.\n\n# Type\n\n```\nBoolean -> String -> a -> a\n```\n",
  "lib.warnOnInstantiate": "\nWrap a derivation such that instantiating it produces a warning.\n\nAll attributes apart from `meta`, `name`, and `type` (which are used by\n`nix search`) will be wrapped in `lib.warn`.\n\n# Inputs\n\n`msg`\n: The warning message to emit (via `lib.warn`).\n\n`drv`\n: The derivation to wrap.\n\n# Examples\n:::{.example}\n## `lib.derivations.warnOnInstantiate` usage example\n\n```nix\n{\n  myPackage = warnOnInstantiate \"myPackage has been renamed to my-package\" my-package;\n}\n```\n\n:::\n",
  "lib.withFeature": "\nCreate an --{with,without}-<feature> string that can be passed to\nstandard GNU Autoconf scripts.\n\n\n# Inputs\n\n`flag`\n: 1\\. Function argument\n\n`feature`\n: 2\\. Function argument\n\n\n# Type\n\n```\nwithFeature :: bool -> string -> string\n```\n\n# Examples\n:::{.example}\n## `lib.strings.withFeature` usage example\n\n```nix\nwithFeature true \"shared\"\n=> \"--with-shared\"\nwithFeature false \"shared\"\n=> \"--without-shared\"\n```\n\n:::\n",
  "lib.withFeatureAs": "\nCreate an --{with-<feature>=<value>,without-<feature>} string that can be passed to\nstandard GNU Autoconf scripts.\n\n\n# Inputs\n\n`flag`\n: 1\\. Function argument\n\n`feature`\n: 2\\. Function argument\n\n`value`\n: 3\\. Function argument\n\n# Type\n\n```\nwithFeatureAs :: bool -> string -> string -> string\n```\n\n\n# Examples\n:::{.example}\n## `lib.strings.withFeatureAs` usage example\n\n```nix\nwithFeatureAs true \"shared\" \"foo\"\n=> \"--with-shared=foo\"\nwithFeatureAs false \"shared\" (throw \"ignored\")\n=> \"--without-shared\"\n```\n\n:::\n",
  "lib.xor": "\nboolean “exclusive or”\n\n\n# Inputs\n\n`x`\n\n: 1\\. Function argument\n\n`y`\n\n: 2\\. Function argument\n",
  "lib.zip": "\nMerge sets of attributes and use the function f to merge attribute values.\nLike `lib.attrsets.zipAttrsWithNames` with all key names are passed for `names`.\n\nImplementation note: Common names appear multiple times in the list of\nnames, hopefully this does not affect the system because the maximal\nlaziness avoid computing twice the same expression and `listToAttrs` does\nnot care about duplicated attribute names.\n\n# Type\n\n```\nzipAttrsWith :: (String -> [ Any ] -> Any) -> [ AttrSet ] -> AttrSet\n```\n\n# Examples\n:::{.example}\n## `lib.attrsets.zipAttrsWith` usage example\n\n```nix\nzipAttrsWith (name: values: values) [{a = \"x\";} {a = \"y\"; b = \"z\";}]\n=> { a = [\"x\" \"y\"]; b = [\"z\"]; }\n```\n\n:::\n",
  "lib.zipAttrs": "\nMerge sets of attributes and combine each attribute value in to a list.\n\nLike `lib.attrsets.zipAttrsWith` with `(name: values: values)` as the function.\n\n# Type\n\n```\nzipAttrs :: [ AttrSet ] -> AttrSet\n```\n\n# Examples\n:::{.example}\n## `lib.attrsets.zipAttrs` usage example\n\n```nix\nzipAttrs [{a = \"x\";} {a = \"y\"; b = \"z\";}]\n=> { a = [\"x\" \"y\"]; b = [\"z\"]; }\n```\n\n:::\n",
  "lib.zipAttrsWith": "\nMerge sets of attributes and use the function f to merge attribute values.\nLike `lib.attrsets.zipAttrsWithNames` with all key names are passed for `names`.\n\nImplementation note: Common names appear multiple times in the list of\nnames, hopefully this does not affect the system because the maximal\nlaziness avoid computing twice the same expression and `listToAttrs` does\nnot care about duplicated attribute names.\n\n# Type\n\n```\nzipAttrsWith :: (String -> [ Any ] -> Any) -> [ AttrSet ] -> AttrSet\n```\n\n# Examples\n:::{.example}\n## `lib.attrsets.zipAttrsWith` usage example\n\n```nix\nzipAttrsWith (name: values: values) [{a = \"x\";} {a = \"y\"; b = \"z\";}]\n=> { a = [\"x\" \"y\"]; b = [\"z\"]; }\n```\n\n:::\n",
  "lib.zipAttrsWithNames": "\nMerge sets of attributes and use the function `f` to merge attributes\nvalues.\n\n\n# Inputs\n\n`names`\n\n: List of attribute names to zip.\n\n`f`\n\n: A function, accepts an attribute name, all the values, and returns a combined value.\n\n`sets`\n\n: List of values from the list of attribute sets.\n\n# Type\n\n```\nzipAttrsWithNames :: [ String ] -> (String -> [ Any ] -> Any) -> [ AttrSet ] -> AttrSet\n```\n\n# Examples\n:::{.example}\n## `lib.attrsets.zipAttrsWithNames` usage example\n\n```nix\nzipAttrsWithNames [\"a\"] (name: vs: vs) [{a = \"x\";} {a = \"y\"; b = \"z\";}]\n=> { a = [\"x\" \"y\"]; }\n```\n\n:::\n",
  "lib.zipLists": "\nMerges two lists of the same size together. If the sizes aren't the same\nthe merging stops at the shortest.\n\n# Inputs\n\n`fst`\n\n: First list\n\n`snd`\n\n: Second list\n\n# Type\n\n```\nzipLists :: [a] -> [b] -> [{ fst :: a; snd :: b; }]\n```\n\n# Examples\n:::{.example}\n## `lib.lists.zipLists` usage example\n\n```nix\nzipLists [ 1 2 ] [ \"a\" \"b\" ]\n=> [ { fst = 1; snd = \"a\"; } { fst = 2; snd = \"b\"; } ]\n```\n\n:::\n",
  "lib.zipListsWith": "\nMerges two lists of the same size together. If the sizes aren't the same\nthe merging stops at the shortest. How both lists are merged is defined\nby the first argument.\n\n# Inputs\n\n`f`\n\n: Function to zip elements of both lists\n\n`fst`\n\n: First list\n\n`snd`\n\n: Second list\n\n# Type\n\n```\nzipListsWith :: (a -> b -> c) -> [a] -> [b] -> [c]\n```\n\n# Examples\n:::{.example}\n## `lib.lists.zipListsWith` usage example\n\n```nix\nzipListsWith (a: b: a + b) [\"h\" \"l\"] [\"e\" \"o\"]\n=> [\"he\" \"lo\"]\n```\n\n:::\n",
  "lib.zipWithNames": "\nMerge sets of attributes and use the function `f` to merge attributes\nvalues.\n\n\n# Inputs\n\n`names`\n\n: List of attribute names to zip.\n\n`f`\n\n: A function, accepts an attribute name, all the values, and returns a combined value.\n\n`sets`\n\n: List of values from the list of attribute sets.\n\n# Type\n\n```\nzipAttrsWithNames :: [ String ] -> (String -> [ Any ] -> Any) -> [ AttrSet ] -> AttrSet\n```\n\n# Examples\n:::{.example}\n## `lib.attrsets.zipAttrsWithNames` usage example\n\n```nix\nzipAttrsWithNames [\"a\"] (name: vs: vs) [{a = \"x\";} {a = \"y\"; b = \"z\";}]\n=> { a = [\"x\" \"y\"]; }\n```\n\n:::\n",
  "lib.asserts.assertEachOneOf": "\nSpecialized `assertMsg` for checking if every one of `vals` is one of the elements\nof the list `xs`. Useful for checking lists of supported attributes.\n\n# Inputs\n\n`name`\n\n: The name of the variable the user entered `val` into, for inclusion in the error message\n\n`vals`\n\n: The list of values of what the user provided, to be compared against the values in `xs`\n\n`xs`\n\n: The list of valid values\n\n# Type\n\n```\nassertEachOneOf :: String -> List ComparableVal -> List ComparableVal -> Bool\n```\n\n# Examples\n:::{.example}\n## `lib.asserts.assertEachOneOf` usage example\n\n```nix\nlet sslLibraries = [ \"libressl\" \"bearssl\" ];\nin assertEachOneOf \"sslLibraries\" sslLibraries [ \"openssl\" \"bearssl\" ]\nstderr> error: each element in sslLibraries must be one of [\nstderr>   \"openssl\"\nstderr>   \"bearssl\"\nstderr> ], but is: [\nstderr>   \"libressl\"\nstderr>   \"bearssl\"\nstderr> ]\n```\n\n:::\n",
  "lib.asserts.assertMsg": "\nThrow if pred is false, else return pred.\nIntended to be used to augment asserts with helpful error messages.\n\n# Inputs\n\n`pred`\n\n: Predicate that needs to succeed, otherwise `msg` is thrown\n\n`msg`\n\n: Message to throw in case `pred` fails\n\n# Type\n\n```\nassertMsg :: Bool -> String -> Bool\n```\n\n# Examples\n:::{.example}\n## `lib.asserts.assertMsg` usage example\n\n```nix\nassertMsg false \"nope\"\nstderr> error: nope\nassert assertMsg (\"foo\" == \"bar\") \"foo is not bar, silly\"; \"\"\nstderr> error: foo is not bar, silly\n```\n\n:::\n",
  "lib.asserts.assertOneOf": "\nSpecialized `assertMsg` for checking if `val` is one of the elements\nof the list `xs`. Useful for checking enums.\n\n# Inputs\n\n`name`\n\n: The name of the variable the user entered `val` into, for inclusion in the error message\n\n`val`\n\n: The value of what the user provided, to be compared against the values in `xs`\n\n`xs`\n\n: The list of valid values\n\n# Type\n\n```\nassertOneOf :: String -> ComparableVal -> List ComparableVal -> Bool\n```\n\n# Examples\n:::{.example}\n## `lib.asserts.assertOneOf` usage example\n\n```nix\nlet sslLibrary = \"libressl\";\nin assertOneOf \"sslLibrary\" sslLibrary [ \"openssl\" \"bearssl\" ]\nstderr> error: sslLibrary must be one of [\nstderr>   \"openssl\"\nstderr>   \"bearssl\"\nstderr> ], but is: \"libressl\"\n```\n\n:::\n",
  "lib.attrsets.attrByPath": "\nReturn an attribute from nested attribute sets.\n\nNix has an [attribute selection operator `.`](https://nixos.org/manual/nix/stable/language/operators#attribute-selection) which is sufficient for such queries, as long as the number of attributes is static. For example:\n\n```nix\n(x.a.b or 6) == attrByPath [\"a\" \"b\"] 6 x\n# and\n(x.${f p}.\"example.com\" or 6) == attrByPath [ (f p) \"example.com\" ] 6 x\n```\n\n\n# Inputs\n\n`attrPath`\n\n: A list of strings representing the attribute path to return from `set`\n\n`default`\n\n: Default value if `attrPath` does not resolve to an existing value\n\n`set`\n\n: The nested attribute set to select values from\n\n# Type\n\n```\nattrByPath :: [String] -> Any -> AttrSet -> Any\n```\n\n# Examples\n:::{.example}\n## `lib.attrsets.attrByPath` usage example\n\n```nix\nx = { a = { b = 3; }; }\n# [\"a\" \"b\"] is equivalent to x.a.b\n# 6 is a default value to return if the path does not exist in attrset\nattrByPath [\"a\" \"b\"] 6 x\n=> 3\nattrByPath [\"z\" \"z\"] 6 x\n=> 6\n```\n\n:::\n",
  "lib.attrsets.attrNames": "\nReturn the names of the attributes in the set *set* in an\nalphabetically sorted list. For instance, `builtins.attrNames { y\n= 1; x = \"foo\"; }` evaluates to `[ \"x\" \"y\" ]`.\n",
  "lib.attrsets.attrVals": "\nReturn the specified attributes from a set.\n\n\n# Inputs\n\n`nameList`\n\n: The list of attributes to fetch from `set`. Each attribute name must exist on the attrbitue set\n\n`set`\n\n: The set to get attribute values from\n\n# Type\n\n```\nattrVals :: [String] -> AttrSet -> [Any]\n```\n\n# Examples\n:::{.example}\n## `lib.attrsets.attrVals` usage example\n\n```nix\nattrVals [\"a\" \"b\" \"c\"] as\n=> [as.a as.b as.c]\n```\n\n:::\n",
  "lib.attrsets.attrValues": "\nReturn the values of all attributes in the given set, sorted by\nattribute name.\n\n# Type\n\n```\nattrValues :: AttrSet -> [Any]\n```\n\n# Examples\n:::{.example}\n## `lib.attrsets.attrValues` usage example\n\n```nix\nattrValues {c = 3; a = 1; b = 2;}\n=> [1 2 3]\n```\n\n:::\n",
  "lib.attrsets.attrsToList": "\nDeconstruct an attrset to a list of name-value pairs as expected by [`builtins.listToAttrs`](https://nixos.org/manual/nix/stable/language/builtins.html#builtins-listToAttrs).\nEach element of the resulting list is an attribute set with these attributes:\n- `name` (string): The name of the attribute\n- `value` (any): The value of the attribute\n\nThe following is always true:\n```nix\nbuiltins.listToAttrs (attrsToList attrs) == attrs\n```\n\n:::{.warning}\nThe opposite is not always true. In general expect that\n```nix\nattrsToList (builtins.listToAttrs list) != list\n```\n\nThis is because the `listToAttrs` removes duplicate names and doesn't preserve the order of the list.\n:::\n\n# Inputs\n\n`set`\n\n: The attribute set to deconstruct.\n\n# Type\n\n```\nattrsToList :: AttrSet -> [ { name :: String; value :: Any; } ]\n```\n\n# Examples\n:::{.example}\n## `lib.attrsets.attrsToList` usage example\n\n```nix\nattrsToList { foo = 1; bar = \"asdf\"; }\n=> [ { name = \"bar\"; value = \"asdf\"; } { name = \"foo\"; value = 1; } ]\n```\n\n:::\n",
  "lib.attrsets.cartesianProduct": "\nReturn the cartesian product of attribute set value combinations.\n\n\n# Inputs\n\n`attrsOfLists`\n\n: Attribute set with attributes that are lists of values\n\n# Type\n\n```\ncartesianProduct :: AttrSet -> [AttrSet]\n```\n\n# Examples\n:::{.example}\n## `lib.attrsets.cartesianProduct` usage example\n\n```nix\ncartesianProduct { a = [ 1 2 ]; b = [ 10 20 ]; }\n=> [\n     { a = 1; b = 10; }\n     { a = 1; b = 20; }\n     { a = 2; b = 10; }\n     { a = 2; b = 20; }\n   ]\n```\n\n:::\n",
  "lib.attrsets.cartesianProductOfSets": "\nReturn the cartesian product of attribute set value combinations.\n\n\n# Inputs\n\n`attrsOfLists`\n\n: Attribute set with attributes that are lists of values\n\n# Type\n\n```\ncartesianProduct :: AttrSet -> [AttrSet]\n```\n\n# Examples\n:::{.example}\n## `lib.attrsets.cartesianProduct` usage example\n\n```nix\ncartesianProduct { a = [ 1 2 ]; b = [ 10 20 ]; }\n=> [\n     { a = 1; b = 10; }\n     { a = 1; b = 20; }\n     { a = 2; b = 10; }\n     { a = 2; b = 20; }\n   ]\n```\n\n:::\n",
  "lib.attrsets.catAttrs": "\nCollect each attribute named `attr` from a list of attribute\nsets.  Sets that don't contain the named attribute are ignored.\n\n# Inputs\n\n`attr`\n\n: The attribute name to get out of the sets.\n\n`list`\n\n: The list of attribute sets to go through\n\n# Type\n\n```\ncatAttrs :: String -> [AttrSet] -> [Any]\n```\n\n# Examples\n:::{.example}\n## `lib.attrsets.catAttrs` usage example\n\n```nix\ncatAttrs \"a\" [{a = 1;} {b = 0;} {a = 2;}]\n=> [1 2]\n```\n\n:::\n",
  "lib.attrsets.chooseDevOutputs": "\nPick the outputs of packages to place in `buildInputs`\n\n# Inputs\n\n`pkgs`\n\n: List of packages.\n\n# Type\n\n```\nchooseDevOutputs :: [Derivation] -> [Derivation]\n```\n",
  "lib.attrsets.collect": "\nRecursively collect sets that verify a given predicate named `pred`\nfrom the set `attrs`. The recursion is stopped when the predicate is\nverified.\n\n\n# Inputs\n\n`pred`\n\n: Given an attribute's value, determine if recursion should stop.\n\n`attrs`\n\n: The attribute set to recursively collect.\n\n# Type\n\n```\ncollect :: (AttrSet -> Bool) -> AttrSet -> [x]\n```\n\n# Examples\n:::{.example}\n## `lib.attrsets.collect` usage example\n\n```nix\ncollect isList { a = { b = [\"b\"]; }; c = [1]; }\n=> [[\"b\"] [1]]\n\ncollect (x: x ? outPath)\n   { a = { outPath = \"a/\"; }; b = { outPath = \"b/\"; }; }\n=> [{ outPath = \"a/\"; } { outPath = \"b/\"; }]\n```\n\n:::\n",
  "lib.attrsets.concatMapAttrs": "\nMap each attribute in the given set and merge them into a new attribute set.\n\n\n# Inputs\n\n`f`\n\n: 1\\. Function argument\n\n`v`\n\n: 2\\. Function argument\n\n# Type\n\n```\nconcatMapAttrs :: (String -> a -> AttrSet) -> AttrSet -> AttrSet\n```\n\n# Examples\n:::{.example}\n## `lib.attrsets.concatMapAttrs` usage example\n\n```nix\nconcatMapAttrs\n  (name: value: {\n    ${name} = value;\n    ${name + value} = value;\n  })\n  { x = \"a\"; y = \"b\"; }\n=> { x = \"a\"; xa = \"a\"; y = \"b\"; yb = \"b\"; }\n```\n\n:::\n",
  "lib.attrsets.dontRecurseIntoAttrs": "\nUndo the effect of recurseIntoAttrs.\n\n\n# Inputs\n\n`attrs`\n\n: An attribute set to not scan for derivations.\n\n# Type\n\n```\ndontRecurseIntoAttrs :: AttrSet -> AttrSet\n```\n",
  "lib.attrsets.filterAttrs": "\nFilter an attribute set by removing all attributes for which the\ngiven predicate return false.\n\n\n# Inputs\n\n`pred`\n\n: Predicate taking an attribute name and an attribute value, which returns `true` to include the attribute, or `false` to exclude the attribute.\n\n`set`\n\n: The attribute set to filter\n\n# Type\n\n```\nfilterAttrs :: (String -> Any -> Bool) -> AttrSet -> AttrSet\n```\n\n# Examples\n:::{.example}\n## `lib.attrsets.filterAttrs` usage example\n\n```nix\nfilterAttrs (n: v: n == \"foo\") { foo = 1; bar = 2; }\n=> { foo = 1; }\n```\n\n:::\n",
  "lib.attrsets.filterAttrsRecursive": "\nFilter an attribute set recursively by removing all attributes for\nwhich the given predicate return false.\n\n\n# Inputs\n\n`pred`\n\n: Predicate taking an attribute name and an attribute value, which returns `true` to include the attribute, or `false` to exclude the attribute.\n\n`set`\n\n: The attribute set to filter\n\n# Type\n\n```\nfilterAttrsRecursive :: (String -> Any -> Bool) -> AttrSet -> AttrSet\n```\n\n# Examples\n:::{.example}\n## `lib.attrsets.filterAttrsRecursive` usage example\n\n```nix\nfilterAttrsRecursive (n: v: v != null) { foo = { bar = null; }; }\n=> { foo = {}; }\n```\n\n:::\n",
  "lib.attrsets.foldAttrs": "\nApply fold functions to values grouped by key.\n\n\n# Inputs\n\n`op`\n\n: A function, given a value and a collector combines the two.\n\n`nul`\n\n: The starting value.\n\n`list_of_attrs`\n\n: A list of attribute sets to fold together by key.\n\n# Type\n\n```\nfoldAttrs :: (Any -> Any -> Any) -> Any -> [AttrSets] -> Any\n```\n\n# Examples\n:::{.example}\n## `lib.attrsets.foldAttrs` usage example\n\n```nix\nfoldAttrs (item: acc: [item] ++ acc) [] [{ a = 2; } { a = 3; }]\n=> { a = [ 2 3 ]; }\n```\n\n:::\n",
  "lib.attrsets.foldlAttrs": "\nLike [`lib.lists.foldl'`](#function-library-lib.lists.foldl-prime) but for attribute sets.\nIterates over every name-value pair in the given attribute set.\nThe result of the callback function is often called `acc` for accumulator. It is passed between callbacks from left to right and the final `acc` is the return value of `foldlAttrs`.\n\nAttention:\n\nThere is a completely different function `lib.foldAttrs`\nwhich has nothing to do with this function, despite the similar name.\n\n\n# Inputs\n\n`f`\n\n: 1\\. Function argument\n\n`init`\n\n: 2\\. Function argument\n\n`set`\n\n: 3\\. Function argument\n\n# Type\n\n```\nfoldlAttrs :: ( a -> String -> b -> a ) -> a -> { ... :: b } -> a\n```\n\n# Examples\n:::{.example}\n## `lib.attrsets.foldlAttrs` usage example\n\n```nix\nfoldlAttrs\n  (acc: name: value: {\n    sum = acc.sum + value;\n    names = acc.names ++ [name];\n  })\n  { sum = 0; names = []; }\n  {\n    foo = 1;\n    bar = 10;\n  }\n->\n  {\n    sum = 11;\n    names = [\"bar\" \"foo\"];\n  }\n\nfoldlAttrs\n  (throw \"function not needed\")\n  123\n  {};\n->\n  123\n\nfoldlAttrs\n  (acc: _: _: acc)\n  3\n  { z = throw \"value not needed\"; a = throw \"value not needed\"; };\n->\n  3\n\nThe accumulator doesn't have to be an attrset.\nIt can be as simple as a number or string.\n\nfoldlAttrs\n  (acc: _: v: acc * 10 + v)\n  1\n  { z = 1; a = 2; };\n->\n  121\n```\n\n:::\n",
  "lib.attrsets.genAttrs": "\nGenerate an attribute set by mapping a function over a list of\nattribute names.\n\n\n# Inputs\n\n`names`\n\n: Names of values in the resulting attribute set.\n\n`f`\n\n: A function, given the name of the attribute, returns the attribute's value.\n\n# Type\n\n```\ngenAttrs :: [ String ] -> (String -> Any) -> AttrSet\n```\n\n# Examples\n:::{.example}\n## `lib.attrsets.genAttrs` usage example\n\n```nix\ngenAttrs [ \"foo\" \"bar\" ] (name: \"x_\" + name)\n=> { foo = \"x_foo\"; bar = \"x_bar\"; }\n```\n\n:::\n",
  "lib.attrsets.getAttr": "\n`getAttr` returns the attribute named *s* from *set*. Evaluation\naborts if the attribute doesn’t exist. This is a dynamic version of\nthe `.` operator, since *s* is an expression rather than an\nidentifier.\n",
  "lib.attrsets.getAttrFromPath": "\nLike `attrByPath`, but without a default value. If it doesn't find the\npath it will throw an error.\n\nNix has an [attribute selection operator](https://nixos.org/manual/nix/stable/language/operators#attribute-selection) which is sufficient for such queries, as long as the number of attributes is static. For example:\n\n```nix\nx.a.b == getAttrByPath [\"a\" \"b\"] x\n# and\nx.${f p}.\"example.com\" == getAttrByPath [ (f p) \"example.com\" ] x\n```\n\n\n# Inputs\n\n`attrPath`\n\n: A list of strings representing the attribute path to get from `set`\n\n`set`\n\n: The nested attribute set to find the value in.\n\n# Type\n\n```\ngetAttrFromPath :: [String] -> AttrSet -> Any\n```\n\n# Examples\n:::{.example}\n## `lib.attrsets.getAttrFromPath` usage example\n\n```nix\nx = { a = { b = 3; }; }\ngetAttrFromPath [\"a\" \"b\"] x\n=> 3\ngetAttrFromPath [\"z\" \"z\"] x\n=> error: cannot find attribute `z.z'\n```\n\n:::\n",
  "lib.attrsets.getAttrs": "\nGiven a set of attribute names, return the set of the corresponding\nattributes from the given set.\n\n\n# Inputs\n\n`names`\n\n: A list of attribute names to get out of `set`\n\n`attrs`\n\n: The set to get the named attributes from\n\n# Type\n\n```\ngetAttrs :: [String] -> AttrSet -> AttrSet\n```\n\n# Examples\n:::{.example}\n## `lib.attrsets.getAttrs` usage example\n\n```nix\ngetAttrs [ \"a\" \"b\" ] { a = 1; b = 2; c = 3; }\n=> { a = 1; b = 2; }\n```\n\n:::\n",
  "lib.attrsets.getBin": "\nGet a package's `bin` output.\nIf the output does not exist, fallback to `.out` and then to the default.\n\n# Inputs\n\n`pkg`\n\n: The package whose `bin` output will be retrieved.\n\n# Type\n\n```\ngetBin :: Derivation -> Derivation\n```\n\n# Examples\n:::{.example}\n## `lib.attrsets.getBin` usage example\n\n```nix\n\"${getBin pkgs.openssl}\"\n=> \"/nix/store/00000000000000000000000000000000-openssl-1.0.1r\"\n```\n\n:::\n",
  "lib.attrsets.getDev": "\nGet a package's `dev` output.\nIf the output does not exist, fallback to `.out` and then to the default.\n\n# Inputs\n\n`pkg`\n\n: The package whose `dev` output will be retrieved.\n\n# Type\n\n```\ngetDev :: Derivation -> Derivation\n```\n\n# Examples\n:::{.example}\n## `lib.attrsets.getDev` usage example\n\n```nix\n\"${getDev pkgs.openssl}\"\n=> \"/nix/store/9rz8gxhzf8sw4kf2j2f1grr49w8zx5vj-openssl-1.0.1r-dev\"\n```\n\n:::\n",
  "lib.attrsets.getFirstOutput": "\nGet the first of the `outputs` provided by the package, or the default.\nThis function is alligned with `_overrideFirst()` from the `multiple-outputs.sh` setup hook.\nLike `getOutput`, the function is idempotent.\n\n# Inputs\n\n`outputs`\n\n: 1\\. Function argument\n\n`pkg`\n\n: 2\\. Function argument\n\n# Type\n\n```\ngetFirstOutput :: [String] -> Derivation -> Derivation\n```\n\n# Examples\n:::{.example}\n## `lib.attrsets.getFirstOutput` usage example\n\n```nix\n\"${getFirstOutput [ \"include\" \"dev\" ] pkgs.openssl}\"\n=> \"/nix/store/00000000000000000000000000000000-openssl-1.0.1r-dev\"\n```\n\n:::\n",
  "lib.attrsets.getInclude": "\nGet a package's `include` output.\nIf the output does not exist, fallback to `.dev`, then to `.out`, and then to the default.\n\n# Inputs\n\n`pkg`\n\n: The package whose `include` output will be retrieved.\n\n# Type\n\n```\ngetInclude :: Derivation -> Derivation\n```\n\n# Examples\n:::{.example}\n## `lib.attrsets.getInclude` usage example\n\n```nix\n\"${getInclude pkgs.openssl}\"\n=> \"/nix/store/00000000000000000000000000000000-openssl-1.0.1r-dev\"\n```\n\n:::\n",
  "lib.attrsets.getLib": "\nGet a package's `lib` output.\nIf the output does not exist, fallback to `.out` and then to the default.\n\n# Inputs\n\n`pkg`\n\n: The package whose `lib` output will be retrieved.\n\n# Type\n\n```\ngetLib :: Derivation -> Derivation\n```\n\n# Examples\n:::{.example}\n## `lib.attrsets.getLib` usage example\n\n```nix\n\"${getLib pkgs.openssl}\"\n=> \"/nix/store/9rz8gxhzf8sw4kf2j2f1grr49w8zx5vj-openssl-1.0.1r-lib\"\n```\n\n:::\n",
  "lib.attrsets.getMan": "\nGet a package's `man` output.\nIf the output does not exist, fallback to `.out` and then to the default.\n\n# Inputs\n\n`pkg`\n\n: The package whose `man` output will be retrieved.\n\n# Type\n\n```\ngetMan :: Derivation -> Derivation\n```\n\n# Examples\n:::{.example}\n## `lib.attrsets.getMan` usage example\n\n```nix\n\"${getMan pkgs.openssl}\"\n=> \"/nix/store/9rz8gxhzf8sw4kf2j2f1grr49w8zx5vj-openssl-1.0.1r-man\"\n```\n\n:::\n",
  "lib.attrsets.getOutput": "\nGet a package output.\nIf no output is found, fallback to `.out` and then to the default.\nThe function is idempotent: `getOutput \"b\" (getOutput \"a\" p) == getOutput \"a\" p`.\n\n\n# Inputs\n\n`output`\n\n: 1\\. Function argument\n\n`pkg`\n\n: 2\\. Function argument\n\n# Type\n\n```\ngetOutput :: String -> :: Derivation -> Derivation\n```\n\n# Examples\n:::{.example}\n## `lib.attrsets.getOutput` usage example\n\n```nix\n\"${getOutput \"dev\" pkgs.openssl}\"\n=> \"/nix/store/9rz8gxhzf8sw4kf2j2f1grr49w8zx5vj-openssl-1.0.1r-dev\"\n```\n\n:::\n",
  "lib.attrsets.getStatic": "\nGet a package's `static` output.\nIf the output does not exist, fallback to `.lib`, then to `.out`, and then to the default.\n\n# Inputs\n\n`pkg`\n\n: The package whose `static` output will be retrieved.\n\n# Type\n\n```\ngetStatic :: Derivation -> Derivation\n```\n\n# Examples\n:::{.example}\n## `lib.attrsets.getStatic` usage example\n\n```nix\n\"${lib.getStatic pkgs.glibc}\"\n=> \"/nix/store/00000000000000000000000000000000-glibc-2.39-52-static\"\n```\n\n:::\n",
  "lib.attrsets.hasAttr": "\n`hasAttr` returns `true` if *set* has an attribute named *s*, and\n`false` otherwise. This is a dynamic version of the `?` operator,\nsince *s* is an expression rather than an identifier.\n",
  "lib.attrsets.hasAttrByPath": "\nReturn if an attribute from nested attribute set exists.\n\nNix has a [has attribute operator `?`](https://nixos.org/manual/nix/stable/language/operators#has-attribute), which is sufficient for such queries, as long as the number of attributes is static. For example:\n\n```nix\n(x?a.b) == hasAttrByPath [\"a\" \"b\"] x\n# and\n(x?${f p}.\"example.com\") == hasAttrByPath [ (f p) \"example.com\" ] x\n```\n\n**Laws**:\n 1.  ```nix\n     hasAttrByPath [] x == true\n     ```\n\n\n# Inputs\n\n`attrPath`\n\n: A list of strings representing the attribute path to check from `set`\n\n`e`\n\n: The nested attribute set to check\n\n# Type\n\n```\nhasAttrByPath :: [String] -> AttrSet -> Bool\n```\n\n# Examples\n:::{.example}\n## `lib.attrsets.hasAttrByPath` usage example\n\n```nix\nx = { a = { b = 3; }; }\nhasAttrByPath [\"a\" \"b\"] x\n=> true\nhasAttrByPath [\"z\" \"z\"] x\n=> false\nhasAttrByPath [] (throw \"no need\")\n=> true\n```\n\n:::\n",
  "lib.attrsets.intersectAttrs": "\nReturn a set consisting of the attributes in the set *e2* which have the\nsame name as some attribute in *e1*.\n\nPerforms in O(*n* log *m*) where *n* is the size of the smaller set and *m* the larger set's size.\n",
  "lib.attrsets.isAttrs": "\nReturn `true` if *e* evaluates to a set, and `false` otherwise.\n",
  "lib.attrsets.isDerivation": "\nCheck whether the argument is a derivation. Any set with\n`{ type = \"derivation\"; }` counts as a derivation.\n\n\n# Inputs\n\n`value`\n\n: Value to check.\n\n# Type\n\n```\nisDerivation :: Any -> Bool\n```\n\n# Examples\n:::{.example}\n## `lib.attrsets.isDerivation` usage example\n\n```nix\nnixpkgs = import <nixpkgs> {}\nisDerivation nixpkgs.ruby\n=> true\nisDerivation \"foobar\"\n=> false\n```\n\n:::\n",
  "lib.attrsets.listToAttrs": "\nConstruct a set from a list specifying the names and values of each\nattribute. Each element of the list should be a set consisting of a\nstring-valued attribute `name` specifying the name of the attribute,\nand an attribute `value` specifying its value.\n\nIn case of duplicate occurrences of the same name, the first\ntakes precedence.\n\nExample:\n\n```nix\nbuiltins.listToAttrs\n  [ { name = \"foo\"; value = 123; }\n    { name = \"bar\"; value = 456; }\n    { name = \"bar\"; value = 420; }\n  ]\n```\n\nevaluates to\n\n```nix\n{ foo = 123; bar = 456; }\n```\n",
  "lib.attrsets.longestValidPathPrefix": "\nReturn the longest prefix of an attribute path that refers to an existing attribute in a nesting of attribute sets.\n\nCan be used after [`mapAttrsRecursiveCond`](#function-library-lib.attrsets.mapAttrsRecursiveCond) to apply a condition,\nalthough this will evaluate the predicate function on sibling attributes as well.\n\nNote that the empty attribute path is valid for all values, so this function only throws an exception if any of its inputs does.\n\n**Laws**:\n1.  ```nix\n    attrsets.longestValidPathPrefix [] x == []\n    ```\n\n2.  ```nix\n    hasAttrByPath (attrsets.longestValidPathPrefix p x) x == true\n    ```\n\n\n# Inputs\n\n`attrPath`\n\n: A list of strings representing the longest possible path that may be returned.\n\n`v`\n\n: The nested attribute set to check.\n\n# Type\n\n```\nattrsets.longestValidPathPrefix :: [String] -> Value -> [String]\n```\n\n# Examples\n:::{.example}\n## `lib.attrsets.longestValidPathPrefix` usage example\n\n```nix\nx = { a = { b = 3; }; }\nattrsets.longestValidPathPrefix [\"a\" \"b\" \"c\"] x\n=> [\"a\" \"b\"]\nattrsets.longestValidPathPrefix [\"a\"] x\n=> [\"a\"]\nattrsets.longestValidPathPrefix [\"z\" \"z\"] x\n=> []\nattrsets.longestValidPathPrefix [\"z\" \"z\"] (throw \"no need\")\n=> []\n```\n\n:::\n",
  "lib.attrsets.mapAttrs": "\nApply a function to each element in an attribute set, creating a new attribute set.\n\n# Inputs\n\n`f`\n\n: A function that takes an attribute name and its value, and returns the new value for the attribute.\n\n`attrset`\n\n: The attribute set to iterate through.\n\n# Type\n\n```\nmapAttrs :: (String -> Any -> Any) -> AttrSet -> AttrSet\n```\n\n# Examples\n:::{.example}\n## `lib.attrsets.mapAttrs` usage example\n\n```nix\nmapAttrs (name: value: name + \"-\" + value)\n   { x = \"foo\"; y = \"bar\"; }\n=> { x = \"x-foo\"; y = \"y-bar\"; }\n```\n\n:::\n",
  "lib.attrsets.mapAttrs' (Prime)": "\nLike `mapAttrs`, but allows the name of each attribute to be\nchanged in addition to the value.  The applied function should\nreturn both the new name and value as a `nameValuePair`.\n\n\n# Inputs\n\n`f`\n\n: A function, given an attribute's name and value, returns a new `nameValuePair`.\n\n`set`\n\n: Attribute set to map over.\n\n# Type\n\n```\nmapAttrs' :: (String -> Any -> { name :: String; value :: Any; }) -> AttrSet -> AttrSet\n```\n\n# Examples\n:::{.example}\n## `lib.attrsets.mapAttrs'` usage example\n\n```nix\nmapAttrs' (name: value: nameValuePair (\"foo_\" + name) (\"bar-\" + value))\n   { x = \"a\"; y = \"b\"; }\n=> { foo_x = \"bar-a\"; foo_y = \"bar-b\"; }\n```\n\n:::\n",
  "lib.attrsets.mapAttrsRecursive": "\nLike `mapAttrs`, except that it recursively applies itself to the *leaf* attributes of a potentially-nested attribute set:\nthe second argument of the function will never be an attrset.\nAlso, the first argument of the mapping function is a *list* of the attribute names that form the path to the leaf attribute.\n\nFor a function that gives you control over what counts as a leaf, see `mapAttrsRecursiveCond`.\n\n:::{#map-attrs-recursive-example .example}\n# Map over leaf attributes\n\n```nix\nmapAttrsRecursive (path: value: concatStringsSep \"-\" (path ++ [value]))\n  { n = { a = \"A\"; m = { b = \"B\"; c = \"C\"; }; }; d = \"D\"; }\n```\nevaluates to\n```nix\n{ n = { a = \"n-a-A\"; m = { b = \"n-m-b-B\"; c = \"n-m-c-C\"; }; }; d = \"d-D\"; }\n```\n:::\n\n# Type\n```\nmapAttrsRecursive :: ([String] -> a -> b) -> AttrSet -> AttrSet\n```\n",
  "lib.attrsets.mapAttrsRecursiveCond": "\nLike `mapAttrsRecursive`, but it takes an additional predicate that tells it whether to recurse into an attribute set.\nIf the predicate returns false, `mapAttrsRecursiveCond` does not recurse, but instead applies the mapping function.\nIf the predicate returns true, it does recurse, and does not apply the mapping function.\n\n:::{#map-attrs-recursive-cond-example .example}\n# Map over an leaf attributes defined by a condition\n\nMap derivations to their `name` attribute.\nDerivatons are identified as attribute sets that contain `{ type = \"derivation\"; }`.\n```nix\nmapAttrsRecursiveCond\n  (as: !(as ? \"type\" && as.type == \"derivation\"))\n  (x: x.name)\n  attrs\n```\n:::\n\n# Type\n```\nmapAttrsRecursiveCond :: (AttrSet -> Bool) -> ([String] -> a -> b) -> AttrSet -> AttrSet\n```\n",
  "lib.attrsets.mapAttrsToList": "\nCall a function for each attribute in the given set and return\nthe result in a list.\n\n# Inputs\n\n`f`\n\n: A function, given an attribute's name and value, returns a new value.\n\n`attrs`\n\n: Attribute set to map over.\n\n# Type\n\n```\nmapAttrsToList :: (String -> a -> b) -> AttrSet -> [b]\n```\n\n# Examples\n:::{.example}\n## `lib.attrsets.mapAttrsToList` usage example\n\n```nix\nmapAttrsToList (name: value: name + value)\n   { x = \"a\"; y = \"b\"; }\n=> [ \"xa\" \"yb\" ]\n```\n\n:::\n",
  "lib.attrsets.mapCartesianProduct": "\nReturn the result of function f applied to the cartesian product of attribute set value combinations.\nEquivalent to using cartesianProduct followed by map.\n\n# Inputs\n\n`f`\n\n: A function, given an attribute set, it returns a new value.\n\n`attrsOfLists`\n\n: Attribute set with attributes that are lists of values\n\n# Type\n\n```\nmapCartesianProduct :: (AttrSet -> a) -> AttrSet -> [a]\n```\n\n# Examples\n:::{.example}\n## `lib.attrsets.mapCartesianProduct` usage example\n\n```nix\nmapCartesianProduct ({a, b}: \"${a}-${b}\") { a = [ \"1\" \"2\" ]; b = [ \"3\" \"4\" ]; }\n=> [ \"1-3\" \"1-4\" \"2-3\" \"2-4\" ]\n```\n\n:::\n\n",
  "lib.attrsets.matchAttrs": "\nRecurse into every attribute set of the first argument and check that:\n- Each attribute path also exists in the second argument.\n- If the attribute's value is not a nested attribute set, it must have the same value in the right argument.\n\n\n# Inputs\n\n`pattern`\n\n: Attribute set structure to match\n\n`attrs`\n\n: Attribute set to check\n\n# Type\n\n```\nmatchAttrs :: AttrSet -> AttrSet -> Bool\n```\n\n# Examples\n:::{.example}\n## `lib.attrsets.matchAttrs` usage example\n\n```nix\nmatchAttrs { cpu = {}; } { cpu = { bits = 64; }; }\n=> true\n```\n\n:::\n",
  "lib.attrsets.mergeAttrsList": "\nMerge a list of attribute sets together using the `//` operator.\nIn case of duplicate attributes, values from later list elements take precedence over earlier ones.\nThe result is the same as `foldl mergeAttrs { }`, but the performance is better for large inputs.\nFor n list elements, each with an attribute set containing m unique attributes, the complexity of this operation is O(nm log n).\n\n\n# Inputs\n\n`list`\n\n: 1\\. Function argument\n\n# Type\n\n```\nmergeAttrsList :: [ Attrs ] -> Attrs\n```\n\n# Examples\n:::{.example}\n## `lib.attrsets.mergeAttrsList` usage example\n\n```nix\nmergeAttrsList [ { a = 0; b = 1; } { c = 2; d = 3; } ]\n=> { a = 0; b = 1; c = 2; d = 3; }\nmergeAttrsList [ { a = 0; } { a = 1; } ]\n=> { a = 1; }\n```\n\n:::\n",
  "lib.attrsets.nameValuePair": "\nUtility function that creates a `{name, value}` pair as expected by `builtins.listToAttrs`.\n\n\n# Inputs\n\n`name`\n\n: Attribute name\n\n`value`\n\n: Attribute value\n\n# Type\n\n```\nnameValuePair :: String -> Any -> { name :: String; value :: Any; }\n```\n\n# Examples\n:::{.example}\n## `lib.attrsets.nameValuePair` usage example\n\n```nix\nnameValuePair \"some\" 6\n=> { name = \"some\"; value = 6; }\n```\n\n:::\n",
  "lib.attrsets.optionalAttrs": "\nIf `cond` is true, return the attribute set `as`,\notherwise an empty attribute set.\n\n\n# Inputs\n\n`cond`\n\n: Condition under which the `as` attribute set is returned.\n\n`as`\n\n: The attribute set to return if `cond` is `true`.\n\n# Type\n\n```\noptionalAttrs :: Bool -> AttrSet -> AttrSet\n```\n\n# Examples\n:::{.example}\n## `lib.attrsets.optionalAttrs` usage example\n\n```nix\noptionalAttrs (true) { my = \"set\"; }\n=> { my = \"set\"; }\noptionalAttrs (false) { my = \"set\"; }\n=> { }\n```\n\n:::\n",
  "lib.attrsets.overrideExisting": "\nOverride only the attributes that are already present in the old set\nuseful for deep-overriding.\n\n\n# Inputs\n\n`old`\n\n: Original attribute set\n\n`new`\n\n: Attribute set with attributes to override in `old`.\n\n# Type\n\n```\noverrideExisting :: AttrSet -> AttrSet -> AttrSet\n```\n\n# Examples\n:::{.example}\n## `lib.attrsets.overrideExisting` usage example\n\n```nix\noverrideExisting {} { a = 1; }\n=> {}\noverrideExisting { b = 2; } { a = 1; }\n=> { b = 2; }\noverrideExisting { a = 3; b = 2; } { a = 1; }\n=> { a = 1; b = 2; }\n```\n\n:::\n",
  "lib.attrsets.recurseIntoAttrs": "\nMake various Nix tools consider the contents of the resulting\nattribute set when looking for what to build, find, etc.\n\nThis function only affects a single attribute set; it does not\napply itself recursively for nested attribute sets.\n\n\n# Inputs\n\n`attrs`\n\n: An attribute set to scan for derivations.\n\n# Type\n\n```\nrecurseIntoAttrs :: AttrSet -> AttrSet\n```\n\n# Examples\n:::{.example}\n## `lib.attrsets.recurseIntoAttrs` usage example\n\n```nix\n{ pkgs ? import <nixpkgs> {} }:\n{\n  myTools = pkgs.lib.recurseIntoAttrs {\n    inherit (pkgs) hello figlet;\n  };\n}\n```\n\n:::\n",
  "lib.attrsets.recursiveUpdate": "\nA recursive variant of the update operator ‘//’.  The recursion\nstops when one of the attribute values is not an attribute set,\nin which case the right hand side value takes precedence over the\nleft hand side value.\n\n\n# Inputs\n\n`lhs`\n\n: Left attribute set of the merge.\n\n`rhs`\n\n: Right attribute set of the merge.\n\n# Type\n\n```\nrecursiveUpdate :: AttrSet -> AttrSet -> AttrSet\n```\n\n# Examples\n:::{.example}\n## `lib.attrsets.recursiveUpdate` usage example\n\n```nix\nrecursiveUpdate {\n  boot.loader.grub.enable = true;\n  boot.loader.grub.device = \"/dev/hda\";\n} {\n  boot.loader.grub.device = \"\";\n}\n\nreturns: {\n  boot.loader.grub.enable = true;\n  boot.loader.grub.device = \"\";\n}\n```\n\n:::\n",
  "lib.attrsets.recursiveUpdateUntil": "\nDoes the same as the update operator '//' except that attributes are\nmerged until the given predicate is verified.  The predicate should\naccept 3 arguments which are the path to reach the attribute, a part of\nthe first attribute set and a part of the second attribute set.  When\nthe predicate is satisfied, the value of the first attribute set is\nreplaced by the value of the second attribute set.\n\n\n# Inputs\n\n`pred`\n\n: Predicate, taking the path to the current attribute as a list of strings for attribute names, and the two values at that path from the original arguments.\n\n`lhs`\n\n: Left attribute set of the merge.\n\n`rhs`\n\n: Right attribute set of the merge.\n\n# Type\n\n```\nrecursiveUpdateUntil :: ( [ String ] -> AttrSet -> AttrSet -> Bool ) -> AttrSet -> AttrSet -> AttrSet\n```\n\n# Examples\n:::{.example}\n## `lib.attrsets.recursiveUpdateUntil` usage example\n\n```nix\nrecursiveUpdateUntil (path: l: r: path == [\"foo\"]) {\n  # first attribute set\n  foo.bar = 1;\n  foo.baz = 2;\n  bar = 3;\n} {\n  #second attribute set\n  foo.bar = 1;\n  foo.quz = 2;\n  baz = 4;\n}\n\n=> {\n  foo.bar = 1; # 'foo.*' from the second set\n  foo.quz = 2; #\n  bar = 3;     # 'bar' from the first set\n  baz = 4;     # 'baz' from the second set\n}\n```\n\n:::\n",
  "lib.attrsets.removeAttrs": "\nRemove the attributes listed in *list* from *set*. The attributes\ndon’t have to exist in *set*. For instance,\n\n```nix\nremoveAttrs { x = 1; y = 2; z = 3; } [ \"a\" \"x\" \"z\" ]\n```\n\nevaluates to `{ y = 2; }`.\n",
  "lib.attrsets.setAttrByPath": "\nCreate a new attribute set with `value` set at the nested attribute location specified in `attrPath`.\n\n\n# Inputs\n\n`attrPath`\n\n: A list of strings representing the attribute path to set\n\n`value`\n\n: The value to set at the location described by `attrPath`\n\n# Type\n\n```\nsetAttrByPath :: [String] -> Any -> AttrSet\n```\n\n# Examples\n:::{.example}\n## `lib.attrsets.setAttrByPath` usage example\n\n```nix\nsetAttrByPath [\"a\" \"b\"] 3\n=> { a = { b = 3; }; }\n```\n\n:::\n",
  "lib.attrsets.showAttrPath": "\nTurns a list of strings into a human-readable description of those\nstrings represented as an attribute path. The result of this function is\nnot intended to be machine-readable.\nCreate a new attribute set with `value` set at the nested attribute location specified in `attrPath`.\n\n\n# Inputs\n\n`path`\n\n: Attribute path to render to a string\n\n# Type\n\n```\nshowAttrPath :: [String] -> String\n```\n\n# Examples\n:::{.example}\n## `lib.attrsets.showAttrPath` usage example\n\n```nix\nshowAttrPath [ \"foo\" \"10\" \"bar\" ]\n=> \"foo.\\\"10\\\".bar\"\nshowAttrPath []\n=> \"<root attribute path>\"\n```\n\n:::\n",
  "lib.attrsets.toDerivation": "\nConverts a store path to a fake derivation.\n\n\n# Inputs\n\n`path`\n\n: A store path to convert to a derivation.\n\n# Type\n\n```\ntoDerivation :: Path -> Derivation\n```\n",
  "lib.attrsets.unionOfDisjoint": "\n`unionOfDisjoint x y` is equal to `x // y // z` where the\nattrnames in `z` are the intersection of the attrnames in `x` and\n`y`, and all values `assert` with an error message.  This\n operator is commutative, unlike (//).\n\n\n# Inputs\n\n`x`\n\n: 1\\. Function argument\n\n`y`\n\n: 2\\. Function argument\n\n# Type\n\n```\nunionOfDisjoint :: AttrSet -> AttrSet -> AttrSet\n```\n",
  "lib.attrsets.updateManyAttrsByPath": "\nUpdate or set specific paths of an attribute set.\n\nTakes a list of updates to apply and an attribute set to apply them to,\nand returns the attribute set with the updates applied. Updates are\nrepresented as `{ path = ...; update = ...; }` values, where `path` is a\nlist of strings representing the attribute path that should be updated,\nand `update` is a function that takes the old value at that attribute path\nas an argument and returns the new\nvalue it should be.\n\nProperties:\n\n- Updates to deeper attribute paths are applied before updates to more\n  shallow attribute paths\n\n- Multiple updates to the same attribute path are applied in the order\n  they appear in the update list\n\n- If any but the last `path` element leads into a value that is not an\n  attribute set, an error is thrown\n\n- If there is an update for an attribute path that doesn't exist,\n  accessing the argument in the update function causes an error, but\n  intermediate attribute sets are implicitly created as needed\n\n# Type\n\n```\nupdateManyAttrsByPath :: [{ path :: [String]; update :: (Any -> Any); }] -> AttrSet -> AttrSet\n```\n\n# Examples\n:::{.example}\n## `lib.attrsets.updateManyAttrsByPath` usage example\n\n```nix\nupdateManyAttrsByPath [\n  {\n    path = [ \"a\" \"b\" ];\n    update = old: { d = old.c; };\n  }\n  {\n    path = [ \"a\" \"b\" \"c\" ];\n    update = old: old + 1;\n  }\n  {\n    path = [ \"x\" \"y\" ];\n    update = old: \"xy\";\n  }\n] { a.b.c = 0; }\n=> { a = { b = { d = 1; }; }; x = { y = \"xy\"; }; }\n```\n\n:::\n",
  "lib.attrsets.zip": "\nMerge sets of attributes and use the function f to merge attribute values.\nLike `lib.attrsets.zipAttrsWithNames` with all key names are passed for `names`.\n\nImplementation note: Common names appear multiple times in the list of\nnames, hopefully this does not affect the system because the maximal\nlaziness avoid computing twice the same expression and `listToAttrs` does\nnot care about duplicated attribute names.\n\n# Type\n\n```\nzipAttrsWith :: (String -> [ Any ] -> Any) -> [ AttrSet ] -> AttrSet\n```\n\n# Examples\n:::{.example}\n## `lib.attrsets.zipAttrsWith` usage example\n\n```nix\nzipAttrsWith (name: values: values) [{a = \"x\";} {a = \"y\"; b = \"z\";}]\n=> { a = [\"x\" \"y\"]; b = [\"z\"]; }\n```\n\n:::\n",
  "lib.attrsets.zipAttrs": "\nMerge sets of attributes and combine each attribute value in to a list.\n\nLike `lib.attrsets.zipAttrsWith` with `(name: values: values)` as the function.\n\n# Type\n\n```\nzipAttrs :: [ AttrSet ] -> AttrSet\n```\n\n# Examples\n:::{.example}\n## `lib.attrsets.zipAttrs` usage example\n\n```nix\nzipAttrs [{a = \"x\";} {a = \"y\"; b = \"z\";}]\n=> { a = [\"x\" \"y\"]; b = [\"z\"]; }\n```\n\n:::\n",
  "lib.attrsets.zipAttrsWith": "\nMerge sets of attributes and use the function f to merge attribute values.\nLike `lib.attrsets.zipAttrsWithNames` with all key names are passed for `names`.\n\nImplementation note: Common names appear multiple times in the list of\nnames, hopefully this does not affect the system because the maximal\nlaziness avoid computing twice the same expression and `listToAttrs` does\nnot care about duplicated attribute names.\n\n# Type\n\n```\nzipAttrsWith :: (String -> [ Any ] -> Any) -> [ AttrSet ] -> AttrSet\n```\n\n# Examples\n:::{.example}\n## `lib.attrsets.zipAttrsWith` usage example\n\n```nix\nzipAttrsWith (name: values: values) [{a = \"x\";} {a = \"y\"; b = \"z\";}]\n=> { a = [\"x\" \"y\"]; b = [\"z\"]; }\n```\n\n:::\n",
  "lib.attrsets.zipAttrsWithNames": "\nMerge sets of attributes and use the function `f` to merge attributes\nvalues.\n\n\n# Inputs\n\n`names`\n\n: List of attribute names to zip.\n\n`f`\n\n: A function, accepts an attribute name, all the values, and returns a combined value.\n\n`sets`\n\n: List of values from the list of attribute sets.\n\n# Type\n\n```\nzipAttrsWithNames :: [ String ] -> (String -> [ Any ] -> Any) -> [ AttrSet ] -> AttrSet\n```\n\n# Examples\n:::{.example}\n## `lib.attrsets.zipAttrsWithNames` usage example\n\n```nix\nzipAttrsWithNames [\"a\"] (name: vs: vs) [{a = \"x\";} {a = \"y\"; b = \"z\";}]\n=> { a = [\"x\" \"y\"]; }\n```\n\n:::\n",
  "lib.attrsets.zipWithNames": "\nMerge sets of attributes and use the function `f` to merge attributes\nvalues.\n\n\n# Inputs\n\n`names`\n\n: List of attribute names to zip.\n\n`f`\n\n: A function, accepts an attribute name, all the values, and returns a combined value.\n\n`sets`\n\n: List of values from the list of attribute sets.\n\n# Type\n\n```\nzipAttrsWithNames :: [ String ] -> (String -> [ Any ] -> Any) -> [ AttrSet ] -> AttrSet\n```\n\n# Examples\n:::{.example}\n## `lib.attrsets.zipAttrsWithNames` usage example\n\n```nix\nzipAttrsWithNames [\"a\"] (name: vs: vs) [{a = \"x\";} {a = \"y\"; b = \"z\";}]\n=> { a = [\"x\" \"y\"]; }\n```\n\n:::\n",
  "lib.cli.toGNUCommandLine": "\nAutomatically convert an attribute set to a list of command-line options.\n\n`toGNUCommandLine` returns a list of string arguments.\n\n# Inputs\n\n`options`\n\n: How to format the arguments, see below.\n\n`attrs`\n\n: The attributes to transform into arguments.\n\n# Options\n\n`mkOptionName`\n\n: How to string-format the option name;\nBy default one character is a short option (`-`), more than one characters a long option (`--`).\n\n`mkBool`\n\n: How to format a boolean value to a command list;\nBy default it’s a flag option (only the option name if true, left out completely if false).\n\n`mkList`\n\n: How to format a list value to a command list;\nBy default the option name is repeated for each value and `mkOption` is applied to the values themselves.\n\n`mkOption`\n\n: How to format any remaining value to a command list;\nOn the toplevel, booleans and lists are handled by `mkBool` and `mkList`, though they can still appear as values of a list.\nBy default, everything is printed verbatim and complex types are forbidden (lists, attrsets, functions). `null` values are omitted.\n\n`optionValueSeparator`\n\n: How to separate an option from its flag;\nBy default, there is no separator, so option `-c` and value `5` would become [\"-c\" \"5\"].\nThis is useful if the command requires equals, for example, `-c=5`.\n\n# Examples\n:::{.example}\n## `lib.cli.toGNUCommandLine` usage example\n\n```nix\ncli.toGNUCommandLine {} {\n  data = builtins.toJSON { id = 0; };\n  X = \"PUT\";\n  retry = 3;\n  retry-delay = null;\n  url = [ \"https://example.com/foo\" \"https://example.com/bar\" ];\n  silent = false;\n  verbose = true;\n}\n=> [\n  \"-X\" \"PUT\"\n  \"--data\" \"{\\\"id\\\":0}\"\n  \"--retry\" \"3\"\n  \"--url\" \"https://example.com/foo\"\n  \"--url\" \"https://example.com/bar\"\n  \"--verbose\"\n]\n```\n\n:::\n",
  "lib.cli.toGNUCommandLineShell": "\nAutomatically convert an attribute set to command-line options.\n\nThis helps protect against malformed command lines and also to reduce\nboilerplate related to command-line construction for simple use cases.\n\n`toGNUCommandLineShell` returns an escaped shell string.\n\n# Inputs\n\n`options`\n\n: How to format the arguments, see `toGNUCommandLine`\n\n`attrs`\n\n: The attributes to transform into arguments.\n\n# Examples\n:::{.example}\n## `lib.cli.toGNUCommandLineShell` usage example\n\n```nix\ncli.toGNUCommandLineShell {} {\n  data = builtins.toJSON { id = 0; };\n  X = \"PUT\";\n  retry = 3;\n  retry-delay = null;\n  url = [ \"https://example.com/foo\" \"https://example.com/bar\" ];\n  silent = false;\n  verbose = true;\n}\n=> \"'-X' 'PUT' '--data' '{\\\"id\\\":0}' '--retry' '3' '--url' 'https://example.com/foo' '--url' 'https://example.com/bar' '--verbose'\";\n```\n\n:::\n",
  "lib.customisation.callPackageWith": "\nCall the package function in the file `fn` with the required\narguments automatically.  The function is called with the\narguments `args`, but any missing arguments are obtained from\n`autoArgs`.  This function is intended to be partially\nparameterised, e.g.,\n\n  ```nix\n  callPackage = callPackageWith pkgs;\n  pkgs = {\n    libfoo = callPackage ./foo.nix { };\n    libbar = callPackage ./bar.nix { };\n  };\n  ```\n\nIf the `libbar` function expects an argument named `libfoo`, it is\nautomatically passed as an argument.  Overrides or missing\narguments can be supplied in `args`, e.g.\n\n  ```nix\n  libbar = callPackage ./bar.nix {\n    libfoo = null;\n    enableX11 = true;\n  };\n  ```\n\n<!-- TODO: Apply \"Example:\" tag to the examples above -->\n\n# Inputs\n\n`autoArgs`\n\n: 1\\. Function argument\n\n`fn`\n\n: 2\\. Function argument\n\n`args`\n\n: 3\\. Function argument\n\n# Type\n\n```\ncallPackageWith :: AttrSet -> ((AttrSet -> a) | Path) -> AttrSet -> a\n```\n",
  "lib.customisation.callPackagesWith": "\nLike callPackage, but for a function that returns an attribute\nset of derivations. The override function is added to the\nindividual attributes.\n\n# Inputs\n\n`autoArgs`\n\n: 1\\. Function argument\n\n`fn`\n\n: 2\\. Function argument\n\n`args`\n\n: 3\\. Function argument\n\n# Type\n\n```\ncallPackagesWith :: AttrSet -> ((AttrSet -> AttrSet) | Path) -> AttrSet -> AttrSet\n```\n",
  "lib.customisation.extendDerivation": "\nAdd attributes to each output of a derivation without changing\nthe derivation itself and check a given condition when evaluating.\n\n# Inputs\n\n`condition`\n\n: 1\\. Function argument\n\n`passthru`\n\n: 2\\. Function argument\n\n`drv`\n\n: 3\\. Function argument\n\n# Type\n\n```\nextendDerivation :: Bool -> Any -> Derivation -> Derivation\n```\n",
  "lib.customisation.extendMkDerivation": "\nDefine a `mkDerivation`-like function based on another `mkDerivation`-like function.\n\n[`stdenv.mkDerivation`](#part-stdenv) gives access to\nits final set of derivation attributes when it is passed a function,\nor when it is passed an overlay-style function in `overrideAttrs`.\n\nInstead of composing new `stdenv.mkDerivation`-like build helpers\nusing normal function composition,\n`extendMkDerivation` makes sure that the returned build helper\nsupports such first class recursion like `mkDerivation` does.\n\n`extendMkDerivation` takes an extra attribute set to configure its behaviour.\nOne can optionally specify\n`transformDrv` to specify a function to apply to the result derivation,\nor `inheritFunctionArgs` to decide whether to inherit the `__functionArgs`\nfrom the base build helper.\n\n# Inputs\n\n`extendMkDerivation`-specific configurations\n: `constructDrv`: Base build helper, the `mkDerivation`-like build helper to extend.\n: `excludeDrvArgNames`: Argument names not to pass from the input fixed-point arguments to `constructDrv`. Note: It doesn't apply to the updating arguments returned by `extendDrvArgs`.\n: `extendDrvArgs` : An extension (overlay) of the argument set, like the one taken by [overrideAttrs](#sec-pkg-overrideAttrs) but applied before passing to `constructDrv`.\n: `inheritFunctionArgs`: Whether to inherit `__functionArgs` from the base build helper (default to `true`).\n: `transformDrv`: Function to apply to the result derivation (default to `lib.id`).\n\n# Type\n\n```\nextendMkDerivation ::\n  {\n    constructDrv :: ((FixedPointArgs | AttrSet) -> a)\n    excludeDrvArgNames :: [ String ],\n    extendDrvArgs :: (AttrSet -> AttrSet -> AttrSet)\n    inheritFunctionArgs :: Bool,\n    transformDrv :: a -> a,\n  }\n  -> (FixedPointArgs | AttrSet) -> a\n\nFixedPointArgs = AttrSet -> AttrSet\na = Derivation when defining a build helper\n```\n\n# Examples\n\n:::{.example}\n## `lib.customisation.extendMkDerivation` usage example\n```nix-repl\nmkLocalDerivation = lib.extendMkDerivation {\n  constructDrv = pkgs.stdenv.mkDerivation;\n  excludeDrvArgNames = [ \"specialArg\" ];\n  extendDrvArgs =\n    finalAttrs: args@{ preferLocalBuild ? true, allowSubstitute ? false, specialArg ? (_: false), ... }:\n    { inherit preferLocalBuild allowSubstitute; passthru = { inherit specialArg; } // args.passthru or { }; };\n}\n\nmkLocalDerivation.__functionArgs\n=> { allowSubstitute = true; preferLocalBuild = true; specialArg = true; }\n\nmkLocalDerivation { inherit (pkgs.hello) pname version src; specialArg = _: false; }\n=> «derivation /nix/store/xirl67m60ahg6jmzicx43a81g635g8z8-hello-2.12.1.drv»\n\nmkLocalDerivation (finalAttrs: { inherit (pkgs.hello) pname version src; specialArg = _: false; })\n=> «derivation /nix/store/xirl67m60ahg6jmzicx43a81g635g8z8-hello-2.12.1.drv»\n\n(mkLocalDerivation (finalAttrs: { inherit (pkgs.hello) pname version src; passthru = { foo = \"a\"; bar = \"${finalAttrs.passthru.foo}b\"; }; })).bar\n=> \"ab\"\n```\n:::\n\n:::{.note}\nIf `transformDrv` is specified,\nit should take care of existing attributes that perform overriding\n(e.g., [`overrideAttrs`](#sec-pkg-overrideAttrs))\nto ensure that the overriding functionality of the result derivation\nwork as expected.\nModifications that breaks the overriding include\ndirect [attribute set update](https://nixos.org/manual/nix/stable/language/operators#update)\nand [`lib.extendDerivation`](#function-library-lib.customisation.extendDerivation).\n:::\n",
  "lib.customisation.hydraJob": "\nStrip a derivation of all non-essential attributes, returning\nonly those needed by hydra-eval-jobs. Also strictly evaluate the\nresult to ensure that there are no thunks kept alive to prevent\ngarbage collection.\n\n# Inputs\n\n`drv`\n\n: 1\\. Function argument\n\n# Type\n\n```\nhydraJob :: (Derivation | Null) -> (Derivation | Null)\n```\n",
  "lib.customisation.makeOverridable": "\n`makeOverridable` takes a function from attribute set to attribute set and\ninjects `override` attribute which can be used to override arguments of\nthe function.\n\nPlease refer to  documentation on [`<pkg>.overrideDerivation`](#sec-pkg-overrideDerivation) to learn about `overrideDerivation` and caveats\nrelated to its use.\n\n# Inputs\n\n`f`\n\n: 1\\. Function argument\n\n# Type\n\n```\nmakeOverridable :: (AttrSet -> a) -> AttrSet -> a\n```\n\n# Examples\n:::{.example}\n## `lib.customisation.makeOverridable` usage example\n\n```nix\nnix-repl> x = {a, b}: { result = a + b; }\n\nnix-repl> y = lib.makeOverridable x { a = 1; b = 2; }\n\nnix-repl> y\n{ override = «lambda»; overrideDerivation = «lambda»; result = 3; }\n\nnix-repl> y.override { a = 10; }\n{ override = «lambda»; overrideDerivation = «lambda»; result = 12; }\n```\n\n:::\n",
  "lib.customisation.makeScope": "\nMake an attribute set (a \"scope\") from functions that take arguments from that same attribute set.\nSee [](#ex-makeScope) for how to use it.\n\n# Inputs\n\n1. `newScope` (`AttrSet -> ((AttrSet -> a) | Path) -> AttrSet -> a`)\n\n   A function that takes an attribute set `attrs` and returns what ends up as `callPackage` in the output.\n\n   Typical values are `callPackageWith` or the output attribute `newScope`.\n\n2. `f` (`AttrSet -> AttrSet`)\n\n   A function that takes an attribute set as returned by `makeScope newScope f` (a \"scope\") and returns any attribute set.\n\n   This function is used to compute the fixpoint of the resulting scope using `callPackage`.\n   Its argument is the lazily evaluated reference to the value of that fixpoint, and is typically called `self` or `final`.\n\n   See [](#ex-makeScope) for how to use it.\n   See [](#sec-functions-library-fixedPoints) for details on fixpoint computation.\n\n# Output\n\n`makeScope` returns an attribute set of a form called `scope`, which also contains the final attributes produced by `f`:\n\n```\nscope :: {\n  callPackage :: ((AttrSet -> a) | Path) -> AttrSet -> a\n  newScope = AttrSet -> scope\n  overrideScope = (scope -> scope -> AttrSet) -> scope\n  packages :: AttrSet -> AttrSet\n}\n```\n\n- `callPackage` (`((AttrSet -> a) | Path) -> AttrSet -> a`)\n\n  A function that\n\n  1. Takes a function `p`, or a path to a Nix file that contains a function `p`, which takes an attribute set and returns value of arbitrary type `a`,\n  2. Takes an attribute set `args` with explicit attributes to pass to `p`,\n  3. Calls `f` with attributes from the original attribute set `attrs` passed to `newScope` updated with `args`, i.e. `attrs // args`, if they match the attributes in the argument of `p`.\n\n  All such functions `p` will be called with the same value for `attrs`.\n\n  See [](#ex-makeScope-callPackage) for how to use it.\n\n- `newScope` (`AttrSet -> scope`)\n\n  Takes an attribute set `attrs` and returns a scope that extends the original scope.\n\n- `overrideScope` (`(scope -> scope -> AttrSet) -> scope`)\n\n  Takes a function `g` of the form `final: prev: { # attributes }` to act as an overlay on `f`, and returns a new scope with values determined by `extends g f`.\n  See [](https://nixos.org/manual/nixpkgs/unstable/#function-library-lib.fixedPoints.extends) for details.\n\n  This allows subsequent modification of the final attribute set in a consistent way, i.e. all functions `p` invoked with `callPackage` will be called with the modified values.\n\n- `packages` (`AttrSet -> AttrSet`)\n\n  The value of the argument `f` to `makeScope`.\n\n- final attributes\n\n  The final values returned by `f`.\n\n# Examples\n\n:::{#ex-makeScope .example}\n# Create an interdependent package set on top of `pkgs`\n\nThe functions in `foo.nix` and `bar.nix` can depend on each other, in the sense that `foo.nix` can contain a function that expects `bar` as an attribute in its argument.\n\n```nix\nlet\n  pkgs = import <nixpkgs> { };\nin\npkgs.lib.makeScope pkgs.newScope (self: {\n  foo = self.callPackage ./foo.nix { };\n  bar = self.callPackage ./bar.nix { };\n})\n```\n\nevaluates to\n\n```nix\n{\n  callPackage = «lambda»;\n  newScope = «lambda»;\n  overrideScope = «lambda»;\n  packages = «lambda»;\n  foo = «derivation»;\n  bar = «derivation»;\n}\n```\n:::\n\n:::{#ex-makeScope-callPackage .example}\n# Using `callPackage` from a scope\n\n```nix\nlet\n  pkgs = import <nixpkgs> { };\n  inherit (pkgs) lib;\n  scope = lib.makeScope lib.callPackageWith (self: { a = 1; b = 2; });\n  three = scope.callPackage ({ a, b }: a + b) { };\n  four = scope.callPackage ({ a, b }: a + b) { a = 2; };\nin\n[ three four ]\n```\n\nevaluates to\n\n```nix\n[ 3 4 ]\n```\n:::\n\n# Type\n\n```\nmakeScope :: (AttrSet -> ((AttrSet -> a) | Path) -> AttrSet -> a) -> (AttrSet -> AttrSet) -> scope\n```\n",
  "lib.customisation.makeScopeWithSplicing": "\nbackward compatibility with old uncurried form; deprecated\n\n# Inputs\n\n`splicePackages`\n\n: 1\\. Function argument\n\n`newScope`\n\n: 2\\. Function argument\n\n`otherSplices`\n\n: 3\\. Function argument\n\n`keep`\n\n: 4\\. Function argument\n\n`extra`\n\n: 5\\. Function argument\n\n`f`\n\n: 6\\. Function argument\n",
  "lib.customisation.makeScopeWithSplicing' (Prime)": "\nLike makeScope, but aims to support cross compilation. It's still ugly, but\nhopefully it helps a little bit.\n\n# Type\n\n```\nmakeScopeWithSplicing' ::\n  { splicePackages :: Splice -> AttrSet\n  , newScope :: AttrSet -> ((AttrSet -> a) | Path) -> AttrSet -> a\n  }\n  -> { otherSplices :: Splice, keep :: AttrSet -> AttrSet, extra :: AttrSet -> AttrSet }\n  -> AttrSet\n\nSplice ::\n  { pkgsBuildBuild :: AttrSet\n  , pkgsBuildHost :: AttrSet\n  , pkgsBuildTarget :: AttrSet\n  , pkgsHostHost :: AttrSet\n  , pkgsHostTarget :: AttrSet\n  , pkgsTargetTarget :: AttrSet\n  }\n```\n",
  "lib.customisation.overrideDerivation": "\n`overrideDerivation drv f` takes a derivation (i.e., the result\nof a call to the builtin function `derivation`) and returns a new\nderivation in which the attributes of the original are overridden\naccording to the function `f`.  The function `f` is called with\nthe original derivation attributes.\n\n`overrideDerivation` allows certain \"ad-hoc\" customisation\nscenarios (e.g. in ~/.config/nixpkgs/config.nix).  For instance,\nif you want to \"patch\" the derivation returned by a package\nfunction in Nixpkgs to build another version than what the\nfunction itself provides.\n\nFor another application, see build-support/vm, where this\nfunction is used to build arbitrary derivations inside a QEMU\nvirtual machine.\n\nNote that in order to preserve evaluation errors, the new derivation's\noutPath depends on the old one's, which means that this function cannot\nbe used in circular situations when the old derivation also depends on the\nnew one.\n\nYou should in general prefer `drv.overrideAttrs` over this function;\nsee the nixpkgs manual for more information on overriding.\n\n# Inputs\n\n`drv`\n\n: 1\\. Function argument\n\n`f`\n\n: 2\\. Function argument\n\n# Type\n\n```\noverrideDerivation :: Derivation -> ( Derivation -> AttrSet ) -> Derivation\n```\n\n# Examples\n:::{.example}\n## `lib.customisation.overrideDerivation` usage example\n\n```nix\nmySed = overrideDerivation pkgs.gnused (oldAttrs: {\n  name = \"sed-4.2.2-pre\";\n  src = fetchurl {\n    url = ftp://alpha.gnu.org/gnu/sed/sed-4.2.2-pre.tar.bz2;\n    hash = \"sha256-MxBJRcM2rYzQYwJ5XKxhXTQByvSg5jZc5cSHEZoB2IY=\";\n  };\n  patches = [];\n});\n```\n\n:::\n",
  "lib.debug.runTests": "\nEvaluates a set of tests.\n\nA test is an attribute set `{expr, expected}`,\ndenoting an expression and its expected result.\n\nThe result is a `list` of __failed tests__, each represented as\n`{name, expected, result}`,\n\n- expected\n  - What was passed as `expected`\n- result\n  - The actual `result` of the test\n\nUsed for regression testing of the functions in lib; see\ntests.nix for more examples.\n\nImportant: Only attributes that start with `test` are executed.\n\n- If you want to run only a subset of the tests add the attribute `tests = [\"testName\"];`\n\n# Inputs\n\n`tests`\n\n: Tests to run\n\n# Type\n\n```\nrunTests :: {\n  tests = [ String ];\n  ${testName} :: {\n    expr :: a;\n    expected :: a;\n  };\n}\n->\n[\n  {\n    name :: String;\n    expected :: a;\n    result :: a;\n  }\n]\n```\n\n# Examples\n:::{.example}\n## `lib.debug.runTests` usage example\n\n```nix\nrunTests {\n  testAndOk = {\n    expr = lib.and true false;\n    expected = false;\n  };\n  testAndFail = {\n    expr = lib.and true false;\n    expected = true;\n  };\n}\n->\n[\n  {\n    name = \"testAndFail\";\n    expected = true;\n    result = false;\n  }\n]\n```\n\n:::\n",
  "lib.debug.testAllTrue": "\nCreate a test assuming that list elements are `true`.\n\n# Inputs\n\n`expr`\n\n: 1\\. Function argument\n\n# Examples\n:::{.example}\n## `lib.debug.testAllTrue` usage example\n\n```nix\n{ testX = allTrue [ true ]; }\n```\n\n:::\n",
  "lib.debug.traceFnSeqN": "\nTrace the input and output of a function `f` named `name`,\nboth down to `depth`.\n\nThis is useful for adding around a function call,\nto see the before/after of values as they are transformed.\n\n# Inputs\n\n`depth`\n\n: 1\\. Function argument\n\n`name`\n\n: 2\\. Function argument\n\n`f`\n\n: 3\\. Function argument\n\n`v`\n\n: 4\\. Function argument\n\n# Examples\n:::{.example}\n## `lib.debug.traceFnSeqN` usage example\n\n```nix\ntraceFnSeqN 2 \"id\" (x: x) { a.b.c = 3; }\ntrace: { fn = \"id\"; from = { a.b = {…}; }; to = { a.b = {…}; }; }\n=> { a.b.c = 3; }\n```\n\n:::\n",
  "lib.debug.traceIf": "\nConditionally trace the supplied message, based on a predicate.\n\n# Inputs\n\n`pred`\n\n: Predicate to check\n\n`msg`\n\n: Message that should be traced\n\n`x`\n\n: Value to return\n\n# Type\n\n```\ntraceIf :: bool -> string -> a -> a\n```\n\n# Examples\n:::{.example}\n## `lib.debug.traceIf` usage example\n\n```nix\ntraceIf true \"hello\" 3\ntrace: hello\n=> 3\n```\n\n:::\n",
  "lib.debug.traceSeq": "\n`builtins.trace`, but the value is `builtins.deepSeq`ed first.\n\n# Inputs\n\n`x`\n\n: The value to trace\n\n`y`\n\n: The value to return\n\n# Type\n\n```\ntraceSeq :: a -> b -> b\n```\n\n# Examples\n:::{.example}\n## `lib.debug.traceSeq` usage example\n\n```nix\ntrace { a.b.c = 3; } null\ntrace: { a = <CODE>; }\n=> null\ntraceSeq { a.b.c = 3; } null\ntrace: { a = { b = { c = 3; }; }; }\n=> null\n```\n\n:::\n",
  "lib.debug.traceSeqN": "\nLike `traceSeq`, but only evaluate down to depth n.\nThis is very useful because lots of `traceSeq` usages\nlead to an infinite recursion.\n\n# Inputs\n\n`depth`\n\n: 1\\. Function argument\n\n`x`\n\n: 2\\. Function argument\n\n`y`\n\n: 3\\. Function argument\n\n# Type\n\n```\ntraceSeqN :: Int -> a -> b -> b\n```\n\n# Examples\n:::{.example}\n## `lib.debug.traceSeqN` usage example\n\n```nix\ntraceSeqN 2 { a.b.c = 3; } null\ntrace: { a = { b = {…}; }; }\n=> null\n```\n\n:::\n",
  "lib.debug.traceVal": "\nTrace the supplied value and return it.\n\n# Inputs\n\n`x`\n\n: Value to trace and return\n\n# Type\n\n```\ntraceVal :: a -> a\n```\n\n# Examples\n:::{.example}\n## `lib.debug.traceVal` usage example\n\n```nix\ntraceVal 42\n# trace: 42\n=> 42\n```\n\n:::\n",
  "lib.debug.traceValFn": "\nTrace the supplied value after applying a function to it, and\nreturn the original value.\n\n# Inputs\n\n`f`\n\n: Function to apply\n\n`x`\n\n: Value to trace and return\n\n# Type\n\n```\ntraceValFn :: (a -> b) -> a -> a\n```\n\n# Examples\n:::{.example}\n## `lib.debug.traceValFn` usage example\n\n```nix\ntraceValFn (v: \"mystring ${v}\") \"foo\"\ntrace: mystring foo\n=> \"foo\"\n```\n\n:::\n",
  "lib.debug.traceValSeq": "\nA combination of `traceVal` and `traceSeq`.\n\n# Inputs\n\n`v`\n\n: Value to trace\n",
  "lib.debug.traceValSeqFn": "\nA combination of `traceVal` and `traceSeq` that applies a\nprovided function to the value to be traced after `deepSeq`ing\nit.\n\n# Inputs\n\n`f`\n\n: Function to apply\n\n`v`\n\n: Value to trace\n",
  "lib.debug.traceValSeqN": "\nA combination of `traceVal` and `traceSeqN`.\n\n# Inputs\n\n`depth`\n\n: 1\\. Function argument\n\n`v`\n\n: Value to trace\n",
  "lib.debug.traceValSeqNFn": "\nA combination of `traceVal` and `traceSeqN` that applies a\nprovided function to the value to be traced.\n\n# Inputs\n\n`f`\n\n: Function to apply\n\n`depth`\n\n: 2\\. Function argument\n\n`v`\n\n: Value to trace\n",
  "lib.derivations.lazyDerivation": "\nRestrict a derivation to a predictable set of attribute names, so\nthat the returned attrset is not strict in the actual derivation,\nsaving a lot of computation when the derivation is non-trivial.\n\nThis is useful in situations where a derivation might only be used for its\npassthru attributes, improving evaluation performance.\n\nThe returned attribute set is lazy in `derivation`. Specifically, this\nmeans that the derivation will not be evaluated in at least the\nsituations below.\n\nFor illustration and/or testing, we define derivation such that its\nevaluation is very noticeable.\n\n    let derivation = throw \"This won't be evaluated.\";\n\nIn the following expressions, `derivation` will _not_ be evaluated:\n\n    (lazyDerivation { inherit derivation; }).type\n\n    attrNames (lazyDerivation { inherit derivation; })\n\n    (lazyDerivation { inherit derivation; } // { foo = true; }).foo\n\n    (lazyDerivation { inherit derivation; meta.foo = true; }).meta\n\nIn these expressions, `derivation` _will_ be evaluated:\n\n    \"${lazyDerivation { inherit derivation }}\"\n\n    (lazyDerivation { inherit derivation }).outPath\n\n    (lazyDerivation { inherit derivation }).meta\n\nAnd the following expressions are not valid, because the refer to\nimplementation details and/or attributes that may not be present on\nsome derivations:\n\n    (lazyDerivation { inherit derivation }).buildInputs\n\n    (lazyDerivation { inherit derivation }).passthru\n\n    (lazyDerivation { inherit derivation }).pythonPath\n\n# Inputs\n\nTakes an attribute set with the following attributes\n\n`derivation`\n: The derivation to be wrapped.\n\n`meta`\n: Optional meta attribute.\n\n  While this function is primarily about derivations, it can improve\n  the `meta` package attribute, which is usually specified through\n  `mkDerivation`.\n\n`passthru`\n: Optional extra values to add to the returned attrset.\n\n  This can be used for adding package attributes, such as `tests`.\n\n`outputs`\n: Optional list of assumed outputs. Default: [\"out\"]\n\n  This must match the set of outputs that the returned derivation has.\n  You must use this when the derivation has multiple outputs.\n",
  "lib.derivations.optionalDrvAttr": "\nConditionally set a derivation attribute.\n\nBecause `mkDerivation` sets `__ignoreNulls = true`, a derivation\nattribute set to `null` will not impact the derivation output hash.\nThus, this function passes through its `value` argument if the `cond`\nis `true`, but returns `null` if not.\n\n# Inputs\n\n`cond`\n\n: Condition\n\n`value`\n\n: Attribute value\n\n# Type\n\n```\noptionalDrvAttr :: Bool -> a -> a | Null\n```\n\n# Examples\n:::{.example}\n## `lib.derivations.optionalDrvAttr` usage example\n\n```nix\n(stdenv.mkDerivation {\n  name = \"foo\";\n  x = optionalDrvAttr true 1;\n  y = optionalDrvAttr false 1;\n}).drvPath == (stdenv.mkDerivation {\n  name = \"foo\";\n  x = 1;\n}).drvPath\n=> true\n```\n\n:::\n",
  "lib.derivations.warnOnInstantiate": "\nWrap a derivation such that instantiating it produces a warning.\n\nAll attributes apart from `meta`, `name`, and `type` (which are used by\n`nix search`) will be wrapped in `lib.warn`.\n\n# Inputs\n\n`msg`\n: The warning message to emit (via `lib.warn`).\n\n`drv`\n: The derivation to wrap.\n\n# Examples\n:::{.example}\n## `lib.derivations.warnOnInstantiate` usage example\n\n```nix\n{\n  myPackage = warnOnInstantiate \"myPackage has been renamed to my-package\" my-package;\n}\n```\n\n:::\n",
  "lib.fetchers.normalizeHash": "\nConverts an attrset containing one of `hash`, `sha256` or `sha512`,\ninto one containing `outputHash{,Algo}` as accepted by `mkDerivation`.\n\nAn appropriate “fake hash” is substituted when the hash value is `\"\"`,\nas is the [convention for fetchers](#sec-pkgs-fetchers-updating-source-hashes-fakehash-method).\n\nAll other attributes in the set remain as-is.\n\n# Example\n\n```nix\nnormalizeHash { } { hash = \"\"; foo = \"bar\"; }\n=>\n{\n  outputHash = lib.fakeHash;\n  outputHashAlgo = null;\n  foo = \"bar\";\n}\n```\n\n```nix\nnormalizeHash { } { sha256 = lib.fakeSha256; }\n=>\n{\n  outputHash = lib.fakeSha256;\n  outputHashAlgo = \"sha256\";\n}\n```\n\n```nix\nnormalizeHash { } { sha512 = lib.fakeSha512; }\n=>\n{\n  outputHash = lib.fakeSha512;\n  outputHashAlgo = \"sha512\";\n}\n```\n\n# Type\n```\nnormalizeHash :: { hashTypes :: List String, required :: Bool } -> AttrSet -> AttrSet\n```\n\n# Arguments\n\nhashTypes\n: the set of attribute names accepted as hash inputs, in addition to `hash`\n\nrequired\n: whether to throw if no hash was present in the input; otherwise returns the original input, unmodified\n",
  "lib.fetchers.withNormalizedHash": "\nWraps a function which accepts `outputHash{,Algo}` into one which accepts `hash` or `sha{256,512}`\n\n# Example\n```nix\nwithNormalizedHash { hashTypes = [ \"sha256\" \"sha512\" ]; } (\n  { outputHash, outputHashAlgo, ... }:\n  ...\n)\n```\nis a function which accepts one of `hash`, `sha256`, or `sha512` (or the original's `outputHash` and `outputHashAlgo`).\n\nIts `functionArgs` metadata only lists `hash` as a parameter, optional iff. `outputHash` was an optional parameter of\nthe original function.  `sha256`, `sha512`, `outputHash`, or `outputHashAlgo` are not mentioned in the `functionArgs`\nmetadata.\n\n# Type\n```\nwithNormalizedHash :: { hashTypes :: List String } -> (AttrSet -> T) -> (AttrSet -> T)\n```\n\n# Arguments\n\nhashTypes\n: the set of attribute names accepted as hash inputs, in addition to `hash`\n: they must correspond to a valid value for `outputHashAlgo`, currently one of: `md5`, `sha1`, `sha256`, or `sha512`.\n\nf\n: the function to be wrapped\n\n::: {.note}\nIn nixpkgs, `mkDerivation` rejects MD5 `outputHash`es, and SHA-1 is being deprecated.\n\nAs such, there is no reason to add `md5` to `hashTypes`, and\n`sha1` should only ever be included for backwards compatibility.\n:::\n\n# Output\n\n`withNormalizedHash { inherit hashTypes; } f` is functionally equivalent to\n```nix\nargs: f (normalizeHash {\n  inherit hashTypes;\n  required = !(lib.functionArgs f).outputHash;\n} args)\n```\n\nHowever, `withNormalizedHash` preserves `functionArgs` metadata insofar as possible,\nand is implemented somewhat more efficiently.\n",
  "lib.fileset.difference": "\nThe file set containing all files from the first file set that are not in the second file set.\nSee also [Difference (set theory)](https://en.wikipedia.org/wiki/Complement_(set_theory)#Relative_complement).\n\nThe given file sets are evaluated as lazily as possible,\nwith the first argument being evaluated first if needed.\n\n# Inputs\n\n`positive`\n\n: The positive file set. The result can only contain files that are also in this file set.  This argument can also be a path, which gets [implicitly coerced to a file set](#sec-fileset-path-coercion).\n\n`negative`\n\n: The negative file set. The result will never contain files that are also in this file set.  This argument can also be a path, which gets [implicitly coerced to a file set](#sec-fileset-path-coercion).\n\n# Type\n\n```\nunion :: FileSet -> FileSet -> FileSet\n```\n\n# Examples\n:::{.example}\n## `lib.fileset.difference` usage example\n\n```nix\n# Create a file set containing all files from the current directory,\n# except ones under ./tests\ndifference ./. ./tests\n\nlet\n  # A set of Nix-related files\n  nixFiles = unions [ ./default.nix ./nix ./tests/default.nix ];\nin\n# Create a file set containing all files under ./tests, except ones in `nixFiles`,\n# meaning only without ./tests/default.nix\ndifference ./tests nixFiles\n```\n\n:::\n",
  "lib.fileset.fileFilter": "\nFilter a file set to only contain files matching some predicate.\n\n# Inputs\n\n`predicate`\n\n: The predicate function to call on all files contained in given file set.\n  A file is included in the resulting file set if this function returns true for it.\n\n  This function is called with an attribute set containing these attributes:\n\n  - `name` (String): The name of the file\n\n  - `type` (String, one of `\"regular\"`, `\"symlink\"` or `\"unknown\"`): The type of the file.\n    This matches result of calling [`builtins.readFileType`](https://nixos.org/manual/nix/stable/language/builtins.html#builtins-readFileType) on the file's path.\n\n  - `hasExt` (String -> Bool): Whether the file has a certain file extension.\n    `hasExt ext` is true only if `hasSuffix \".${ext}\" name`.\n\n    This also means that e.g. for a file with name `.gitignore`,\n    `hasExt \"gitignore\"` is true.\n\n  Other attributes may be added in the future.\n\n`path`\n\n: The path whose files to filter\n\n# Type\n\n```\nfileFilter ::\n  ({\n    name :: String,\n    type :: String,\n    hasExt :: String -> Bool,\n    ...\n  } -> Bool)\n  -> Path\n  -> FileSet\n```\n\n# Examples\n:::{.example}\n## `lib.fileset.fileFilter` usage example\n\n```nix\n# Include all regular `default.nix` files in the current directory\nfileFilter (file: file.name == \"default.nix\") ./.\n\n# Include all non-Nix files from the current directory\nfileFilter (file: ! file.hasExt \"nix\") ./.\n\n# Include all files that start with a \".\" in the current directory\nfileFilter (file: hasPrefix \".\" file.name) ./.\n\n# Include all regular files (not symlinks or others) in the current directory\nfileFilter (file: file.type == \"regular\") ./.\n```\n\n:::\n",
  "lib.fileset.fromSource": "\nCreate a file set with the same files as a `lib.sources`-based value.\nThis does not import any of the files into the store.\n\nThis can be used to gradually migrate from `lib.sources`-based filtering to `lib.fileset`.\n\nA file set can be turned back into a source using [`toSource`](#function-library-lib.fileset.toSource).\n\n:::{.note}\nFile sets cannot represent empty directories.\nTurning the result of this function back into a source using `toSource` will therefore not preserve empty directories.\n:::\n\n# Inputs\n\n`source`\n\n: 1\\. Function argument\n\n# Type\n\n```\nfromSource :: SourceLike -> FileSet\n```\n\n# Examples\n:::{.example}\n## `lib.fileset.fromSource` usage example\n\n```nix\n# There's no cleanSource-like function for file sets yet,\n# but we can just convert cleanSource to a file set and use it that way\ntoSource {\n  root = ./.;\n  fileset = fromSource (lib.sources.cleanSource ./.);\n}\n\n# Keeping a previous sourceByRegex (which could be migrated to `lib.fileset.unions`),\n# but removing a subdirectory using file set functions\ndifference\n  (fromSource (lib.sources.sourceByRegex ./. [\n    \"^README\\.md$\"\n    # This regex includes everything in ./doc\n    \"^doc(/.*)?$\"\n  ])\n  ./doc/generated\n\n# Use cleanSource, but limit it to only include ./Makefile and files under ./src\nintersection\n  (fromSource (lib.sources.cleanSource ./.))\n  (unions [\n    ./Makefile\n    ./src\n  ]);\n```\n\n:::\n",
  "lib.fileset.gitTracked": "\nCreate a file set containing all [Git-tracked files](https://git-scm.com/book/en/v2/Git-Basics-Recording-Changes-to-the-Repository) in a repository.\n\nThis function behaves like [`gitTrackedWith { }`](#function-library-lib.fileset.gitTrackedWith) - using the defaults.\n\n# Inputs\n\n`path`\n\n: The [path](https://nixos.org/manual/nix/stable/language/values#type-path) to the working directory of a local Git repository.\n  This directory must contain a `.git` file or subdirectory.\n\n# Type\n\n```\ngitTracked :: Path -> FileSet\n```\n\n# Examples\n:::{.example}\n## `lib.fileset.gitTracked` usage example\n\n```nix\n# Include all files tracked by the Git repository in the current directory\ngitTracked ./.\n\n# Include only files tracked by the Git repository in the parent directory\n# that are also in the current directory\nintersection ./. (gitTracked ../.)\n```\n\n:::\n",
  "lib.fileset.gitTrackedWith": "\nCreate a file set containing all [Git-tracked files](https://git-scm.com/book/en/v2/Git-Basics-Recording-Changes-to-the-Repository) in a repository.\nThe first argument allows configuration with an attribute set,\nwhile the second argument is the path to the Git working tree.\n\n`gitTrackedWith` does not perform any filtering when the path is a [Nix store path](https://nixos.org/manual/nix/stable/store/store-path.html#store-path) and not a repository.\nIn this way, it accommodates the use case where the expression that makes the `gitTracked` call does not reside in an actual git repository anymore,\nand has presumably already been fetched in a way that excludes untracked files.\nFetchers with such equivalent behavior include `builtins.fetchGit`, `builtins.fetchTree` (experimental), and `pkgs.fetchgit` when used without `leaveDotGit`.\n\nIf you don't need the configuration,\nyou can use [`gitTracked`](#function-library-lib.fileset.gitTracked) instead.\n\nThis is equivalent to the result of [`unions`](#function-library-lib.fileset.unions) on all files returned by [`git ls-files`](https://git-scm.com/docs/git-ls-files)\n(which uses [`--cached`](https://git-scm.com/docs/git-ls-files#Documentation/git-ls-files.txt--c) by default).\n\n:::{.warning}\nCurrently this function is based on [`builtins.fetchGit`](https://nixos.org/manual/nix/stable/language/builtins.html#builtins-fetchGit)\nAs such, this function causes all Git-tracked files to be unnecessarily added to the Nix store,\nwithout being re-usable by [`toSource`](#function-library-lib.fileset.toSource).\n\nThis may change in the future.\n:::\n\n# Inputs\n\n`options` (attribute set)\n: `recurseSubmodules` (optional, default: `false`)\n  : Whether to recurse into [Git submodules](https://git-scm.com/book/en/v2/Git-Tools-Submodules) to also include their tracked files.\n    If `true`, this is equivalent to passing the [--recurse-submodules](https://git-scm.com/docs/git-ls-files#Documentation/git-ls-files.txt---recurse-submodules) flag to `git ls-files`.\n\n  `path`\n  : The [path](https://nixos.org/manual/nix/stable/language/values#type-path) to the working directory of a local Git repository.\n    This directory must contain a `.git` file or subdirectory.\n\n# Type\n\n```\ngitTrackedWith :: { recurseSubmodules :: Bool ? false } -> Path -> FileSet\n```\n\n# Examples\n:::{.example}\n## `lib.fileset.gitTrackedWith` usage example\n\n```nix\n# Include all files tracked by the Git repository in the current directory\n# and any submodules under it\ngitTracked { recurseSubmodules = true; } ./.\n```\n\n:::\n",
  "lib.fileset.intersection": "\nThe file set containing all files that are in both of two given file sets.\nSee also [Intersection (set theory)](https://en.wikipedia.org/wiki/Intersection_(set_theory)).\n\nThe given file sets are evaluated as lazily as possible,\nwith the first argument being evaluated first if needed.\n\n# Inputs\n\n`fileset1`\n\n: The first file set. This argument can also be a path, which gets [implicitly coerced to a file set](#sec-fileset-path-coercion).\n\n`fileset2`\n\n: The second file set. This argument can also be a path, which gets [implicitly coerced to a file set](#sec-fileset-path-coercion).\n\n# Type\n\n```\nintersection :: FileSet -> FileSet -> FileSet\n```\n\n# Examples\n:::{.example}\n## `lib.fileset.intersection` usage example\n\n```nix\n# Limit the selected files to the ones in ./., so only ./src and ./Makefile\nintersection ./. (unions [ ../LICENSE ./src ./Makefile ])\n```\n\n:::\n",
  "lib.fileset.maybeMissing": "\nCreate a file set from a path that may or may not exist:\n- If the path does exist, the path is [coerced to a file set](#sec-fileset-path-coercion).\n- If the path does not exist, a file set containing no files is returned.\n\n# Inputs\n\n`path`\n\n: 1\\. Function argument\n\n# Type\n\n```\nmaybeMissing :: Path -> FileSet\n```\n\n# Examples\n:::{.example}\n## `lib.fileset.maybeMissing` usage example\n\n```nix\n# All files in the current directory, but excluding main.o if it exists\ndifference ./. (maybeMissing ./main.o)\n```\n\n:::\n",
  "lib.fileset.toList": "\nThe list of file paths contained in the given file set.\n\n:::{.note}\nThis function is strict in the entire file set.\nThis is in contrast with combinators [`lib.fileset.union`](#function-library-lib.fileset.union),\n[`lib.fileset.intersection`](#function-library-lib.fileset.intersection) and [`lib.fileset.difference`](#function-library-lib.fileset.difference).\n\nThus it is recommended to call `toList` on file sets created using the combinators,\ninstead of doing list processing on the result of `toList`.\n:::\n\nThe resulting list of files can be turned back into a file set using [`lib.fileset.unions`](#function-library-lib.fileset.unions).\n\n# Inputs\n\n`fileset`\n\n: The file set whose file paths to return. This argument can also be a path, which gets [implicitly coerced to a file set](#sec-fileset-path-coercion).\n\n# Type\n\n```\ntoList :: FileSet -> [ Path ]\n```\n\n# Examples\n:::{.example}\n## `lib.fileset.toList` usage example\n\n```nix\ntoList ./.\n[ ./README.md ./Makefile ./src/main.c ./src/main.h ]\n\ntoList (difference ./. ./src)\n[ ./README.md ./Makefile ]\n```\n\n:::\n",
  "lib.fileset.toSource": "\nAdd the local files contained in `fileset` to the store as a single [store path](https://nixos.org/manual/nix/stable/glossary#gloss-store-path) rooted at `root`.\n\nThe result is the store path as a string-like value, making it usable e.g. as the `src` of a derivation, or in string interpolation:\n```nix\nstdenv.mkDerivation {\n  src = lib.fileset.toSource { ... };\n  # ...\n}\n```\n\nThe name of the store path is always `source`.\n\n# Inputs\n\nTakes an attribute set with the following attributes\n\n`root` (Path; _required_)\n\n: The local directory [path](https://nixos.org/manual/nix/stable/language/values.html#type-path) that will correspond to the root of the resulting store path.\n  Paths in [strings](https://nixos.org/manual/nix/stable/language/values.html#type-string), including Nix store paths, cannot be passed as `root`.\n  `root` has to be a directory.\n\n  :::{.note}\n  Changing `root` only affects the directory structure of the resulting store path, it does not change which files are added to the store.\n  The only way to change which files get added to the store is by changing the `fileset` attribute.\n  :::\n\n`fileset` (FileSet; _required_)\n\n: The file set whose files to import into the store.\n  File sets can be created using other functions in this library.\n  This argument can also be a path,\n  which gets [implicitly coerced to a file set](#sec-fileset-path-coercion).\n\n  :::{.note}\n  If a directory does not recursively contain any file, it is omitted from the store path contents.\n  :::\n\n# Type\n\n```\ntoSource :: {\n  root :: Path,\n  fileset :: FileSet,\n} -> SourceLike\n```\n\n# Examples\n:::{.example}\n## `lib.fileset.toSource` usage example\n\n```nix\n# Import the current directory into the store\n# but only include files under ./src\ntoSource {\n  root = ./.;\n  fileset = ./src;\n}\n=> \"/nix/store/...-source\"\n\n# Import the current directory into the store\n# but only include ./Makefile and all files under ./src\ntoSource {\n  root = ./.;\n  fileset = union\n    ./Makefile\n    ./src;\n}\n=> \"/nix/store/...-source\"\n\n# Trying to include a file outside the root will fail\ntoSource {\n  root = ./.;\n  fileset = unions [\n    ./Makefile\n    ./src\n    ../LICENSE\n  ];\n}\n=> <error>\n\n# The root needs to point to a directory that contains all the files\ntoSource {\n  root = ../.;\n  fileset = unions [\n    ./Makefile\n    ./src\n    ../LICENSE\n  ];\n}\n=> \"/nix/store/...-source\"\n\n# The root has to be a local filesystem path\ntoSource {\n  root = \"/nix/store/...-source\";\n  fileset = ./.;\n}\n=> <error>\n```\n\n:::\n",
  "lib.fileset.trace": "\nIncrementally evaluate and trace a file set in a pretty way.\nThis function is only intended for debugging purposes.\nThe exact tracing format is unspecified and may change.\n\nThis function takes a final argument to return.\nIn comparison, [`traceVal`](#function-library-lib.fileset.traceVal) returns\nthe given file set argument.\n\nThis variant is useful for tracing file sets in the Nix repl.\n\n# Inputs\n\n`fileset`\n\n: The file set to trace.\n\n  This argument can also be a path,\n  which gets [implicitly coerced to a file set](#sec-fileset-path-coercion).\n\n`val`\n\n: The value to return.\n\n# Type\n\n```\ntrace :: FileSet -> Any -> Any\n```\n\n# Examples\n:::{.example}\n## `lib.fileset.trace` usage example\n\n```nix\ntrace (unions [ ./Makefile ./src ./tests/run.sh ]) null\n=>\ntrace: /home/user/src/myProject\ntrace: - Makefile (regular)\ntrace: - src (all files in directory)\ntrace: - tests\ntrace:   - run.sh (regular)\nnull\n```\n\n:::\n",
  "lib.fileset.traceVal": "\nIncrementally evaluate and trace a file set in a pretty way.\nThis function is only intended for debugging purposes.\nThe exact tracing format is unspecified and may change.\n\nThis function returns the given file set.\nIn comparison, [`trace`](#function-library-lib.fileset.trace) takes another argument to return.\n\nThis variant is useful for tracing file sets passed as arguments to other functions.\n\n# Inputs\n\n`fileset`\n\n: The file set to trace and return.\n\n  This argument can also be a path,\n  which gets [implicitly coerced to a file set](#sec-fileset-path-coercion).\n\n# Type\n\n```\ntraceVal :: FileSet -> FileSet\n```\n\n# Examples\n:::{.example}\n## `lib.fileset.traceVal` usage example\n\n```nix\ntoSource {\n  root = ./.;\n  fileset = traceVal (unions [\n    ./Makefile\n    ./src\n    ./tests/run.sh\n  ]);\n}\n=>\ntrace: /home/user/src/myProject\ntrace: - Makefile (regular)\ntrace: - src (all files in directory)\ntrace: - tests\ntrace:   - run.sh (regular)\n\"/nix/store/...-source\"\n```\n\n:::\n",
  "lib.fileset.union": "\nThe file set containing all files that are in either of two given file sets.\nThis is the same as [`unions`](#function-library-lib.fileset.unions),\nbut takes just two file sets instead of a list.\nSee also [Union (set theory)](https://en.wikipedia.org/wiki/Union_(set_theory)).\n\nThe given file sets are evaluated as lazily as possible,\nwith the first argument being evaluated first if needed.\n\n# Inputs\n\n`fileset1`\n\n: The first file set. This argument can also be a path, which gets [implicitly coerced to a file set](#sec-fileset-path-coercion).\n\n`fileset2`\n\n: The second file set. This argument can also be a path, which gets [implicitly coerced to a file set](#sec-fileset-path-coercion).\n\n# Type\n\n```\nunion :: FileSet -> FileSet -> FileSet\n```\n\n# Examples\n:::{.example}\n## `lib.fileset.union` usage example\n\n```nix\n# Create a file set containing the file `Makefile`\n# and all files recursively in the `src` directory\nunion ./Makefile ./src\n\n# Create a file set containing the file `Makefile`\n# and the LICENSE file from the parent directory\nunion ./Makefile ../LICENSE\n```\n\n:::\n",
  "lib.fileset.unions": "\nThe file set containing all files that are in any of the given file sets.\nThis is the same as [`union`](#function-library-lib.fileset.unions),\nbut takes a list of file sets instead of just two.\nSee also [Union (set theory)](https://en.wikipedia.org/wiki/Union_(set_theory)).\n\nThe given file sets are evaluated as lazily as possible,\nwith earlier elements being evaluated first if needed.\n\n# Inputs\n\n`filesets`\n\n: A list of file sets. The elements can also be paths, which get [implicitly coerced to file sets](#sec-fileset-path-coercion).\n\n# Type\n\n```\nunions :: [ FileSet ] -> FileSet\n```\n\n# Examples\n:::{.example}\n## `lib.fileset.unions` usage example\n\n```nix\n# Create a file set containing selected files\nunions [\n  # Include the single file `Makefile` in the current directory\n  # This errors if the file doesn't exist\n  ./Makefile\n\n  # Recursively include all files in the `src/code` directory\n  # If this directory is empty this has no effect\n  ./src/code\n\n  # Include the files `run.sh` and `unit.c` from the `tests` directory\n  ./tests/run.sh\n  ./tests/unit.c\n\n  # Include the `LICENSE` file from the parent directory\n  ../LICENSE\n]\n```\n\n:::\n",
  "lib.filesystem.haskellPathsInDir": "\nA map of all haskell packages defined in the given path,\nidentified by having a cabal file with the same name as the\ndirectory itself.\n\n\n# Inputs\n\n`root`\n\n: The directory within to search\n\n# Type\n\n```\nPath -> Map String Path\n```\n",
  "lib.filesystem.listFilesRecursive": "\nGiven a directory, return a flattened list of all files within it recursively.\n\n\n# Inputs\n\n`dir`\n\n: The path to recursively list\n\n# Type\n\n```\nPath -> [ Path ]\n```\n",
  "lib.filesystem.locateDominatingFile": "\nFind the first directory containing a file matching 'pattern'\nupward from a given 'file'.\nReturns 'null' if no directories contain a file matching 'pattern'.\n\n\n# Inputs\n\n`pattern`\n\n: The pattern to search for\n\n`file`\n\n: The file to start searching upward from\n\n# Type\n\n```\nRegExp -> Path -> Nullable { path : Path; matches : [ MatchResults ]; }\n```\n",
  "lib.filesystem.packagesFromDirectoryRecursive": "\nTransform a directory tree containing package files suitable for\n`callPackage` into a matching nested attribute set of derivations.\n\nFor a directory tree like this:\n\n```\nmy-packages\n├── a.nix\n├── b.nix\n├── c\n│  ├── my-extra-feature.patch\n│  ├── package.nix\n│  └── support-definitions.nix\n└── my-namespace\n   ├── d.nix\n   ├── e.nix\n   └── f\n      └── package.nix\n```\n\n`packagesFromDirectoryRecursive` will produce an attribute set like this:\n\n```nix\n# packagesFromDirectoryRecursive {\n#   callPackage = pkgs.callPackage;\n#   directory = ./my-packages;\n# }\n{\n  a = pkgs.callPackage ./my-packages/a.nix { };\n  b = pkgs.callPackage ./my-packages/b.nix { };\n  c = pkgs.callPackage ./my-packages/c/package.nix { };\n  my-namespace = {\n    d = pkgs.callPackage ./my-packages/my-namespace/d.nix { };\n    e = pkgs.callPackage ./my-packages/my-namespace/e.nix { };\n    f = pkgs.callPackage ./my-packages/my-namespace/f/package.nix { };\n  };\n}\n```\n\nIn particular:\n- If the input directory contains a `package.nix` file, then\n  `callPackage <directory>/package.nix { }` is returned.\n- Otherwise, the input directory's contents are listed and transformed into\n  an attribute set.\n  - If a file name has the `.nix` extension, it is turned into attribute\n    where:\n    - The attribute name is the file name without the `.nix` extension\n    - The attribute value is `callPackage <file path> { }`\n  - Other files are ignored.\n  - Directories are turned into an attribute where:\n    - The attribute name is the name of the directory\n    - The attribute value is the result of calling\n      `packagesFromDirectoryRecursive { ... }` on the directory.\n\n    As a result, directories with no `.nix` files (including empty\n    directories) will be transformed into empty attribute sets.\n\n# Type\n\n```\npackagesFromDirectoryRecursive :: {\n  callPackage :: Path -> {} -> a,\n  directory :: Path,\n  ...\n} -> AttrSet\n```\n\n# Inputs\n\n`callPackage`\n: The function used to convert a Nix file's path into a leaf of the attribute set.\n  It is typically the `callPackage` function, taken from either `pkgs` or a new scope corresponding to the `directory`.\n\n`directory`\n: The directory to read package files from.\n\n\n# Examples\n:::{.example}\n## Basic use of `lib.packagesFromDirectoryRecursive`\n\n```nix\npackagesFromDirectoryRecursive {\n  inherit (pkgs) callPackage;\n  directory = ./my-packages;\n}\n=> { ... }\n```\n\nIn this case, `callPackage` will only search `pkgs` for a file's input parameters.\nIn other words, a file cannot refer to another file in the directory in its input parameters.\n:::\n\n::::{.example}\n## Create a scope for the nix files found in a directory\n```nix\nlib.makeScope pkgs.newScope (\n  self: packagesFromDirectoryRecursive {\n    inherit (self) callPackage;\n    directory = ./my-packages;\n  }\n)\n=> { ... }\n```\n\nFor example, take the following directory structure:\n```\nmy-packages\n├── a.nix    → { b }: assert b ? b1; ...\n└── b\n   ├── b1.nix  → { a }: ...\n   └── b2.nix\n```\n\nHere, `b1.nix` can specify `{ a }` as a parameter, which `callPackage` will resolve as expected.\nLikewise, `a.nix` receive an attrset corresponding to the contents of the `b` directory.\n\n:::{.note}\n`a.nix` cannot directly take as inputs packages defined in a child directory, such as `b1`.\n:::\n\n:::{.warning}\nAs of now, `lib.packagesFromDirectoryRecursive` cannot create nested scopes for sub-directories.\n\nIn particular, files under `b/` can only require (as inputs) other files under `my-packages`,\nbut not to those in the same directory, nor those in a parent directory; e.g, `b2.nix` cannot directly\nrequire `b1`.\n:::\n::::\n",
  "lib.filesystem.pathIsDirectory": "\nWhether a path exists and is a directory.\n\n\n# Inputs\n\n`path`\n\n: 1\\. Function argument\n\n# Type\n\n```\npathIsDirectory :: Path -> Bool\n```\n\n# Examples\n:::{.example}\n## `lib.filesystem.pathIsDirectory` usage example\n\n```nix\npathIsDirectory /.\n=> true\n\npathIsDirectory /this/does/not/exist\n=> false\n\npathIsDirectory /some/file.nix\n=> false\n```\n\n:::\n",
  "lib.filesystem.pathIsRegularFile": "\nWhether a path exists and is a regular file, meaning not a symlink or any other special file type.\n\n\n# Inputs\n\n`path`\n\n: 1\\. Function argument\n\n# Type\n\n```\npathIsRegularFile :: Path -> Bool\n```\n\n# Examples\n:::{.example}\n## `lib.filesystem.pathIsRegularFile` usage example\n\n```nix\npathIsRegularFile /.\n=> false\n\npathIsRegularFile /this/does/not/exist\n=> false\n\npathIsRegularFile /some/file.nix\n=> true\n```\n\n:::\n",
  "lib.filesystem.pathType": "\nThe type of a path. The path needs to exist and be accessible.\nThe result is either \"directory\" for a directory, \"regular\" for a regular file, \"symlink\" for a symlink, or \"unknown\" for anything else.\n\n# Inputs\n\npath\n\n: The path to query\n\n# Type\n\n```\npathType :: Path -> String\n```\n\n# Examples\n:::{.example}\n## `lib.filesystem.pathType` usage example\n\n```nix\npathType /.\n=> \"directory\"\n\npathType /some/file.nix\n=> \"regular\"\n```\n\n:::\n",
  "lib.fixedPoints.composeExtensions": "\nCompose two overlay functions and return a single overlay function that combines them.\nFor more details see: [composeManyExtensions](#function-library-lib.fixedPoints.composeManyExtensions).\n",
  "lib.fixedPoints.composeManyExtensions": "\nComposes a list of [`overlays`](#chap-overlays) and returns a single overlay function that combines them.\n\n:::{.note}\nThe result is produced by using the update operator `//`.\nThis means nested values of previous overlays are not merged recursively.\nIn other words, previously defined attributes are replaced, ignoring the previous value, unless referenced by the overlay; for example `final: prev: { foo = final.foo + 1; }`.\n:::\n\n# Inputs\n\n`extensions`\n\n: A list of overlay functions\n  :::{.note}\n  The order of the overlays in the list is important.\n  :::\n\n: Each overlay function takes two arguments, by convention `final` and `prev`, and returns an attribute set.\n  - `final` is the result of the fixed-point function, with all overlays applied.\n  - `prev` is the result of the previous overlay function(s).\n\n# Type\n\n```\n# Pseudo code\nlet\n  #               final      prev\n  #                 ↓          ↓\n  OverlayFn = { ... } -> { ... } -> { ... };\nin\n  composeManyExtensions :: ListOf OverlayFn -> OverlayFn\n```\n\n# Examples\n:::{.example}\n## `lib.fixedPoints.composeManyExtensions` usage example\n\n```nix\nlet\n  # The \"original function\" that is extended by the overlays.\n  # Note that it doesn't have prev: as argument since no overlay function precedes it.\n  original = final: { a = 1; };\n\n  # Each overlay function has 'final' and 'prev' as arguments.\n  overlayA = final: prev: { b = final.c; c = 3; };\n  overlayB = final: prev: { c = 10; x = prev.c or 5; };\n\n  extensions = composeManyExtensions [ overlayA overlayB ];\n\n  # Caluculate the fixed point of all composed overlays.\n  fixedpoint = lib.fix (lib.extends extensions original );\n\nin fixedpoint\n=>\n{\n  a = 1;\n  b = 10;\n  c = 10;\n  x = 3;\n}\n```\n:::\n",
  "lib.fixedPoints.converge": "\nReturn the fixpoint that `f` converges to when called iteratively, starting\nwith the input `x`.\n\n```\nnix-repl> converge (x: x / 2) 16\n0\n```\n\n# Inputs\n\n`f`\n\n: 1\\. Function argument\n\n`x`\n\n: 2\\. Function argument\n\n# Type\n\n```\n(a -> a) -> a -> a\n```\n",
  "lib.fixedPoints.extends": "\nExtend a function using an overlay.\n\nOverlays allow modifying and extending fixed-point functions, specifically ones returning attribute sets.\nA fixed-point function is a function which is intended to be evaluated by passing the result of itself as the argument.\nThis is possible due to Nix's lazy evaluation.\n\nA fixed-point function returning an attribute set has the form\n\n```nix\nfinal: {\n  # attributes\n}\n```\n\nwhere `final` refers to the lazily evaluated attribute set returned by the fixed-point function.\n\nAn overlay to such a fixed-point function has the form\n\n```nix\nfinal: prev: {\n  # attributes\n}\n```\n\nwhere `prev` refers to the result of the original function to `final`, and `final` is the result of the composition of the overlay and the original function.\n\nApplying an overlay is done with `extends`:\n\n```nix\nlet\n  f = final: {\n    # attributes\n  };\n  overlay = final: prev: {\n    # attributes\n  };\nin extends overlay f;\n```\n\nTo get the value of `final`, use `lib.fix`:\n\n```nix\nlet\n  f = final: {\n    # attributes\n  };\n  overlay = final: prev: {\n    # attributes\n  };\n  g = extends overlay f;\nin fix g\n```\n\n:::{.note}\nThe argument to the given fixed-point function after applying an overlay will *not* refer to its own return value, but rather to the value after evaluating the overlay function.\n\nThe given fixed-point function is called with a separate argument than if it was evaluated with `lib.fix`.\n:::\n\n:::{.example}\n\n# Extend a fixed-point function with an overlay\n\nDefine a fixed-point function `f` that expects its own output as the argument `final`:\n\n```nix-repl\nf = final: {\n  # Constant value a\n  a = 1;\n\n  # b depends on the final value of a, available as final.a\n  b = final.a + 2;\n}\n```\n\nEvaluate this using [`lib.fix`](#function-library-lib.fixedPoints.fix) to get the final result:\n\n```nix-repl\nfix f\n=> { a = 1; b = 3; }\n```\n\nAn overlay represents a modification or extension of such a fixed-point function.\nHere's an example of an overlay:\n\n```nix-repl\noverlay = final: prev: {\n  # Modify the previous value of a, available as prev.a\n  a = prev.a + 10;\n\n  # Extend the attribute set with c, letting it depend on the final values of a and b\n  c = final.a + final.b;\n}\n```\n\nUse `extends overlay f` to apply the overlay to the fixed-point function `f`.\nThis produces a new fixed-point function `g` with the combined behavior of `f` and `overlay`:\n\n```nix-repl\ng = extends overlay f\n```\n\nThe result is a function, so we can't print it directly, but it's the same as:\n\n```nix-repl\ng' = final: {\n  # The constant from f, but changed with the overlay\n  a = 1 + 10;\n\n  # Unchanged from f\n  b = final.a + 2;\n\n  # Extended in the overlay\n  c = final.a + final.b;\n}\n```\n\nEvaluate this using [`lib.fix`](#function-library-lib.fixedPoints.fix) again to get the final result:\n\n```nix-repl\nfix g\n=> { a = 11; b = 13; c = 24; }\n```\n:::\n\n# Inputs\n\n`overlay`\n\n: The overlay to apply to the fixed-point function\n\n`f`\n\n: The fixed-point function\n\n# Type\n\n```\nextends :: (Attrs -> Attrs -> Attrs) # The overlay to apply to the fixed-point function\n        -> (Attrs -> Attrs) # A fixed-point function\n        -> (Attrs -> Attrs) # The resulting fixed-point function\n```\n\n# Examples\n:::{.example}\n## `lib.fixedPoints.extends` usage example\n\n```nix\nf = final: { a = 1; b = final.a + 2; }\n\nfix f\n=> { a = 1; b = 3; }\n\nfix (extends (final: prev: { a = prev.a + 10; }) f)\n=> { a = 11; b = 13; }\n\nfix (extends (final: prev: { b = final.a + 5; }) f)\n=> { a = 1; b = 6; }\n\nfix (extends (final: prev: { c = final.a + final.b; }) f)\n=> { a = 1; b = 3; c = 4; }\n```\n\n:::\n",
  "lib.fixedPoints.fix": "\n`fix f` computes the fixed point of the given function `f`. In other words, the return value is `x` in `x = f x`.\n\n`f` must be a lazy function.\nThis means that `x` must be a value that can be partially evaluated,\nsuch as an attribute set, a list, or a function.\nThis way, `f` can use one part of `x` to compute another part.\n\n**Relation to syntactic recursion**\n\nThis section explains `fix` by refactoring from syntactic recursion to a call of `fix` instead.\n\nFor context, Nix lets you define attributes in terms of other attributes syntactically using the [`rec { }` syntax](https://nixos.org/manual/nix/stable/language/constructs.html#recursive-sets).\n\n```nix\nnix-repl> rec {\n  foo = \"foo\";\n  bar = \"bar\";\n  foobar = foo + bar;\n}\n{ bar = \"bar\"; foo = \"foo\"; foobar = \"foobar\"; }\n```\n\nThis is convenient when constructing a value to pass to a function for example,\nbut an equivalent effect can be achieved with the `let` binding syntax:\n\n```nix\nnix-repl> let self = {\n  foo = \"foo\";\n  bar = \"bar\";\n  foobar = self.foo + self.bar;\n}; in self\n{ bar = \"bar\"; foo = \"foo\"; foobar = \"foobar\"; }\n```\n\nBut in general you can get more reuse out of `let` bindings by refactoring them to a function.\n\n```nix\nnix-repl> f = self: {\n  foo = \"foo\";\n  bar = \"bar\";\n  foobar = self.foo + self.bar;\n}\n```\n\nThis is where `fix` comes in, it contains the syntactic recursion that's not in `f` anymore.\n\n```nix\nnix-repl> fix = f:\n  let self = f self; in self;\n```\n\nBy applying `fix` we get the final result.\n\n```nix\nnix-repl> fix f\n{ bar = \"bar\"; foo = \"foo\"; foobar = \"foobar\"; }\n```\n\nSuch a refactored `f` using `fix` is not useful by itself.\nSee [`extends`](#function-library-lib.fixedPoints.extends) for an example use case.\nThere `self` is also often called `final`.\n\n# Inputs\n\n`f`\n\n: 1\\. Function argument\n\n# Type\n\n```\nfix :: (a -> a) -> a\n```\n\n# Examples\n:::{.example}\n## `lib.fixedPoints.fix` usage example\n\n```nix\nfix (self: { foo = \"foo\"; bar = \"bar\"; foobar = self.foo + self.bar; })\n=> { bar = \"bar\"; foo = \"foo\"; foobar = \"foobar\"; }\n\nfix (self: [ 1 2 (elemAt self 0 + elemAt self 1) ])\n=> [ 1 2 3 ]\n```\n\n:::\n",
  "lib.fixedPoints.fix' (Prime)": "\nA variant of `fix` that records the original recursive attribute set in the\nresult, in an attribute named `__unfix__`.\n\nThis is useful in combination with the `extends` function to\nimplement deep overriding.\n\n# Inputs\n\n`f`\n\n: 1\\. Function argument\n",
  "lib.fixedPoints.makeExtensible": "\nCreate an overridable, recursive attribute set. For example:\n\n```\nnix-repl> obj = makeExtensible (final: { })\n\nnix-repl> obj\n{ __unfix__ = «lambda»; extend = «lambda»; }\n\nnix-repl> obj = obj.extend (final: prev: { foo = \"foo\"; })\n\nnix-repl> obj\n{ __unfix__ = «lambda»; extend = «lambda»; foo = \"foo\"; }\n\nnix-repl> obj = obj.extend (final: prev: { foo = prev.foo + \" + \"; bar = \"bar\"; foobar = final.foo + final.bar; })\n\nnix-repl> obj\n{ __unfix__ = «lambda»; bar = \"bar\"; extend = «lambda»; foo = \"foo + \"; foobar = \"foo + bar\"; }\n```\n",
  "lib.fixedPoints.makeExtensibleWithCustomName": "\nSame as `makeExtensible` but the name of the extending attribute is\ncustomized.\n\n# Inputs\n\n`extenderName`\n\n: 1\\. Function argument\n\n`rattrs`\n\n: 2\\. Function argument\n",
  "lib.fixedPoints.toExtension": "\nConvert to an extending function (overlay).\n\n`toExtension` is the `toFunction` for extending functions (a.k.a. extensions or overlays).\nIt converts a non-function or a single-argument function to an extending function,\nwhile returning a two-argument function as-is.\n\nThat is, it takes a value of the shape `x`, `prev: x`, or `final: prev: x`,\nand returns `final: prev: x`, assuming `x` is not a function.\n\nThis function takes care of the input to `stdenv.mkDerivation`'s\n`overrideAttrs` function.\nIt bridges the gap between `<pkg>.overrideAttrs`\nbefore and after the overlay-style support.\n\n# Inputs\n\n`f`\n: The function or value to convert to an extending function.\n\n# Type\n\n```\ntoExtension ::\n  b' -> Any -> Any -> b'\nor\ntoExtension ::\n  (a -> b') -> Any -> a -> b'\nor\ntoExtension ::\n  (a -> a -> b) -> a -> a -> b\nwhere b' = ! Callable\n\nSet a = b = b' = AttrSet & ! Callable to make toExtension return an extending function.\n```\n\n# Examples\n:::{.example}\n## `lib.fixedPoints.toExtension` usage example\n\n```nix\nfix (final: { a = 0; c = final.a; })\n=> { a = 0; c = 0; };\n\nfix (extends (toExtension { a = 1; b = 2; }) (final: { a = 0; c = final.a; }))\n=> { a = 1; b = 2; c = 1; };\n\nfix (extends (toExtension (prev: { a = 1; b = prev.a; })) (final: { a = 0; c = final.a; }))\n=> { a = 1; b = 0; c = 1; };\n\nfix (extends (toExtension (final: prev: { a = 1; b = prev.a; c = final.a + 1 })) (final: { a = 0; c = final.a; }))\n=> { a = 1; b = 0; c = 2; };\n```\n:::\n",
  "lib.generators.mkDconfKeyValue": "\nmkKeyValueDefault wrapper that handles dconf INI quirks.\nThe main differences of the format is that it requires strings to be quoted.\n",
  "lib.generators.mkKeyValueDefault": "\nGenerate a line of key k and value v, separated by\ncharacter sep. If sep appears in k, it is escaped.\nHelper for synaxes with different separators.\n\nmkValueString specifies how values should be formatted.\n\n```nix\nmkKeyValueDefault {} \":\" \"f:oo\" \"bar\"\n> \"f\\:oo:bar\"\n```\n\n# Inputs\n\nStructured function argument\n: mkValueString (optional, default: `mkValueStringDefault {}`)\n  : Function to convert values to strings\n\n`sep`\n\n: 2\\. Function argument\n\n`k`\n\n: 3\\. Function argument\n\n`v`\n\n: 4\\. Function argument\n",
  "lib.generators.mkLuaInline": "\nMark string as Lua expression to be inlined when processed by toLua.\n\n\n# Inputs\n\n`expr`\n\n: 1\\. Function argument\n\n# Type\n\n```\nmkLuaInline :: String -> AttrSet\n```\n",
  "lib.generators.mkValueStringDefault": "\nConvert a value to a sensible default string representation.\nThe builtin `toString` function has some strange defaults,\nsuitable for bash scripts but not much else.\n\n# Inputs\n\nOptions\n: Empty set, there may be configuration options in the future\n\n`v`\n: 2\\. Function argument\n",
  "lib.generators.toDconfINI": "\nGenerates INI in dconf keyfile style. See https://help.gnome.org/admin/system-admin-guide/stable/dconf-keyfiles.html.en\nfor details.\n",
  "lib.generators.toDhall": "\nTranslate a simple Nix expression to Dhall notation.\n\nNote that integers are translated to Integer and never\nthe Natural type.\n\n# Inputs\n\nOptions\n\n: Empty set, there may be configuration options in the future\n\nValue\n\n: The value to be converted to Dhall\n",
  "lib.generators.toGitINI": "\nGenerate a git-config file from an attrset.\n\nIt has two major differences from the regular INI format:\n\n1. values are indented with tabs\n2. sections can have sub-sections\n\nFurther: https://git-scm.com/docs/git-config#EXAMPLES\n\n# Examples\n:::{.example}\n## `lib.generators.toGitINI` usage example\n\n```nix\ngenerators.toGitINI {\n  url.\"ssh://git@github.com/\".insteadOf = \"https://github.com\";\n  user.name = \"edolstra\";\n}\n\n> [url \"ssh://git@github.com/\"]\n>   insteadOf = \"https://github.com\"\n>\n> [user]\n>   name = \"edolstra\"\n```\n\n:::\n\n# Inputs\n\n`attrs`\n\n: Key-value pairs to be converted to a git-config file.\n  See: https://git-scm.com/docs/git-config#_variables for possible values.\n\n",
  "lib.generators.toINI": "\nGenerate an INI-style config file from an\nattrset of sections to an attrset of key-value pairs.\n\n# Inputs\n\nStructured function argument\n\n: mkSectionName (optional, default: `(name: escape [ \"[\" \"]\" ] name)`)\n  : apply transformations (e.g. escapes) to section names\n\n: mkKeyValue (optional, default: `{} \"=\"`)\n  : format a setting line from key and value\n\n: listsAsDuplicateKeys (optional, default: `false`)\n  : allow lists as values for duplicate keys\n\n# Examples\n:::{.example}\n## `lib.generators.toINI` usage example\n\n```nix\ngenerators.toINI {} {\n  foo = { hi = \"${pkgs.hello}\"; ciao = \"bar\"; };\n  baz = { \"also, integers\" = 42; };\n}\n\n> [baz]\n> also, integers=42\n>\n> [foo]\n> ciao=bar\n> hi=/nix/store/y93qql1p5ggfnaqjjqhxcw0vqw95rlz0-hello-2.10\n```\n\nThe mk* configuration attributes can generically change\nthe way sections and key-value strings are generated.\n\nFor more examples see the test cases in ./tests/misc.nix.\n\n:::\n",
  "lib.generators.toINIWithGlobalSection": "\nGenerate an INI-style config file from an attrset\nspecifying the global section (no header), and an\nattrset of sections to an attrset of key-value pairs.\n\n# Inputs\n\n1\\. Structured function argument\n\n: mkSectionName (optional, default: `(name: escape [ \"[\" \"]\" ] name)`)\n  : apply transformations (e.g. escapes) to section names\n\n: mkKeyValue (optional, default: `{} \"=\"`)\n  : format a setting line from key and value\n\n: listsAsDuplicateKeys (optional, default: `false`)\n  : allow lists as values for duplicate keys\n\n2\\. Structured function argument\n\n: globalSection (required)\n  : global section key-value pairs\n\n: sections (optional, default: `{}`)\n  : attrset of sections to key-value pairs\n\n# Examples\n:::{.example}\n## `lib.generators.toINIWithGlobalSection` usage example\n\n```nix\ngenerators.toINIWithGlobalSection {} {\n  globalSection = {\n    someGlobalKey = \"hi\";\n  };\n  sections = {\n    foo = { hi = \"${pkgs.hello}\"; ciao = \"bar\"; };\n    baz = { \"also, integers\" = 42; };\n}\n\n> someGlobalKey=hi\n>\n> [baz]\n> also, integers=42\n>\n> [foo]\n> ciao=bar\n> hi=/nix/store/y93qql1p5ggfnaqjjqhxcw0vqw95rlz0-hello-2.10\n```\n\nThe mk* configuration attributes can generically change\nthe way sections and key-value strings are generated.\n\nFor more examples see the test cases in ./tests/misc.nix.\n\n:::\n\nIf you don’t need a global section, you can also use\n`generators.toINI` directly, which only takes\nthe part in `sections`.\n",
  "lib.generators.toJSON": "\nGenerates JSON from an arbitrary (non-function) value.\nFor more information see the documentation of the builtin.\n\n# Inputs\n\nOptions\n\n: Empty set, there may be configuration options in the future\n\nValue\n\n: The value to be converted to JSON\n",
  "lib.generators.toKeyValue": "\nGenerate a key-value-style config file from an attrset.\n\n# Inputs\n\nStructured function argument\n\n: mkKeyValue (optional, default: `mkKeyValueDefault {} \"=\"`)\n  : format a setting line from key and value\n\n: listsAsDuplicateKeys (optional, default: `false`)\n  : allow lists as values for duplicate keys\n\n: indent (optional, default: `\"\"`)\n  : Initial indentation level\n\n",
  "lib.generators.toLua": "\nTranslate a simple Nix expression to Lua representation with occasional\nLua-inlines that can be constructed by mkLuaInline function.\n\nConfiguration:\n\n* multiline - by default is true which results in indented block-like view.\n* indent - initial indent.\n* asBindings - by default generate single value, but with this use attrset to set global vars.\n\nAttention:\n\nRegardless of multiline parameter there is no trailing newline.\n\n\n# Inputs\n\nStructured function argument\n\n: multiline (optional, default: `true`)\n  : If this option is true, the output is indented with newlines for attribute sets and lists\n: indent (optional, default: `\"\"`)\n  : Initial indentation level\n: asBindings (optional, default: `false`)\n  : Interpret as variable bindings\n\nValue\n\n: The value to be converted to Lua\n\n# Type\n\n```\ntoLua :: AttrSet -> Any -> String\n```\n\n# Examples\n:::{.example}\n## `lib.generators.toLua` usage example\n\n```nix\ngenerators.toLua {}\n  {\n    cmd = [ \"typescript-language-server\" \"--stdio\" ];\n    settings.workspace.library = mkLuaInline ''vim.api.nvim_get_runtime_file(\"\", true)'';\n  }\n->\n {\n   [\"cmd\"] = {\n     \"typescript-language-server\",\n     \"--stdio\"\n   },\n   [\"settings\"] = {\n     [\"workspace\"] = {\n       [\"library\"] = (vim.api.nvim_get_runtime_file(\"\", true))\n     }\n   }\n }\n```\n\n:::\n",
  "lib.generators.toPlist": "\nTranslate a simple Nix expression to [Plist notation](https://en.wikipedia.org/wiki/Property_list).\n\n# Inputs\n\nStructured function argument\n\n: escape (optional, default: `false`)\n  : If this option is true, XML special characters are escaped in string values and keys\n\nValue\n  : The value to be converted to Plist\n",
  "lib.generators.toPretty": "\nPretty print a value, akin to `builtins.trace`.\n\nShould probably be a builtin as well.\n\nThe pretty-printed string should be suitable for rendering default values\nin the NixOS manual. In particular, it should be as close to a valid Nix expression\nas possible.\n\n# Inputs\n\nStructured function argument\n: allowPrettyValues\n  : If this option is true, attrsets like { __pretty = fn; val = …; }\n    will use fn to convert val to a pretty printed representation.\n    (This means fn is type Val -> String.)\n: multiline\n  : If this option is true, the output is indented with newlines for attribute sets and lists\n: indent\n  : Initial indentation level\n\nValue\n: The value to be pretty printed\n",
  "lib.generators.toYAML": "\nYAML has been a strict superset of JSON since 1.2, so we\nuse toJSON. Before it only had a few differences referring\nto implicit typing rules, so it should work with older\nparsers as well.\n\n# Inputs\n\nOptions\n\n: Empty set, there may be configuration options in the future\n\nValue\n\n: The value to be converted to YAML\n",
  "lib.generators.withRecursion": "\nRecurses through a `Value` limited to a certain depth. (`depthLimit`)\n\nIf the depth is exceeded, an error is thrown, unless `throwOnDepthLimit` is set to `false`.\n\n# Inputs\n\nStructured function argument\n\n: depthLimit (required)\n  : If this option is not null, the given value will stop evaluating at a certain depth\n\n: throwOnDepthLimit (optional, default: `true`)\n  : If this option is true, an error will be thrown, if a certain given depth is exceeded\n\nValue\n: The value to be evaluated recursively\n",
  "lib.gvariant.isGVariant": "\nCheck if a value is a GVariant value\n\n# Inputs\n\n`v`\n\n: value to check\n\n# Type\n\n```\nisGVariant :: Any -> Bool\n```\n",
  "lib.gvariant.mkArray": "\nReturns the GVariant array from the given type of the elements and a Nix list.\n\n# Inputs\n\n`elems`\n\n: 1\\. Function argument\n\n# Type\n\n```\nmkArray :: [Any] -> gvariant\n```\n\n# Examples\n:::{.example}\n## `lib.gvariant.mkArray` usage example\n\n```nix\n# Creating a string array\nlib.gvariant.mkArray [ \"a\" \"b\" \"c\" ]\n```\n\n:::\n",
  "lib.gvariant.mkBoolean": "\nReturns the GVariant boolean from the given Nix bool value.\n\n# Inputs\n\n`v`\n\n: 1\\. Function argument\n\n# Type\n\n```\nmkBoolean :: Bool -> gvariant\n```\n",
  "lib.gvariant.mkDictionaryEntry": "\nReturns the GVariant dictionary entry from the given key and value.\n\n# Inputs\n\n`name`\n\n: The key of the entry\n\n`value`\n\n: The value of the entry\n\n# Type\n\n```\nmkDictionaryEntry :: String -> Any -> gvariant\n```\n\n# Examples\n:::{.example}\n## `lib.gvariant.mkDictionaryEntry` usage example\n\n```nix\n# A dictionary describing an Epiphany’s search provider\n[\n  (lib.gvariant.mkDictionaryEntry \"url\" (lib.gvariant.mkVariant \"https://duckduckgo.com/?q=%s&t=epiphany\"))\n  (lib.gvariant.mkDictionaryEntry \"bang\" (lib.gvariant.mkVariant \"!d\"))\n  (lib.gvariant.mkDictionaryEntry \"name\" (lib.gvariant.mkVariant \"DuckDuckGo\"))\n]\n```\n\n:::\n",
  "lib.gvariant.mkDouble": "\nReturns the GVariant double from the given Nix float value.\n\n# Inputs\n\n`v`\n\n: 1\\. Function argument\n\n# Type\n\n```\nmkDouble :: Float -> gvariant\n```\n",
  "lib.gvariant.mkEmptyArray": "\nReturns the GVariant array from the given empty Nix list.\n\n# Inputs\n\n`elemType`\n\n: 1\\. Function argument\n\n# Type\n\n```\nmkEmptyArray :: gvariant.type -> gvariant\n```\n\n# Examples\n:::{.example}\n## `lib.gvariant.mkEmptyArray` usage example\n\n```nix\n# Creating an empty string array\nlib.gvariant.mkEmptyArray (lib.gvariant.type.string)\n```\n\n:::\n",
  "lib.gvariant.mkInt16": "\nReturns the GVariant int16 from the given Nix int value.\n\n# Type\n\n```\nmkInt16 :: Int -> gvariant\n```\n",
  "lib.gvariant.mkInt32": "\nReturns the GVariant int32 from the given Nix int value.\n\n# Inputs\n\n`v`\n\n: 1\\. Function argument\n\n# Type\n\n```\nmkInt32 :: Int -> gvariant\n```\n",
  "lib.gvariant.mkInt64": "\nReturns the GVariant int64 from the given Nix int value.\n\n# Type\n\n```\nmkInt64 :: Int -> gvariant\n```\n",
  "lib.gvariant.mkJust": "\nReturns the GVariant just from the given Nix value.\n\n# Inputs\n\n`elem`\n\n: 1\\. Function argument\n\n# Type\n\n```\nmkJust :: Any -> gvariant\n```\n",
  "lib.gvariant.mkMaybe": "\nReturns the GVariant maybe from the given element type.\n\n# Inputs\n\n`elemType`\n\n: 1\\. Function argument\n\n`elem`\n\n: 2\\. Function argument\n\n# Type\n\n```\nmkMaybe :: gvariant.type -> Any -> gvariant\n```\n",
  "lib.gvariant.mkNothing": "\nReturns the GVariant nothing from the given element type.\n\n# Inputs\n\n`elemType`\n\n: 1\\. Function argument\n\n# Type\n\n```\nmkNothing :: gvariant.type -> gvariant\n```\n",
  "lib.gvariant.mkObjectpath": "\nReturns the GVariant object path from the given Nix string value.\n\n# Inputs\n\n`v`\n\n: 1\\. Function argument\n\n# Type\n\n```\nmkObjectpath :: String -> gvariant\n```\n",
  "lib.gvariant.mkString": "\nReturns the GVariant string from the given Nix string value.\n\n# Inputs\n\n`v`\n\n: 1\\. Function argument\n\n# Type\n\n```\nmkString :: String -> gvariant\n```\n",
  "lib.gvariant.mkTuple": "\nReturns the GVariant tuple from the given Nix list.\n\n# Inputs\n\n`elems`\n\n: 1\\. Function argument\n\n# Type\n\n```\nmkTuple :: [Any] -> gvariant\n```\n",
  "lib.gvariant.mkUchar": "\nReturns the GVariant uchar from the given Nix int value.\n\n# Type\n\n```\nmkUchar :: Int -> gvariant\n```\n",
  "lib.gvariant.mkUint16": "\nReturns the GVariant uint16 from the given Nix int value.\n\n# Type\n\n```\nmkUint16 :: Int -> gvariant\n```\n",
  "lib.gvariant.mkUint32": "\nReturns the GVariant uint32 from the given Nix int value.\n\n# Type\n\n```\nmkUint32 :: Int -> gvariant\n```\n",
  "lib.gvariant.mkUint64": "\nReturns the GVariant uint64 from the given Nix int value.\n\n# Type\n\n```\nmkUint64 :: Int -> gvariant\n```\n",
  "lib.gvariant.mkValue": "\nReturns the GVariant value that most closely matches the given Nix value.\nIf no GVariant value can be found unambiguously then error is thrown.\n\n# Inputs\n\n`v`\n\n: 1\\. Function argument\n\n# Type\n\n```\nmkValue :: Any -> gvariant\n```\n",
  "lib.gvariant.mkVariant": "\nReturns the GVariant variant from the given Nix value. Variants are containers\nof different GVariant type.\n\n# Inputs\n\n`elem`\n\n: 1\\. Function argument\n\n# Type\n\n```\nmkVariant :: Any -> gvariant\n```\n\n# Examples\n:::{.example}\n## `lib.gvariant.mkVariant` usage example\n\n```nix\nlib.gvariant.mkArray [\n  (lib.gvariant.mkVariant \"a string\")\n  (lib.gvariant.mkVariant (lib.gvariant.mkInt32 1))\n]\n```\n\n:::\n",
  "lib.kernel.freeform": null,
  "lib.kernel.option": "Keeping these around in case we decide to change this horrible implementation :)",
  "lib.kernel.whenHelpers": "Common patterns/legacy used in common-config/hardened/config.nix",
  "lib.lists.all": "\nReturn true if function `pred` returns true for all elements of\n`list`.\n\n# Inputs\n\n`pred`\n\n: Predicate\n\n`list`\n\n: Input list\n\n# Type\n\n```\nall :: (a -> bool) -> [a] -> bool\n```\n\n# Examples\n:::{.example}\n## `lib.lists.all` usage example\n\n```nix\nall (x: x < 3) [ 1 2 ]\n=> true\nall (x: x < 3) [ 1 2 3 ]\n=> false\n```\n\n:::\n",
  "lib.lists.allUnique": "\nCheck if list contains only unique elements. O(n^2) complexity.\n\n\n# Inputs\n\n`list`\n\n: 1\\. Function argument\n\n# Type\n\n```\nallUnique :: [a] -> bool\n```\n\n# Examples\n:::{.example}\n## `lib.lists.allUnique` usage example\n\n```nix\nallUnique [ 3 2 3 4 ]\n=> false\nallUnique [ 3 2 4 1 ]\n=> true\n```\n\n:::\n",
  "lib.lists.any": "\nReturn true if function `pred` returns true for at least one\nelement of `list`.\n\n# Inputs\n\n`pred`\n\n: Predicate\n\n`list`\n\n: Input list\n\n# Type\n\n```\nany :: (a -> bool) -> [a] -> bool\n```\n\n# Examples\n:::{.example}\n## `lib.lists.any` usage example\n\n```nix\nany isString [ 1 \"a\" { } ]\n=> true\nany isString [ 1 { } ]\n=> false\n```\n\n:::\n",
  "lib.lists.commonPrefix": "\nThe common prefix of two lists.\n\n\n# Inputs\n\n`list1`\n\n: 1\\. Function argument\n\n`list2`\n\n: 2\\. Function argument\n\n# Type\n\n```\ncommonPrefix :: [a] -> [a] -> [a]\n```\n\n# Examples\n:::{.example}\n## `lib.lists.commonPrefix` usage example\n\n```nix\ncommonPrefix [ 1 2 3 4 5 6 ] [ 1 2 4 8 ]\n=> [ 1 2 ]\ncommonPrefix [ 1 2 3 ] [ 1 2 3 4 5 ]\n=> [ 1 2 3 ]\ncommonPrefix [ 1 2 3 ] [ 4 5 6 ]\n=> [ ]\n```\n\n:::\n",
  "lib.lists.compareLists": "\nCompare two lists element-by-element with a comparison function `cmp`.\n\nList elements are compared pairwise in order by the provided comparison function `cmp`,\nthe first non-equal pair of elements determines the result.\n\n:::{.note}\nThe `<` operator can also be used to compare lists using a boolean condition. (e.g. `[1 2] < [1 3]` is `true`).\nSee also [language operators](https://nix.dev/manual/nix/stable/language/operators#comparison) for more information.\n:::\n\n# Inputs\n\n`cmp`\n\n: The comparison function `a: b: ...` must return:\n  - `0` if `a` and `b` are equal\n  - `1` if `a` is greater than `b`\n  - `-1` if `a` is less than `b`\n\n  See [lib.compare](#function-library-lib.trivial.compare) for a an example implementation.\n\n`a`\n\n: The first list\n\n`b`\n\n: The second list\n\n\n# Examples\n:::{.example}\n## `lib.lists.compareLists` usage examples\n\n```nix\ncompareLists lib.compare [] []\n=> 0\ncompareLists lib.compare [] [ \"a\" ]\n=> -1\ncompareLists lib.compare [ \"a\" ] []\n=> 1\ncompareLists lib.compare [ \"a\" \"b\" ] [ \"a\" \"c\" ]\n=> -1\n```\n\n:::\n",
  "lib.lists.concatLists": "\nConcatenate a list of lists into a single list.\n",
  "lib.lists.concatMap": "\nMap and concatenate the result.\n\n# Type\n\n```\nconcatMap :: (a -> [b]) -> [a] -> [b]\n```\n\n# Examples\n:::{.example}\n## `lib.lists.concatMap` usage example\n\n```nix\nconcatMap (x: [x] ++ [\"z\"]) [\"a\" \"b\"]\n=> [ \"a\" \"z\" \"b\" \"z\" ]\n```\n\n:::\n",
  "lib.lists.count": "\nCount how many elements of `list` match the supplied predicate\nfunction.\n\n# Inputs\n\n`pred`\n\n: Predicate\n\n# Type\n\n```\ncount :: (a -> bool) -> [a] -> int\n```\n\n# Examples\n:::{.example}\n## `lib.lists.count` usage example\n\n```nix\ncount (x: x == 3) [ 3 2 3 4 6 ]\n=> 2\n```\n\n:::\n",
  "lib.lists.crossLists": "\nReturn the image of the cross product of some lists by a function.\n\n\n# Examples\n:::{.example}\n## `lib.lists.crossLists` usage example\n\n```nix\ncrossLists (x: y: \"${toString x}${toString y}\") [[1 2] [3 4]]\n=> [ \"13\" \"14\" \"23\" \"24\" ]\n```\n\nThe following function call is equivalent to the one deprecated above:\n\n```nix\nmapCartesianProduct (x: \"${toString x.a}${toString x.b}\") { a = [1 2]; b = [3 4]; }\n=> [ \"13\" \"14\" \"23\" \"24\" ]\n```\n:::\n",
  "lib.lists.drop": "\nRemove the first (at most) N elements of a list.\n\n\n# Inputs\n\n`count`\n\n: Number of elements to drop\n\n`list`\n\n: Input list\n\n# Type\n\n```\ndrop :: int -> [a] -> [a]\n```\n\n# Examples\n:::{.example}\n## `lib.lists.drop` usage example\n\n```nix\ndrop 2 [ \"a\" \"b\" \"c\" \"d\" ]\n=> [ \"c\" \"d\" ]\ndrop 2 [ ]\n=> [ ]\n```\n\n:::\n",
  "lib.lists.dropEnd": "\nRemove the last (at most) N elements of a list.\n\n\n# Inputs\n\n`count`\n\n: Number of elements to drop\n\n`list`\n\n: Input list\n\n# Type\n\n```\ndropEnd :: Int -> [a] -> [a]\n```\n\n# Examples\n\n:::{.example}\n## `lib.lists.dropEnd` usage example\n\n```nix\n  dropEnd 2 [ \"a\" \"b\" \"c\" \"d\" ]\n  => [ \"a\" \"b\" ]\n  dropEnd 2 [ ]\n  => [ ]\n```\n:::\n\n",
  "lib.lists.elem": "\nReturn `true` if a value equal to *x* occurs in the list *xs*, and\n`false` otherwise.\n",
  "lib.lists.elemAt": "\nReturn element *n* from the list *xs*. Elements are counted starting\nfrom 0. A fatal error occurs if the index is out of bounds.\n",
  "lib.lists.filter": "\nReturn a list consisting of the elements of *list* for which the\nfunction *f* returns `true`.\n",
  "lib.lists.findFirst": "\nFind the first element in the list matching the specified\npredicate or return `default` if no such element exists.\n\n# Inputs\n\n`pred`\n\n: Predicate\n\n`default`\n\n: Default value to return\n\n`list`\n\n: Input list\n\n# Type\n\n```\nfindFirst :: (a -> bool) -> a -> [a] -> a\n```\n\n# Examples\n:::{.example}\n## `lib.lists.findFirst` usage example\n\n```nix\nfindFirst (x: x > 3) 7 [ 1 6 4 ]\n=> 6\nfindFirst (x: x > 9) 7 [ 1 6 4 ]\n=> 7\n```\n\n:::\n",
  "lib.lists.findFirstIndex": "\nFind the first index in the list matching the specified\npredicate or return `default` if no such element exists.\n\n# Inputs\n\n`pred`\n\n: Predicate\n\n`default`\n\n: Default value to return\n\n`list`\n\n: Input list\n\n# Type\n\n```\nfindFirstIndex :: (a -> Bool) -> b -> [a] -> (Int | b)\n```\n\n# Examples\n:::{.example}\n## `lib.lists.findFirstIndex` usage example\n\n```nix\nfindFirstIndex (x: x > 3) null [ 0 6 4 ]\n=> 1\nfindFirstIndex (x: x > 9) null [ 0 6 4 ]\n=> null\n```\n\n:::\n",
  "lib.lists.findSingle": "\nFind the sole element in the list matching the specified\npredicate.\n\nReturns `default` if no such element exists, or\n`multiple` if there are multiple matching elements.\n\n\n# Inputs\n\n`pred`\n\n: Predicate\n\n`default`\n\n: Default value to return if element was not found.\n\n`multiple`\n\n: Default value to return if more than one element was found\n\n`list`\n\n: Input list\n\n# Type\n\n```\nfindSingle :: (a -> bool) -> a -> a -> [a] -> a\n```\n\n# Examples\n:::{.example}\n## `lib.lists.findSingle` usage example\n\n```nix\nfindSingle (x: x == 3) \"none\" \"multiple\" [ 1 3 3 ]\n=> \"multiple\"\nfindSingle (x: x == 3) \"none\" \"multiple\" [ 1 3 ]\n=> 3\nfindSingle (x: x == 3) \"none\" \"multiple\" [ 1 9 ]\n=> \"none\"\n```\n\n:::\n",
  "lib.lists.flatten": "\nFlatten the argument into a single list; that is, nested lists are\nspliced into the top-level lists.\n\n\n# Inputs\n\n`x`\n\n: 1\\. Function argument\n\n\n# Examples\n:::{.example}\n## `lib.lists.flatten` usage example\n\n```nix\nflatten [1 [2 [3] 4] 5]\n=> [1 2 3 4 5]\nflatten 1\n=> [1]\n```\n\n:::\n",
  "lib.lists.fold": "\n`fold` is an alias of `foldr` for historic reasons\n",
  "lib.lists.foldl": "\n“left fold”, like `foldr`, but from the left:\n\n`foldl op nul [x_1 x_2 ... x_n] == op (... (op (op nul x_1) x_2) ... x_n)`.\n\n# Inputs\n\n`op`\n\n: 1\\. Function argument\n\n`nul`\n\n: 2\\. Function argument\n\n`list`\n\n: 3\\. Function argument\n\n# Type\n\n```\nfoldl :: (b -> a -> b) -> b -> [a] -> b\n```\n\n# Examples\n:::{.example}\n## `lib.lists.foldl` usage example\n\n```nix\nlconcat = foldl (a: b: a + b) \"z\"\nlconcat [ \"a\" \"b\" \"c\" ]\n=> \"zabc\"\n# different types\nlstrange = foldl (str: int: str + toString (int + 1)) \"a\"\nlstrange [ 1 2 3 4 ]\n=> \"a2345\"\n```\n\n:::\n",
  "lib.lists.foldl' (Prime)": "\nReduce a list by applying a binary operator from left to right,\nstarting with an initial accumulator.\n\nBefore each application of the operator, the accumulator value is evaluated.\nThis behavior makes this function stricter than [`foldl`](#function-library-lib.lists.foldl).\n\nUnlike [`builtins.foldl'`](https://nixos.org/manual/nix/unstable/language/builtins.html#builtins-foldl'),\nthe initial accumulator argument is evaluated before the first iteration.\n\nA call like\n\n```nix\nfoldl' op acc₀ [ x₀ x₁ x₂ ... xₙ₋₁ xₙ ]\n```\n\nis (denotationally) equivalent to the following,\nbut with the added benefit that `foldl'` itself will never overflow the stack.\n\n```nix\nlet\n  acc₁   = builtins.seq acc₀   (op acc₀   x₀  );\n  acc₂   = builtins.seq acc₁   (op acc₁   x₁  );\n  acc₃   = builtins.seq acc₂   (op acc₂   x₂  );\n  ...\n  accₙ   = builtins.seq accₙ₋₁ (op accₙ₋₁ xₙ₋₁);\n  accₙ₊₁ = builtins.seq accₙ   (op accₙ   xₙ  );\nin\naccₙ₊₁\n\n# Or ignoring builtins.seq\nop (op (... (op (op (op acc₀ x₀) x₁) x₂) ...) xₙ₋₁) xₙ\n```\n\n# Inputs\n\n`op`\n\n: The binary operation to run, where the two arguments are:\n\n1. `acc`: The current accumulator value: Either the initial one for the first iteration, or the result of the previous iteration\n2. `x`: The corresponding list element for this iteration\n\n`acc`\n\n: The initial accumulator value.\n\n  The accumulator value is evaluated in any case before the first iteration starts.\n\n  To avoid evaluation even before the `list` argument is given an eta expansion can be used:\n\n  ```nix\n  list: lib.foldl' op acc list\n  ```\n\n`list`\n\n: The list to fold\n\n# Type\n\n```\nfoldl' :: (acc -> x -> acc) -> acc -> [x] -> acc\n```\n\n# Examples\n:::{.example}\n## `lib.lists.foldl'` usage example\n\n```nix\nfoldl' (acc: x: acc + x) 0 [1 2 3]\n=> 6\n```\n\n:::\n",
  "lib.lists.foldr": "\n“right fold” a binary function `op` between successive elements of\n`list` with `nul` as the starting value, i.e.,\n`foldr op nul [x_1 x_2 ... x_n] == op x_1 (op x_2 ... (op x_n nul))`.\n\n\n# Inputs\n\n`op`\n\n: 1\\. Function argument\n\n`nul`\n\n: 2\\. Function argument\n\n`list`\n\n: 3\\. Function argument\n\n# Type\n\n```\nfoldr :: (a -> b -> b) -> b -> [a] -> b\n```\n\n# Examples\n:::{.example}\n## `lib.lists.foldr` usage example\n\n```nix\nconcat = foldr (a: b: a + b) \"z\"\nconcat [ \"a\" \"b\" \"c\" ]\n=> \"abcz\"\n# different types\nstrange = foldr (int: str: toString (int + 1) + str) \"a\"\nstrange [ 1 2 3 4 ]\n=> \"2345a\"\n```\n\n:::\n",
  "lib.lists.forEach": "\nApply the function to each element in the list.\nSame as `map`, but arguments flipped.\n\n# Inputs\n\n`xs`\n\n: 1\\. Function argument\n\n`f`\n\n: 2\\. Function argument\n\n# Type\n\n```\nforEach :: [a] -> (a -> b) -> [b]\n```\n\n# Examples\n:::{.example}\n## `lib.lists.forEach` usage example\n\n```nix\nforEach [ 1 2 ] (x:\n  toString x\n)\n=> [ \"1\" \"2\" ]\n```\n\n:::\n",
  "lib.lists.genList": "\nGenerate list of size *length*, with each element *i* equal to the\nvalue returned by *generator* `i`. For example,\n\n```nix\nbuiltins.genList (x: x * x) 5\n```\n\nreturns the list `[ 0 1 4 9 16 ]`.\n",
  "lib.lists.groupBy": "\nGroups elements of *list* together by the string returned from the\nfunction *f* called on each element. It returns an attribute set\nwhere each attribute value contains the elements of *list* that are\nmapped to the same corresponding attribute name returned by *f*.\n\nFor example,\n\n```nix\nbuiltins.groupBy (builtins.substring 0 1) [\"foo\" \"bar\" \"baz\"]\n```\n\nevaluates to\n\n```nix\n{ b = [ \"bar\" \"baz\" ]; f = [ \"foo\" ]; }\n```\n",
  "lib.lists.groupBy' (Prime)": "\nSplits the elements of a list into many lists, using the return value of a predicate.\nPredicate should return a string which becomes keys of attrset `groupBy` returns.\n`groupBy'` allows to customise the combining function and initial value\n\n# Inputs\n\n`op`\n\n: 1\\. Function argument\n\n`nul`\n\n: 2\\. Function argument\n\n`pred`\n\n: 3\\. Function argument\n\n`lst`\n\n: 4\\. Function argument\n\n\n# Examples\n:::{.example}\n## `lib.lists.groupBy'` usage example\n\n```nix\ngroupBy (x: boolToString (x > 2)) [ 5 1 2 3 4 ]\n=> { true = [ 5 3 4 ]; false = [ 1 2 ]; }\ngroupBy (x: x.name) [ {name = \"icewm\"; script = \"icewm &\";}\n                      {name = \"xfce\";  script = \"xfce4-session &\";}\n                      {name = \"icewm\"; script = \"icewmbg &\";}\n                      {name = \"mate\";  script = \"gnome-session &\";}\n                    ]\n=> { icewm = [ { name = \"icewm\"; script = \"icewm &\"; }\n               { name = \"icewm\"; script = \"icewmbg &\"; } ];\n     mate  = [ { name = \"mate\";  script = \"gnome-session &\"; } ];\n     xfce  = [ { name = \"xfce\";  script = \"xfce4-session &\"; } ];\n   }\n\ngroupBy' builtins.add 0 (x: boolToString (x > 2)) [ 5 1 2 3 4 ]\n=> { true = 12; false = 3; }\n```\n\n:::\n",
  "lib.lists.hasPrefix": "\nWhether the first list is a prefix of the second list.\n\n\n# Inputs\n\n`list1`\n\n: 1\\. Function argument\n\n`list2`\n\n: 2\\. Function argument\n\n# Type\n\n```\nhasPrefix :: [a] -> [a] -> bool\n```\n\n# Examples\n:::{.example}\n## `lib.lists.hasPrefix` usage example\n\n```nix\nhasPrefix [ 1 2 ] [ 1 2 3 4 ]\n=> true\nhasPrefix [ 0 1 ] [ 1 2 3 4 ]\n=> false\n```\n\n:::\n",
  "lib.lists.head": "\nReturn the first element of a list; abort evaluation if the argument\nisn’t a list or is an empty list. You can test whether a list is\nempty by comparing it with `[]`.\n",
  "lib.lists.ifilter0": "\nFilter a list for elements that satisfy a predicate function.\nThe predicate function is called with both the index and value for each element.\nIt must return `true`/`false` to include/exclude a given element in the result.\nThis function is strict in the result of the predicate function for each element.\nThis function has O(n) complexity.\n\nAlso see [`builtins.filter`](https://nixos.org/manual/nix/stable/language/builtins.html#builtins-filter) (available as `lib.lists.filter`),\nwhich can be used instead when the index isn't needed.\n\n# Inputs\n\n`ipred`\n\n: The predicate function, it takes two arguments:\n  - 1. (int): the index of the element.\n  - 2. (a): the value of the element.\n\n  It must return `true`/`false` to include/exclude a given element from the result.\n\n`list`\n\n: The list to filter using the predicate.\n\n# Type\n```\nifilter0 :: (int -> a -> bool) -> [a] -> [a]\n```\n\n# Examples\n:::{.example}\n## `lib.lists.ifilter0` usage example\n\n```nix\nifilter0 (i: v: i == 0 || v > 2) [ 1 2 3 ]\n=> [ 1 3 ]\n```\n:::\n",
  "lib.lists.imap0": "\nMap with index starting from 0\n\n# Inputs\n\n`f`\n\n: 1\\. Function argument\n\n`list`\n\n: 2\\. Function argument\n\n# Type\n\n```\nimap0 :: (int -> a -> b) -> [a] -> [b]\n```\n\n# Examples\n:::{.example}\n## `lib.lists.imap0` usage example\n\n```nix\nimap0 (i: v: \"${v}-${toString i}\") [\"a\" \"b\"]\n=> [ \"a-0\" \"b-1\" ]\n```\n\n:::\n",
  "lib.lists.imap1": "\nMap with index starting from 1\n\n\n# Inputs\n\n`f`\n\n: 1\\. Function argument\n\n`list`\n\n: 2\\. Function argument\n\n# Type\n\n```\nimap1 :: (int -> a -> b) -> [a] -> [b]\n```\n\n# Examples\n:::{.example}\n## `lib.lists.imap1` usage example\n\n```nix\nimap1 (i: v: \"${v}-${toString i}\") [\"a\" \"b\"]\n=> [ \"a-1\" \"b-2\" ]\n```\n\n:::\n",
  "lib.lists.init": "\nReturn all elements but the last.\n\nThis function throws an error if the list is empty.\n\n\n# Inputs\n\n`list`\n\n: 1\\. Function argument\n\n# Type\n\n```\ninit :: [a] -> [a]\n```\n\n# Examples\n:::{.example}\n## `lib.lists.init` usage example\n\n```nix\ninit [ 1 2 3 ]\n=> [ 1 2 ]\n```\n\n:::\n",
  "lib.lists.intersectLists": "\nIntersects list 'list1' and another list (`list2`).\n\nO(nm) complexity.\n\n# Inputs\n\n`list1`\n\n: First list\n\n`list2`\n\n: Second list\n\n\n# Examples\n:::{.example}\n## `lib.lists.intersectLists` usage example\n\n```nix\nintersectLists [ 1 2 3 ] [ 6 3 2 ]\n=> [ 3 2 ]\n```\n\n:::\n",
  "lib.lists.isList": "\nReturn `true` if *e* evaluates to a list, and `false` otherwise.\n",
  "lib.lists.last": "\nReturn the last element of a list.\n\nThis function throws an error if the list is empty.\n\n\n# Inputs\n\n`list`\n\n: 1\\. Function argument\n\n# Type\n\n```\nlast :: [a] -> a\n```\n\n# Examples\n:::{.example}\n## `lib.lists.last` usage example\n\n```nix\nlast [ 1 2 3 ]\n=> 3\n```\n\n:::\n",
  "lib.lists.length": "\nReturn the length of the list *e*.\n",
  "lib.lists.listDfs": "\nDepth-First Search (DFS) for lists `list != []`.\n\n`before a b == true` means that `b` depends on `a` (there's an\nedge from `b` to `a`).\n\n\n# Inputs\n\n`stopOnCycles`\n\n: 1\\. Function argument\n\n`before`\n\n: 2\\. Function argument\n\n`list`\n\n: 3\\. Function argument\n\n\n# Examples\n:::{.example}\n## `lib.lists.listDfs` usage example\n\n```nix\nlistDfs true hasPrefix [ \"/home/user\" \"other\" \"/\" \"/home\" ]\n  == { minimal = \"/\";                  # minimal element\n       visited = [ \"/home/user\" ];     # seen elements (in reverse order)\n       rest    = [ \"/home\" \"other\" ];  # everything else\n     }\n\nlistDfs true hasPrefix [ \"/home/user\" \"other\" \"/\" \"/home\" \"/\" ]\n  == { cycle   = \"/\";                  # cycle encountered at this element\n       loops   = [ \"/\" ];              # and continues to these elements\n       visited = [ \"/\" \"/home/user\" ]; # elements leading to the cycle (in reverse order)\n       rest    = [ \"/home\" \"other\" ];  # everything else\n```\n\n:::\n",
  "lib.lists.map": "\nApply the function *f* to each element in the list *list*. For\nexample,\n\n```nix\nmap (x: \"foo\" + x) [ \"bar\" \"bla\" \"abc\" ]\n```\n\nevaluates to `[ \"foobar\" \"foobla\" \"fooabc\" ]`.\n",
  "lib.lists.mutuallyExclusive": "\nTest if two lists have no common element.\nIt should be slightly more efficient than (intersectLists a b == [])\n\n# Inputs\n\n`a`\n\n: 1\\. Function argument\n\n`b`\n\n: 2\\. Function argument\n",
  "lib.lists.naturalSort": "\nSort list using \"Natural sorting\".\nNumeric portions of strings are sorted in numeric order.\n\n\n# Inputs\n\n`lst`\n\n: 1\\. Function argument\n\n\n# Examples\n:::{.example}\n## `lib.lists.naturalSort` usage example\n\n```nix\nnaturalSort [\"disk11\" \"disk8\" \"disk100\" \"disk9\"]\n=> [\"disk8\" \"disk9\" \"disk11\" \"disk100\"]\nnaturalSort [\"10.46.133.149\" \"10.5.16.62\" \"10.54.16.25\"]\n=> [\"10.5.16.62\" \"10.46.133.149\" \"10.54.16.25\"]\nnaturalSort [\"v0.2\" \"v0.15\" \"v0.0.9\"]\n=> [ \"v0.0.9\" \"v0.2\" \"v0.15\" ]\n```\n\n:::\n",
  "lib.lists.optional": "\nReturn a singleton list or an empty list, depending on a boolean\nvalue.  Useful when building lists with optional elements\n(e.g. `++ optional (system == \"i686-linux\") firefox`).\n\n# Inputs\n\n`cond`\n\n: 1\\. Function argument\n\n`elem`\n\n: 2\\. Function argument\n\n# Type\n\n```\noptional :: bool -> a -> [a]\n```\n\n# Examples\n:::{.example}\n## `lib.lists.optional` usage example\n\n```nix\noptional true \"foo\"\n=> [ \"foo\" ]\noptional false \"foo\"\n=> [ ]\n```\n\n:::\n",
  "lib.lists.optionals": "\nReturn a list or an empty list, depending on a boolean value.\n\n# Inputs\n\n`cond`\n\n: Condition\n\n`elems`\n\n: List to return if condition is true\n\n# Type\n\n```\noptionals :: bool -> [a] -> [a]\n```\n\n# Examples\n:::{.example}\n## `lib.lists.optionals` usage example\n\n```nix\noptionals true [ 2 3 ]\n=> [ 2 3 ]\noptionals false [ 2 3 ]\n=> [ ]\n```\n\n:::\n",
  "lib.lists.partition": "\nSplits the elements of a list in two lists, `right` and\n`wrong`, depending on the evaluation of a predicate.\n\n# Inputs\n\n`pred`\n\n: Predicate\n\n`list`\n\n: Input list\n\n# Type\n\n```\n(a -> bool) -> [a] -> { right :: [a]; wrong :: [a]; }\n```\n\n# Examples\n:::{.example}\n## `lib.lists.partition` usage example\n\n```nix\npartition (x: x > 2) [ 5 1 2 3 4 ]\n=> { right = [ 5 3 4 ]; wrong = [ 1 2 ]; }\n```\n\n:::\n",
  "lib.lists.range": "\nReturn a list of integers from `first` up to and including `last`.\n\n# Inputs\n\n`first`\n\n: First integer in the range\n\n`last`\n\n: Last integer in the range\n\n# Type\n\n```\nrange :: int -> int -> [int]\n```\n\n# Examples\n:::{.example}\n## `lib.lists.range` usage example\n\n```nix\nrange 2 4\n=> [ 2 3 4 ]\nrange 3 2\n=> [ ]\n```\n\n:::\n",
  "lib.lists.remove": "\nRemove elements equal to 'e' from a list.  Useful for buildInputs.\n\n\n# Inputs\n\n`e`\n\n: Element to remove from `list`\n\n`list`\n\n: The list\n\n# Type\n\n```\nremove :: a -> [a] -> [a]\n```\n\n# Examples\n:::{.example}\n## `lib.lists.remove` usage example\n\n```nix\nremove 3 [ 1 3 4 3 ]\n=> [ 1 4 ]\n```\n\n:::\n",
  "lib.lists.removePrefix": "\nRemove the first list as a prefix from the second list.\nError if the first list isn't a prefix of the second list.\n\n# Inputs\n\n`list1`\n\n: 1\\. Function argument\n\n`list2`\n\n: 2\\. Function argument\n\n# Type\n\n```\nremovePrefix :: [a] -> [a] -> [a]\n```\n\n# Examples\n:::{.example}\n## `lib.lists.removePrefix` usage example\n\n```nix\nremovePrefix [ 1 2 ] [ 1 2 3 4 ]\n=> [ 3 4 ]\nremovePrefix [ 0 1 ] [ 1 2 3 4 ]\n=> <error>\n```\n\n:::\n",
  "lib.lists.replicate": "\nReturn a list with `n` copies of an element.\n\n# Inputs\n\n`n`\n\n: 1\\. Function argument\n\n`elem`\n\n: 2\\. Function argument\n\n# Type\n\n```\nreplicate :: int -> a -> [a]\n```\n\n# Examples\n:::{.example}\n## `lib.lists.replicate` usage example\n\n```nix\nreplicate 3 \"a\"\n=> [ \"a\" \"a\" \"a\" ]\nreplicate 2 true\n=> [ true true ]\n```\n\n:::\n",
  "lib.lists.reverseList": "\nReverse the order of the elements of a list.\n\n# Inputs\n\n`xs`\n\n: 1\\. Function argument\n\n# Type\n\n```\nreverseList :: [a] -> [a]\n```\n\n# Examples\n:::{.example}\n## `lib.lists.reverseList` usage example\n\n```nix\nreverseList [ \"b\" \"o\" \"j\" ]\n=> [ \"j\" \"o\" \"b\" ]\n```\n\n:::\n",
  "lib.lists.singleton": "\nCreate a list consisting of a single element. `singleton x` is\nsometimes more convenient with respect to indentation than `[x]`\nwhen x spans multiple lines.\n\n# Inputs\n\n`x`\n\n: 1\\. Function argument\n\n# Type\n\n```\nsingleton :: a -> [a]\n```\n\n# Examples\n:::{.example}\n## `lib.lists.singleton` usage example\n\n```nix\nsingleton \"foo\"\n=> [ \"foo\" ]\n```\n\n:::\n",
  "lib.lists.sort": "\nSort a list based on a comparator function which compares two\nelements and returns true if the first argument is strictly below\nthe second argument.  The returned list is sorted in an increasing\norder.  The implementation does a quick-sort.\n\nSee also [`sortOn`](#function-library-lib.lists.sortOn), which applies the\ndefault comparison on a function-derived property, and may be more efficient.\n\n# Inputs\n\n`comparator`\n\n: 1\\. Function argument\n\n`list`\n\n: 2\\. Function argument\n\n# Type\n\n```\nsort :: (a -> a -> Bool) -> [a] -> [a]\n```\n\n# Examples\n:::{.example}\n## `lib.lists.sort` usage example\n\n```nix\nsort (p: q: p < q) [ 5 3 7 ]\n=> [ 3 5 7 ]\n```\n\n:::\n",
  "lib.lists.sortOn": "\nSort a list based on the default comparison of a derived property `b`.\n\nThe items are returned in `b`-increasing order.\n\n**Performance**:\n\nThe passed function `f` is only evaluated once per item,\nunlike an unprepared [`sort`](#function-library-lib.lists.sort) using\n`f p < f q`.\n\n**Laws**:\n```nix\nsortOn f == sort (p: q: f p < f q)\n```\n\n\n# Inputs\n\n`f`\n\n: 1\\. Function argument\n\n`list`\n\n: 2\\. Function argument\n\n# Type\n\n```\nsortOn :: (a -> b) -> [a] -> [a], for comparable b\n```\n\n# Examples\n:::{.example}\n## `lib.lists.sortOn` usage example\n\n```nix\nsortOn stringLength [ \"aa\" \"b\" \"cccc\" ]\n=> [ \"b\" \"aa\" \"cccc\" ]\n```\n\n:::\n",
  "lib.lists.sublist": "\nReturn a list consisting of at most `count` elements of `list`,\nstarting at index `start`.\n\n# Inputs\n\n`start`\n\n: Index at which to start the sublist\n\n`count`\n\n: Number of elements to take\n\n`list`\n\n: Input list\n\n# Type\n\n```\nsublist :: int -> int -> [a] -> [a]\n```\n\n# Examples\n:::{.example}\n## `lib.lists.sublist` usage example\n\n```nix\nsublist 1 3 [ \"a\" \"b\" \"c\" \"d\" \"e\" ]\n=> [ \"b\" \"c\" \"d\" ]\nsublist 1 3 [ ]\n=> [ ]\n```\n\n:::\n",
  "lib.lists.subtractLists": "\nSubtracts list 'e' from another list (`list2`).\n\nO(nm) complexity.\n\n# Inputs\n\n`e`\n\n: First list\n\n`list2`\n\n: Second list\n\n\n# Examples\n:::{.example}\n## `lib.lists.subtractLists` usage example\n\n```nix\nsubtractLists [ 3 2 ] [ 1 2 3 4 5 3 ]\n=> [ 1 4 5 ]\n```\n\n:::\n",
  "lib.lists.tail": "\nReturn the list without its first item; abort evaluation if\nthe argument isn’t a list or is an empty list.\n\n> **Warning**\n>\n> This function should generally be avoided since it's inefficient:\n> unlike Haskell's `tail`, it takes O(n) time, so recursing over a\n> list by repeatedly calling `tail` takes O(n^2) time.\n",
  "lib.lists.take": "\nReturn the first (at most) N elements of a list.\n\n\n# Inputs\n\n`count`\n\n: Number of elements to take\n\n`list`\n\n: Input list\n\n# Type\n\n```\ntake :: int -> [a] -> [a]\n```\n\n# Examples\n:::{.example}\n## `lib.lists.take` usage example\n\n```nix\ntake 2 [ \"a\" \"b\" \"c\" \"d\" ]\n=> [ \"a\" \"b\" ]\ntake 2 [ ]\n=> [ ]\n```\n\n:::\n",
  "lib.lists.toList": "\nIf argument is a list, return it; else, wrap it in a singleton\nlist. If you're using this, you should almost certainly\nreconsider if there isn't a more \"well-typed\" approach.\n\n# Inputs\n\n`x`\n\n: 1\\. Function argument\n\n# Examples\n:::{.example}\n## `lib.lists.toList` usage example\n\n```nix\ntoList [ 1 2 ]\n=> [ 1 2 ]\ntoList \"hi\"\n=> [ \"hi \"]\n```\n\n:::\n",
  "lib.lists.toposort": "\nSort a list based on a partial ordering using DFS. This\nimplementation is O(N^2), if your ordering is linear, use `sort`\ninstead.\n\n`before a b == true` means that `b` should be after `a`\nin the result.\n\n\n# Inputs\n\n`before`\n\n: 1\\. Function argument\n\n`list`\n\n: 2\\. Function argument\n\n\n# Examples\n:::{.example}\n## `lib.lists.toposort` usage example\n\n```nix\ntoposort hasPrefix [ \"/home/user\" \"other\" \"/\" \"/home\" ]\n  == { result = [ \"/\" \"/home\" \"/home/user\" \"other\" ]; }\n\ntoposort hasPrefix [ \"/home/user\" \"other\" \"/\" \"/home\" \"/\" ]\n  == { cycle = [ \"/home/user\" \"/\" \"/\" ]; # path leading to a cycle\n       loops = [ \"/\" ]; }                # loops back to these elements\n\ntoposort hasPrefix [ \"other\" \"/home/user\" \"/home\" \"/\" ]\n  == { result = [ \"other\" \"/\" \"/home\" \"/home/user\" ]; }\n\ntoposort (a: b: a < b) [ 3 2 1 ] == { result = [ 1 2 3 ]; }\n```\n\n:::\n",
  "lib.lists.unique": "\nRemove duplicate elements from the `list`. O(n^2) complexity.\n\n\n# Inputs\n\n`list`\n\n: Input list\n\n# Type\n\n```\nunique :: [a] -> [a]\n```\n\n# Examples\n:::{.example}\n## `lib.lists.unique` usage example\n\n```nix\nunique [ 3 2 3 4 ]\n=> [ 3 2 4 ]\n```\n\n:::\n",
  "lib.lists.zipLists": "\nMerges two lists of the same size together. If the sizes aren't the same\nthe merging stops at the shortest.\n\n# Inputs\n\n`fst`\n\n: First list\n\n`snd`\n\n: Second list\n\n# Type\n\n```\nzipLists :: [a] -> [b] -> [{ fst :: a; snd :: b; }]\n```\n\n# Examples\n:::{.example}\n## `lib.lists.zipLists` usage example\n\n```nix\nzipLists [ 1 2 ] [ \"a\" \"b\" ]\n=> [ { fst = 1; snd = \"a\"; } { fst = 2; snd = \"b\"; } ]\n```\n\n:::\n",
  "lib.lists.zipListsWith": "\nMerges two lists of the same size together. If the sizes aren't the same\nthe merging stops at the shortest. How both lists are merged is defined\nby the first argument.\n\n# Inputs\n\n`f`\n\n: Function to zip elements of both lists\n\n`fst`\n\n: First list\n\n`snd`\n\n: Second list\n\n# Type\n\n```\nzipListsWith :: (a -> b -> c) -> [a] -> [b] -> [c]\n```\n\n# Examples\n:::{.example}\n## `lib.lists.zipListsWith` usage example\n\n```nix\nzipListsWith (a: b: a + b) [\"h\" \"l\"] [\"e\" \"o\"]\n=> [\"he\" \"lo\"]\n```\n\n:::\n",
  "lib.mergeAttrBy.buildInputs": "\nConcatenate two lists\n\n\n# Inputs\n\n`x`\n\n: 1\\. Function argument\n\n`y`\n\n: 2\\. Function argument\n\n# Type\n\n```\nconcat :: [a] -> [a] -> [a]\n```\n\n# Examples\n:::{.example}\n## `lib.trivial.concat` usage example\n\n```nix\nconcat [ 1 2 ] [ 3 4 ]\n=> [ 1 2 3 4 ]\n```\n\n:::\n",
  "lib.mergeAttrBy.cfg": "\nMerge two attribute sets shallowly, right side trumps left\n\nmergeAttrs :: attrs -> attrs -> attrs\n\n\n# Inputs\n\n`x`\n\n: Left attribute set\n\n`y`\n\n: Right attribute set (higher precedence for equal keys)\n\n\n# Examples\n:::{.example}\n## `lib.trivial.mergeAttrs` usage example\n\n```nix\nmergeAttrs { a = 1; b = 2; } { b = 3; c = 4; }\n=> { a = 1; b = 3; c = 4; }\n```\n\n:::\n",
  "lib.mergeAttrBy.configureFlags": "\nConcatenate two lists\n\n\n# Inputs\n\n`x`\n\n: 1\\. Function argument\n\n`y`\n\n: 2\\. Function argument\n\n# Type\n\n```\nconcat :: [a] -> [a] -> [a]\n```\n\n# Examples\n:::{.example}\n## `lib.trivial.concat` usage example\n\n```nix\nconcat [ 1 2 ] [ 3 4 ]\n=> [ 1 2 3 4 ]\n```\n\n:::\n",
  "lib.mergeAttrBy.flags": "\nMerge two attribute sets shallowly, right side trumps left\n\nmergeAttrs :: attrs -> attrs -> attrs\n\n\n# Inputs\n\n`x`\n\n: Left attribute set\n\n`y`\n\n: Right attribute set (higher precedence for equal keys)\n\n\n# Examples\n:::{.example}\n## `lib.trivial.mergeAttrs` usage example\n\n```nix\nmergeAttrs { a = 1; b = 2; } { b = 3; c = 4; }\n=> { a = 1; b = 3; c = 4; }\n```\n\n:::\n",
  "lib.mergeAttrBy.meta": "\nMerge two attribute sets shallowly, right side trumps left\n\nmergeAttrs :: attrs -> attrs -> attrs\n\n\n# Inputs\n\n`x`\n\n: Left attribute set\n\n`y`\n\n: Right attribute set (higher precedence for equal keys)\n\n\n# Examples\n:::{.example}\n## `lib.trivial.mergeAttrs` usage example\n\n```nix\nmergeAttrs { a = 1; b = 2; } { b = 3; c = 4; }\n=> { a = 1; b = 3; c = 4; }\n```\n\n:::\n",
  "lib.mergeAttrBy.nativeBuildInputs": "\nConcatenate two lists\n\n\n# Inputs\n\n`x`\n\n: 1\\. Function argument\n\n`y`\n\n: 2\\. Function argument\n\n# Type\n\n```\nconcat :: [a] -> [a] -> [a]\n```\n\n# Examples\n:::{.example}\n## `lib.trivial.concat` usage example\n\n```nix\nconcat [ 1 2 ] [ 3 4 ]\n=> [ 1 2 3 4 ]\n```\n\n:::\n",
  "lib.mergeAttrBy.passthru": "\nMerge two attribute sets shallowly, right side trumps left\n\nmergeAttrs :: attrs -> attrs -> attrs\n\n\n# Inputs\n\n`x`\n\n: Left attribute set\n\n`y`\n\n: Right attribute set (higher precedence for equal keys)\n\n\n# Examples\n:::{.example}\n## `lib.trivial.mergeAttrs` usage example\n\n```nix\nmergeAttrs { a = 1; b = 2; } { b = 3; c = 4; }\n=> { a = 1; b = 3; c = 4; }\n```\n\n:::\n",
  "lib.mergeAttrBy.patches": "\nConcatenate two lists\n\n\n# Inputs\n\n`x`\n\n: 1\\. Function argument\n\n`y`\n\n: 2\\. Function argument\n\n# Type\n\n```\nconcat :: [a] -> [a] -> [a]\n```\n\n# Examples\n:::{.example}\n## `lib.trivial.concat` usage example\n\n```nix\nconcat [ 1 2 ] [ 3 4 ]\n=> [ 1 2 3 4 ]\n```\n\n:::\n",
  "lib.mergeAttrBy.postAll": "\nConcatenate two lists\n\n\n# Inputs\n\n`x`\n\n: 1\\. Function argument\n\n`y`\n\n: 2\\. Function argument\n\n# Type\n\n```\nconcat :: [a] -> [a] -> [a]\n```\n\n# Examples\n:::{.example}\n## `lib.trivial.concat` usage example\n\n```nix\nconcat [ 1 2 ] [ 3 4 ]\n=> [ 1 2 3 4 ]\n```\n\n:::\n",
  "lib.mergeAttrBy.postInstall": null,
  "lib.mergeAttrBy.preConfigure": null,
  "lib.mergeAttrBy.prePhases": "\nConcatenate two lists\n\n\n# Inputs\n\n`x`\n\n: 1\\. Function argument\n\n`y`\n\n: 2\\. Function argument\n\n# Type\n\n```\nconcat :: [a] -> [a] -> [a]\n```\n\n# Examples\n:::{.example}\n## `lib.trivial.concat` usage example\n\n```nix\nconcat [ 1 2 ] [ 3 4 ]\n=> [ 1 2 3 4 ]\n```\n\n:::\n",
  "lib.mergeAttrBy.propagatedBuildInputs": "\nConcatenate two lists\n\n\n# Inputs\n\n`x`\n\n: 1\\. Function argument\n\n`y`\n\n: 2\\. Function argument\n\n# Type\n\n```\nconcat :: [a] -> [a] -> [a]\n```\n\n# Examples\n:::{.example}\n## `lib.trivial.concat` usage example\n\n```nix\nconcat [ 1 2 ] [ 3 4 ]\n=> [ 1 2 3 4 ]\n```\n\n:::\n",
  "lib.meta.addMetaAttrs": "\nAdd to or override the meta attributes of the given\nderivation.\n\n# Inputs\n\n`newAttrs`\n\n: 1\\. Function argument\n\n`drv`\n\n: 2\\. Function argument\n\n\n# Examples\n:::{.example}\n## `lib.meta.addMetaAttrs` usage example\n\n```nix\naddMetaAttrs {description = \"Bla blah\";} somePkg\n```\n\n:::\n",
  "lib.meta.appendToName": "\nAppend a suffix to the name of a package (before the version\npart).\n\n# Inputs\n\n`suffix`\n\n: 1\\. Function argument\n",
  "lib.meta.availableOn": "\nCheck if a package is available on a given platform.\n\nA package is available on a platform if both\n\n1. One of `meta.platforms` pattern matches the given\n    platform, or `meta.platforms` is not present.\n\n2. None of `meta.badPlatforms` pattern matches the given platform.\n\n\n# Inputs\n\n`platform`\n\n: 1\\. Function argument\n\n`pkg`\n\n: 2\\. Function argument\n\n\n# Examples\n:::{.example}\n## `lib.meta.availableOn` usage example\n\n```nix\nlib.meta.availableOn { system = \"aarch64-darwin\"; } pkg.zsh\n=> true\n```\n\n:::\n",
  "lib.meta.dontDistribute": "\nDisable Hydra builds of given derivation.\n\n# Inputs\n\n`drv`\n\n: 1\\. Function argument\n",
  "lib.meta.getExe": "\nGet the path to the main program of a package based on meta.mainProgram\n\n\n# Inputs\n\n`x`\n\n: 1\\. Function argument\n\n# Type\n\n```\ngetExe :: package -> string\n```\n\n# Examples\n:::{.example}\n## `lib.meta.getExe` usage example\n\n```nix\ngetExe pkgs.hello\n=> \"/nix/store/g124820p9hlv4lj8qplzxw1c44dxaw1k-hello-2.12/bin/hello\"\ngetExe pkgs.mustache-go\n=> \"/nix/store/am9ml4f4ywvivxnkiaqwr0hyxka1xjsf-mustache-go-1.3.0/bin/mustache\"\n```\n\n:::\n",
  "lib.meta.getExe' (Prime)": "\nGet the path of a program of a derivation.\n\n\n# Inputs\n\n`x`\n\n: 1\\. Function argument\n\n`y`\n\n: 2\\. Function argument\n\n# Type\n\n```\ngetExe' :: derivation -> string -> string\n```\n\n# Examples\n:::{.example}\n## `lib.meta.getExe'` usage example\n\n```nix\ngetExe' pkgs.hello \"hello\"\n=> \"/nix/store/g124820p9hlv4lj8qplzxw1c44dxaw1k-hello-2.12/bin/hello\"\ngetExe' pkgs.imagemagick \"convert\"\n=> \"/nix/store/5rs48jamq7k6sal98ymj9l4k2bnwq515-imagemagick-7.1.1-15/bin/convert\"\n```\n\n:::\n",
  "lib.meta.getLicenseFromSpdxId": "\nGet the corresponding attribute in lib.licenses from the SPDX ID\nor warn and fallback to `{ shortName = <license string>; }`.\n\nFor SPDX IDs, see https://spdx.org/licenses.\nNote that some SPDX licenses might be missing.\n\n# Type\n\n```\ngetLicenseFromSpdxId :: str -> AttrSet\n```\n\n# Examples\n:::{.example}\n## `lib.meta.getLicenseFromSpdxId` usage example\n\n```nix\nlib.getLicenseFromSpdxId \"MIT\" == lib.licenses.mit\n=> true\nlib.getLicenseFromSpdxId \"mIt\" == lib.licenses.mit\n=> true\nlib.getLicenseFromSpdxId \"MY LICENSE\"\n=> trace: warning: getLicenseFromSpdxId: No license matches the given SPDX ID: MY LICENSE\n=> { shortName = \"MY LICENSE\"; }\n```\n\n:::\n",
  "lib.meta.getLicenseFromSpdxIdOr": "\nGet the corresponding attribute in lib.licenses from the SPDX ID\nor fallback to the given default value.\n\nFor SPDX IDs, see https://spdx.org/licenses.\nNote that some SPDX licenses might be missing.\n\n# Inputs\n\n`licstr`\n: 1\\. SPDX ID string to find a matching license\n\n`default`\n: 2\\. Fallback value when a match is not found\n\n# Type\n\n```\ngetLicenseFromSpdxIdOr :: str -> Any -> Any\n```\n\n# Examples\n:::{.example}\n## `lib.meta.getLicenseFromSpdxIdOr` usage example\n\n```nix\nlib.getLicenseFromSpdxIdOr \"MIT\" null == lib.licenses.mit\n=> true\nlib.getLicenseFromSpdxId \"mIt\" null == lib.licenses.mit\n=> true\nlib.getLicenseFromSpdxIdOr \"MY LICENSE\" lib.licenses.free == lib.licenses.free\n=> true\nlib.getLicenseFromSpdxIdOr \"MY LICENSE\" null\n=> null\nlib.getLicenseFromSpdxIdOr \"MY LICENSE\" (builtins.throw \"No SPDX ID matches MY LICENSE\")\n=> error: No SPDX ID matches MY LICENSE\n```\n:::\n",
  "lib.meta.hiPrio": "\nIncrease the nix-env priority of the package, i.e., this\nversion/variant of the package will be preferred.\n\n# Inputs\n\n`drv`\n\n: 1\\. Function argument\n",
  "lib.meta.hiPrioSet": "\nApply hiPrio to an attrset with derivations.\n\n# Inputs\n\n`set`\n\n: 1\\. Function argument\n",
  "lib.meta.lowPrio": "\nDecrease the nix-env priority of the package, i.e., other\nversions/variants of the package will be preferred.\n\n# Inputs\n\n`drv`\n\n: 1\\. Function argument\n\n",
  "lib.meta.lowPrioSet": "\nApply lowPrio to an attrset with derivations.\n\n# Inputs\n\n`set`\n\n: 1\\. Function argument\n",
  "lib.meta.mapDerivationAttrset": "\nApply a function to each derivation and only to derivations in an attrset.\n\n\n# Inputs\n\n`f`\n\n: 1\\. Function argument\n\n`set`\n\n: 2\\. Function argument\n",
  "lib.meta.platformMatch": "\nCheck to see if a platform is matched by the given `meta.platforms`\nelement.\n\nA `meta.platform` pattern is either\n\n1. (legacy) a system string.\n\n2. (modern) a pattern for the entire platform structure (see `lib.systems.inspect.platformPatterns`).\n\n3. (modern) a pattern for the platform `parsed` field (see `lib.systems.inspect.patterns`).\n\nWe can inject these into a pattern for the whole of a structured platform,\nand then match that.\n\n\n# Inputs\n\n`platform`\n\n: 1\\. Function argument\n\n`elem`\n\n: 2\\. Function argument\n\n\n# Examples\n:::{.example}\n## `lib.meta.platformMatch` usage example\n\n```nix\nlib.meta.platformMatch { system = \"aarch64-darwin\"; } \"aarch64-darwin\"\n=> true\n```\n\n:::\n",
  "lib.meta.setName": "\nChange the [symbolic name of a derivation](https://nixos.org/manual/nix/stable/language/derivations.html#attr-name).\n\n:::{.warning}\nDependent derivations will be rebuilt when the symbolic name is changed.\n:::\n\n# Inputs\n\n`name`\n\n: 1\\. Function argument\n\n`drv`\n\n: 2\\. Function argument\n",
  "lib.meta.setPrio": "\nSet the nix-env priority of the package. Note that higher values are lower priority, and vice versa.\n\n# Inputs\n\n`priority`\n: 1\\. The priority to set.\n\n`drv`\n: 2\\. Function argument\n",
  "lib.meta.updateName": "\nLike `setName`, but takes the previous name as an argument.\n\n# Inputs\n\n`updater`\n\n: 1\\. Function argument\n\n`drv`\n\n: 2\\. Function argument\n\n\n# Examples\n:::{.example}\n## `lib.meta.updateName` usage example\n\n```nix\nupdateName (oldName: oldName + \"-experimental\") somePkg\n```\n\n:::\n",
  "lib.misc.checkFlag": "Return true only if there is an attribute and it is true.",
  "lib.misc.checkReqs": "Output : are reqs satisfied? It's asserted.",
  "lib.misc.closePropagation": "See https://github.com/NixOS/nixpkgs/pull/194391 for details.",
  "lib.misc.closePropagationFast": "See https://github.com/NixOS/nixpkgs/pull/194391 for details.",
  "lib.misc.closePropagationSlow": null,
  "lib.misc.condConcat": null,
  "lib.misc.defaultMerge": null,
  "lib.misc.defaultMergeArg": null,
  "lib.misc.foldArgs": null,
  "lib.misc.getValue": "Output : its value or default.",
  "lib.misc.ifEnable": "of the second argument.",
  "lib.misc.imap": "\nMap with index starting from 1\n\n\n# Inputs\n\n`f`\n\n: 1\\. Function argument\n\n`list`\n\n: 2\\. Function argument\n\n# Type\n\n```\nimap1 :: (int -> a -> b) -> [a] -> [b]\n```\n\n# Examples\n:::{.example}\n## `lib.lists.imap1` usage example\n\n```nix\nimap1 (i: v: \"${v}-${toString i}\") [\"a\" \"b\"]\n=> [ \"a-1\" \"b-2\" ]\n```\n\n:::\n",
  "lib.misc.innerClosePropagation": null,
  "lib.misc.innerModifySumArgs": null,
  "lib.misc.lazyGenericClosure": null,
  "lib.misc.mapAttrsFlatten": "\nCall a function for each attribute in the given set and return\nthe result in a list.\n\n# Inputs\n\n`f`\n\n: A function, given an attribute's name and value, returns a new value.\n\n`attrs`\n\n: Attribute set to map over.\n\n# Type\n\n```\nmapAttrsToList :: (String -> a -> b) -> AttrSet -> [b]\n```\n\n# Examples\n:::{.example}\n## `lib.attrsets.mapAttrsToList` usage example\n\n```nix\nmapAttrsToList (name: value: name + value)\n   { x = \"a\"; y = \"b\"; }\n=> [ \"xa\" \"yb\" ]\n```\n\n:::\n",
  "lib.misc.maybeAttr": "shortcut for attrByPath [\"name\"] default attrs",
  "lib.misc.maybeAttrNullable": "shortcut for attrByPath [\"name\"] default attrs",
  "lib.misc.maybeEnv": "returns default if env var is not set",
  "lib.misc.mergeAttrByFunc": "foldArgs, composedArgsAndFun or applyAndFun. Example: composableDerivation in all-packages.nix",
  "lib.misc.mergeAttrsByFuncDefaults": null,
  "lib.misc.mergeAttrsByFuncDefaultsClean": null,
  "lib.misc.mergeAttrsConcatenateValues": null,
  "lib.misc.mergeAttrsNoOverride": "! deprecated, use mergeAttrByFunc instead",
  "lib.misc.mergeAttrsWithFunc": "exists in both sets",
  "lib.misc.modifySumArgs": null,
  "lib.misc.nixType": null,
  "lib.misc.nvs": "attribute set containing one attribute",
  "lib.misc.setAttr": "adds / replaces an attribute of an attribute set",
  "lib.misc.setAttrMerge": "setAttrMerge \"a\" [] {         } (x: x ++ [3]) -> { a = [  3]; }",
  "lib.misc.uniqList": "This function has O(n^2) performance.",
  "lib.misc.uniqListExt": null,
  "lib.modules.applyModuleArgsIfFunction": null,
  "lib.modules.collectModules": null,
  "lib.modules.dischargeProperties": "\nGiven a config value, expand mkMerge properties, and discharge\nany mkIf conditions.  That is, this is the place where mkIf\nconditions are actually evaluated.  The result is a list of\nconfig values.  For example, ‘mkIf false x’ yields ‘[]’,\n‘mkIf true x’ yields ‘[x]’, and\n\n  mkMerge [ 1 (mkIf true 2) (mkIf true (mkIf false 3)) ]\n\nyields ‘[ 1 2 ]’.\n\n\n# Inputs\n\n`def`\n\n: 1\\. Function argument\n",
  "lib.modules.doRename": "\nReturn a module that help declares an option that has been renamed.\nWhen a value is defined for the old option, it is forwarded to the `to` option.\n",
  "lib.modules.evalModules": "\nSee https://nixos.org/manual/nixpkgs/unstable/#module-system-lib-evalModules\nor file://./../doc/module-system/module-system.chapter.md\n\n!!! Please think twice before adding to this argument list! The more\nthat is specified here instead of in the modules themselves the harder\nit is to transparently move a set of modules to be a submodule of another\nconfig (as the proper arguments need to be replicated at each call to\nevalModules) and the less declarative the module set is.\n",
  "lib.modules.evalOptionValue": "\nMerge all the definitions of an option to produce the final\nconfig value.\n\n\n# Inputs\n\n`loc`\n\n: 1\\. Function argument\n\n`opt`\n\n: 2\\. Function argument\n\n`defs`\n\n: 3\\. Function argument\n",
  "lib.modules.filterOverrides": "\nGiven a list of config values, process the mkOverride properties,\nthat is, return the values that have the highest (that is,\nnumerically lowest) priority, and strip the mkOverride\nproperties.  For example,\n\n  [ { file = \"/1\"; value = mkOverride 10 \"a\"; }\n    { file = \"/2\"; value = mkOverride 20 \"b\"; }\n    { file = \"/3\"; value = \"z\"; }\n    { file = \"/4\"; value = mkOverride 10 \"d\"; }\n  ]\n\nyields\n\n  [ { file = \"/1\"; value = \"a\"; }\n    { file = \"/4\"; value = \"d\"; }\n  ]\n\nNote that \"z\" has the default priority 100.\n\n\n# Inputs\n\n`defs`\n\n: 1\\. Function argument\n",
  "lib.modules.filterOverrides' (Prime)": null,
  "lib.modules.fixMergeModules": "\nCompatibility.\n\n\n# Inputs\n\n`modules`\n\n: 1\\. Function argument\n\n`args`\n\n: 2\\. Function argument\n",
  "lib.modules.fixupOptionType": "TODO: Merge this into mergeOptionDecls",
  "lib.modules.importApply": "\n`importApply file arg :: Path -> a -> Module`,  where `import file :: a -> Module`\n\n`importApply` imports a Nix expression file much like the module system would,\nafter passing an extra positional argument to the function in the file.\n\nThis function should be used when declaring a module in a file that refers to\nvalues from a different scope, such as that in a flake.\n\nIt solves the problems of alternative solutions:\n\n- While `importApply file arg` is _mostly_ equivalent to\n  `import file arg`, the latter returns a module without a location,\n  as `import` only returns the contained expression. This leads to worse\n  error messages.\n\n- Using `specialArgs` to provide arguments to all modules. This effectively\n  creates an incomplete module, and requires the user of the module to\n  manually pass the `specialArgs` to the configuration, which is error-prone,\n  verbose, and unnecessary.\n\nThe nix file must contain a function that returns a module.\nA module may itself be a function, so the file is often a function with two\npositional arguments instead of one. See the example below.\n\nThis function does not add support for deduplication and `disabledModules`,\nalthough that could be achieved by wrapping the returned module and setting\nthe `_key` module attribute.\nThe reason for this omission is that the file path is not guaranteed to be\na unique identifier for the module, as two instances of the module may\nreference different `arg`s in their closures.\n\nExample\n\n    # lib.nix\n    imports = [\n      (lib.modules.importApply ./module.nix { bar = bar; })\n    ];\n\n    # module.nix\n    { bar }:\n    { lib, config, ... }:\n    {\n      options = ...;\n      config = ... bar ...;\n    }\n\n",
  "lib.modules.importJSON": "\nUse this function to import a JSON file as NixOS configuration.\n\nmodules.importJSON :: path -> attrs\n\n\n# Inputs\n\n`file`\n\n: 1\\. Function argument\n",
  "lib.modules.importTOML": "\nUse this function to import a TOML file as NixOS configuration.\n\nmodules.importTOML :: path -> attrs\n\n\n# Inputs\n\n`file`\n\n: 1\\. Function argument\n",
  "lib.modules.mergeAttrDefinitionsWithPrio": "\nMerge an option's definitions in a way that preserves the priority of the\nindividual attributes in the option value.\n\nThis does not account for all option semantics, such as readOnly.\n\n\n# Inputs\n\n`opt`\n\n: 1\\. Function argument\n\n# Type\n\n```\noption -> attrsOf { highestPrio, value }\n```\n",
  "lib.modules.mergeDefinitions": "Merge definitions of a value of a given type.",
  "lib.modules.mergeModules": "\nMerge a list of modules.  This will recurse over the option\ndeclarations in all modules, combining them into a single set.\nAt the same time, for each option declaration, it will merge the\ncorresponding option definitions in all machines, returning them\nin the ‘value’ attribute of each option.\n\nThis returns a set like\n  {\n    # A recursive set of options along with their final values\n    matchedOptions = {\n      foo = { _type = \"option\"; value = \"option value of foo\"; ... };\n      bar.baz = { _type = \"option\"; value = \"option value of bar.baz\"; ... };\n      ...\n    };\n    # A list of definitions that weren't matched by any option\n    unmatchedDefns = [\n      { file = \"file.nix\"; prefix = [ \"qux\" ]; value = \"qux\"; }\n      ...\n    ];\n  }\n\n\n# Inputs\n\n`prefix`\n\n: 1\\. Function argument\n\n`modules`\n\n: 2\\. Function argument\n",
  "lib.modules.mergeModules' (Prime)": null,
  "lib.modules.mergeOptionDecls": "\nMerge multiple option declarations into a single declaration.  In\ngeneral, there should be only one declaration of each option.\nThe exception is the ‘options’ attribute, which specifies\nsub-options.  These can be specified multiple times to allow one\nmodule to add sub-options to an option declared somewhere else\n(e.g. multiple modules define sub-options for ‘fileSystems’).\n\n'loc' is the list of attribute names where the option is located.\n\n'opts' is a list of modules.  Each module has an options attribute which\ncorrespond to the definition of 'loc' in 'opt.file'.\n\n\n# Inputs\n\n`loc`\n\n: 1\\. Function argument\n\n`opts`\n\n: 2\\. Function argument\n",
  "lib.modules.mkAfter": null,
  "lib.modules.mkAliasAndWrapDefinitions": null,
  "lib.modules.mkAliasAndWrapDefsWithPriority": "If a priority is not set, it assumes a priority of defaultOverridePriority.",
  "lib.modules.mkAliasDefinitions": null,
  "lib.modules.mkAliasIfDef": null,
  "lib.modules.mkAliasOptionModule": "\nLike ‘mkRenamedOptionModule’, but doesn't show a warning.\n\n\n# Inputs\n\n`from`\n\n: 1\\. Function argument\n\n`to`\n\n: 2\\. Function argument\n",
  "lib.modules.mkAliasOptionModuleMD": "\nLike ‘mkRenamedOptionModule’, but doesn't show a warning.\n\n\n# Inputs\n\n`from`\n\n: 1\\. Function argument\n\n`to`\n\n: 2\\. Function argument\n",
  "lib.modules.mkAssert": null,
  "lib.modules.mkBefore": null,
  "lib.modules.mkChangedOptionModule": "\nSingle \"from\" version of mkMergedOptionModule.\nReturn a module that causes a warning to be shown if the \"from\" option is\ndefined; the defined value can be used in the \"mergeFn\" to set the \"to\"\nvalue.\nThis function can be used to change an option into another that has a\ndifferent type.\n\n\"mergeFn\" takes the module \"config\" as a parameter and must return a value of\n\"to\" option type.\n\n  mkChangedOptionModule [ \"a\" \"b\" \"c\" ] [ \"x\" \"y\" \"z\" ]\n    (config:\n      let value = getAttrFromPath [ \"a\" \"b\" \"c\" ] config;\n      in\n      if   value > 100 then \"high\"\n      else \"normal\")\n\n- options.a.b.c is a removed int option\n- options.x.y.z is a new str option that supersedes a.b.c\n\nThis show a warning if a.b.c is set, and set the value of x.y.z to the\nresult of the change function\n\n\n# Inputs\n\n`from`\n\n: 1\\. Function argument\n\n`to`\n\n: 2\\. Function argument\n\n`changeFn`\n\n: 3\\. Function argument\n",
  "lib.modules.mkDefault": null,
  "lib.modules.mkDerivedConfig": "\nmkDerivedConfig : Option a -> (a -> Definition b) -> Definition b\n\nCreate config definitions with the same priority as the definition of another option.\nThis should be used for option definitions where one option sets the value of another as a convenience.\nFor instance a config file could be set with a `text` or `source` option, where text translates to a `source`\nvalue using `mkDerivedConfig options.text (pkgs.writeText \"filename.conf\")`.\n\nIt takes care of setting the right priority using `mkOverride`.\n\n\n# Inputs\n\n`opt`\n\n: 1\\. Function argument\n\n`f`\n\n: 2\\. Function argument\n",
  "lib.modules.mkFixStrictness": "\nThe identity function\nFor when you need a function that does “nothing”.\n\n\n# Inputs\n\n`x`\n\n: The value to return\n\n# Type\n\n```\nid :: a -> a\n```\n",
  "lib.modules.mkForce": null,
  "lib.modules.mkIf": "\nProperties.\n\n\n# Inputs\n\n`condition`\n\n: 1\\. Function argument\n\n`content`\n\n: 2\\. Function argument\n",
  "lib.modules.mkImageMediaOverride": null,
  "lib.modules.mkMerge": null,
  "lib.modules.mkMergedOptionModule": "\nReturn a module that causes a warning to be shown if any of the \"from\"\noption is defined; the defined values can be used in the \"mergeFn\" to set\nthe \"to\" value.\nThis function can be used to merge multiple options into one that has a\ndifferent type.\n\n\"mergeFn\" takes the module \"config\" as a parameter and must return a value\nof \"to\" option type.\n\n  mkMergedOptionModule\n    [ [ \"a\" \"b\" \"c\" ]\n      [ \"d\" \"e\" \"f\" ] ]\n    [ \"x\" \"y\" \"z\" ]\n    (config:\n      let value = p: getAttrFromPath p config;\n      in\n      if      (value [ \"a\" \"b\" \"c\" ]) == true then \"foo\"\n      else if (value [ \"d\" \"e\" \"f\" ]) == true then \"bar\"\n      else \"baz\")\n\n- options.a.b.c is a removed boolean option\n- options.d.e.f is a removed boolean option\n- options.x.y.z is a new str option that combines a.b.c and d.e.f\n  functionality\n\nThis show a warning if any a.b.c or d.e.f is set, and set the value of\nx.y.z to the result of the merge function\n\n\n# Inputs\n\n`from`\n\n: 1\\. Function argument\n\n`to`\n\n: 2\\. Function argument\n\n`mergeFn`\n\n: 3\\. Function argument\n",
  "lib.modules.mkOptionDefault": null,
  "lib.modules.mkOrder": null,
  "lib.modules.mkOverride": null,
  "lib.modules.mkRemovedOptionModule": "\nReturn a module that causes a warning to be shown if the\nspecified option is defined. For example,\n\n  mkRemovedOptionModule [ \"boot\" \"loader\" \"grub\" \"bootDevice\" ] \"<replacement instructions>\"\n\ncauses a assertion if the user defines boot.loader.grub.bootDevice.\n\nreplacementInstructions is a string that provides instructions on\nhow to achieve the same functionality without the removed option,\nor alternatively a reasoning why the functionality is not needed.\nreplacementInstructions SHOULD be provided!\n\n\n# Inputs\n\n`optionName`\n\n: 1\\. Function argument\n\n`replacementInstructions`\n\n: 2\\. Function argument\n",
  "lib.modules.mkRenamedOptionModule": "\nReturn a module that causes a warning to be shown if the\nspecified \"from\" option is defined; the defined value is however\nforwarded to the \"to\" option. This can be used to rename options\nwhile providing backward compatibility. For example,\n\n  mkRenamedOptionModule [ \"boot\" \"copyKernels\" ] [ \"boot\" \"loader\" \"grub\" \"copyKernels\" ]\n\nforwards any definitions of boot.copyKernels to\nboot.loader.grub.copyKernels while printing a warning.\n\nThis also copies over the priority from the aliased option to the\nnon-aliased option.\n\n\n# Inputs\n\n`from`\n\n: 1\\. Function argument\n\n`to`\n\n: 2\\. Function argument\n",
  "lib.modules.mkRenamedOptionModuleWith": null,
  "lib.modules.mkVMOverride": null,
  "lib.modules.pushDownProperties": "\nGiven a config set, expand mkMerge properties, and push down the\nother properties into the children.  The result is a list of\nconfig sets that do not have properties at top-level.  For\nexample,\n\n  mkMerge [ { boot = set1; } (mkIf cond { boot = set2; services = set3; }) ]\n\nis transformed into\n\n  [ { boot = set1; } { boot = mkIf cond set2; services = mkIf cond set3; } ].\n\nThis transform is the critical step that allows mkIf conditions\nto refer to the full configuration without creating an infinite\nrecursion.\n\n\n# Inputs\n\n`cfg`\n\n: 1\\. Function argument\n",
  "lib.modules.setDefaultModuleLocation": "\nWrap a module with a default location for reporting errors.\n\n\n# Inputs\n\n`file`\n\n: 1\\. Function argument\n\n`m`\n\n: 2\\. Function argument\n",
  "lib.modules.sortProperties": "\nSort a list of properties.  The sort priority of a property is\ndefaultOrderPriority by default, but can be overridden by wrapping the property\nusing mkOrder.\n\n\n# Inputs\n\n`defs`\n\n: 1\\. Function argument\n",
  "lib.modules.unifyModuleSyntax": "\nMassage a module into canonical form, that is, a set consisting\nof ‘options’, ‘config’ and ‘imports’ attributes.\n\n\n# Inputs\n\n`file`\n\n: 1\\. Function argument\n\n`key`\n\n: 2\\. Function argument\n\n`m`\n\n: 3\\. Function argument\n",
  "lib.options.getFiles": "\nExtracts values of all \"file\" keys of the given list\n\n# Type\n\n```\ngetFiles :: [ { file :: a; } ] -> [a]\n```\n\n# Examples\n:::{.example}\n## `getFiles` usage example\n\n```nix\ngetFiles [ { file = \"file1\"; } { file = \"file2\"; } ] // => [ \"file1\" \"file2\" ]\ngetFiles [ ]                                         // => [ ]\n```\n\n:::\n",
  "lib.options.getValues": "\nExtracts values of all \"value\" keys of the given list.\n\n# Type\n\n```\ngetValues :: [ { value :: a; } ] -> [a]\n```\n\n# Examples\n:::{.example}\n## `getValues` usage example\n\n```nix\ngetValues [ { value = 1; } { value = 2; } ] // => [ 1 2 ]\ngetValues [ ]                               // => [ ]\n```\n\n:::\n",
  "lib.options.isOption": "\nReturns true when the given argument `a` is an option\n\n# Inputs\n\n`a`\n: Any value to check whether it is an option\n\n# Examples\n:::{.example}\n## `lib.options.isOption` usage example\n\n```nix\nisOption 1             // => false\nisOption (mkOption {}) // => true\n```\n\n:::\n\n# Type\n\n```\nisOption :: a -> Bool\n```\n\n",
  "lib.options.literalExample": "\nFor use in the `defaultText` and `example` option attributes. Causes the\ngiven string to be rendered verbatim in the documentation as Nix code. This\nis necessary for complex values, e.g. functions, or values that depend on\nother values or packages.\n\n\n# Inputs\n\n`text`\n\n: 1\\. Function argument\n",
  "lib.options.literalExpression": "\nFor use in the `defaultText` and `example` option attributes. Causes the\ngiven string to be rendered verbatim in the documentation as Nix code. This\nis necessary for complex values, e.g. functions, or values that depend on\nother values or packages.\n\n\n# Inputs\n\n`text`\n\n: 1\\. Function argument\n",
  "lib.options.literalMD": "\nFor use in the `defaultText` and `example` option attributes. Causes the\ngiven MD text to be inserted verbatim in the documentation, for when\na `literalExpression` would be too hard to read.\n\n\n# Inputs\n\n`text`\n\n: 1\\. Function argument\n",
  "lib.options.mergeDefaultOption": "\nA merge function that merges multiple definitions of an option into a single value\n\n:::{.caution}\nThis function is used as the default merge operation in `lib.types.mkOptionType`. In most cases, explicit usage of this function is unnecessary.\n:::\n\n# Inputs\n\n`loc`\n: location of the option in the configuration as a list of strings.\n\n  e.g. `[\"boot\" \"loader \"grub\" \"enable\"]`\n\n`defs`\n: list of definition values and locations.\n\n  e.g. `[ { file = \"/foo.nix\"; value = 1; } { file = \"/bar.nix\"; value = 2 } ]`\n\n# Example\n:::{.example}\n## `lib.options.mergeDefaultOption` usage example\n\n```nix\nmyType = mkOptionType {\n  name = \"myType\";\n  merge = mergeDefaultOption; # <- This line is redundant. It is the default aready.\n};\n```\n\n:::\n\n# Merge behavior\n\nMerging requires all definition values to have the same type.\n\n- If all definitions are booleans, the result of a `foldl'` with the `or` operation is returned.\n- If all definitions are strings, they are concatenated. (`lib.concatStrings`)\n- If all definitions are integers and all are equal, the first one is returned.\n- If all definitions are lists, they are concatenated. (`++`)\n- If all definitions are attribute sets, they are merged. (`lib.mergeAttrs`)\n- If all definitions are functions, the first function is applied to the result of the second function. (`f -> x: f x`)\n- Otherwise, an error is thrown.\n\n",
  "lib.options.mergeEqualOption": "\n\"Merge\" option definitions by checking that they all have the same value.\n\n\n# Inputs\n\n`loc`\n\n: 1\\. Function argument\n\n`defs`\n\n: 2\\. Function argument\n",
  "lib.options.mergeOneOption": "\nRequire a single definition.\n\nWARNING: Does not perform nested checks, as this does not run the merge function!\n",
  "lib.options.mergeUniqueOption": "\nRequire a single definition.\n\nNOTE: When the type is not checked completely by check, pass a merge function for further checking (of sub-attributes, etc).\n\n\n# Inputs\n\n`loc`\n\n: 2\\. Function argument\n\n`defs`\n\n: 3\\. Function argument\n",
  "lib.options.mkEnableOption": "\nCreates an option declaration with a default value of ´false´, and can be defined to ´true´.\n\n# Inputs\n\n`name`\n\n: Name for the created option\n\n# Examples\n:::{.example}\n## `lib.options.mkEnableOption` usage example\n\n```nix\n# module\nlet\n  eval = lib.evalModules {\n    modules = [\n      {\n        options.foo.enable = mkEnableOption \"foo\";\n\n        config.foo.enable = true;\n      }\n    ]:\n  }\nin\neval.config\n=> { foo.enable = true; }\n```\n\n:::\n",
  "lib.options.mkOption": "\nCreates an Option attribute set. mkOption accepts an attribute set with the following keys:\n\n# Inputs\n\nStructured attribute set\n: Attribute set containing none or some of the following attributes.\n\n  `default`\n  : Optional default value used when no definition is given in the configuration.\n\n  `defaultText`\n  : Substitute for documenting the `default`, if evaluating the default value during documentation rendering is not possible.\n  : Can be any nix value that evaluates.\n  : Usage with `lib.literalMD` or `lib.literalExpression` is supported\n\n\n  `example`\n  : Optional example value used in the manual.\n  : Can be any nix value that evaluates.\n  : Usage with `lib.literalMD` or `lib.literalExpression` is supported\n\n  `description`\n  : Optional string describing the option. This is required if option documentation is generated.\n\n  `relatedPackages`\n  : Optional related packages used in the manual (see `genRelatedPackages` in `../nixos/lib/make-options-doc/default.nix`).\n\n  `type`\n  : Optional option type, providing type-checking and value merging.\n\n  `apply`\n  : Optional function that converts the option value to something else.\n\n  `internal`\n  : Optional boolean indicating whether the option is for NixOS developers only.\n\n  `visible`\n  : Optional boolean indicating whether the option shows up in the manual. Default: true. Use false to hide the option and any sub-options from submodules. Use \"shallow\" to hide only sub-options.\n\n  `readOnly`\n  : Optional boolean indicating whether the option can be set only once.\n\n  `...` (any other attribute)\n  : Any other attribute is passed through to the resulting option attribute set.\n\n# Examples\n:::{.example}\n## `lib.options.mkOption` usage example\n\n```nix\nmkOption { }  // => { _type = \"option\"; }\nmkOption { default = \"foo\"; } // => { _type = \"option\"; default = \"foo\"; }\n```\n\n:::\n",
  "lib.options.mkPackageOption": "\nCreates an Option attribute set for an option that specifies the\npackage a module should use for some purpose.\n\nThe package is specified in the third argument under `default` as a list of strings\nrepresenting its attribute path in nixpkgs (or another package set).\nBecause of this, you need to pass nixpkgs itself (usually `pkgs` in a module;\nalternatively to nixpkgs itself, another package set) as the first argument.\n\nIf you pass another package set you should set the `pkgsText` option.\nThis option is used to display the expression for the package set. It is `\"pkgs\"` by default.\nIf your expression is complex you should parenthesize it, as the `pkgsText` argument\nis usually immediately followed by an attribute lookup (`.`).\n\nThe second argument may be either a string or a list of strings.\nIt provides the display name of the package in the description of the generated option\n(using only the last element if the passed value is a list)\nand serves as the fallback value for the `default` argument.\n\nTo include extra information in the description, pass `extraDescription` to\nappend arbitrary text to the generated description.\n\nYou can also pass an `example` value, either a literal string or an attribute path.\n\nThe `default` argument can be omitted if the provided name is\nan attribute of pkgs (if `name` is a string) or a valid attribute path in pkgs (if `name` is a list).\nYou can also set `default` to just a string in which case it is interpreted as an attribute name\n(a singleton attribute path, if you will).\n\nIf you wish to explicitly provide no default, pass `null` as `default`.\n\nIf you want users to be able to set no package, pass `nullable = true`.\nIn this mode a `default = null` will not be interpreted as no default and is interpreted literally.\n\n\n# Inputs\n\n`pkgs`\n\n: Package set (an instantiation of nixpkgs such as pkgs in modules or another package set)\n\n`name`\n\n: Name for the package, shown in option description\n\nStructured function argument\n: Attribute set containing the following attributes.\n\n  `nullable`\n  : Optional whether the package can be null, for example to disable installing a package altogether. Default: `false`\n\n  `default`\n  : Optional attribute path where the default package is located. Default: `name`\n    If omitted will be copied from `name`\n\n  `example`\n  : Optional string or an attribute path to use as an example. Default: `null`\n\n  `extraDescription`\n  : Optional additional text to include in the option description. Default: `\"\"`\n\n  `pkgsText`\n  : Optional representation of the package set passed as pkgs. Default: `\"pkgs\"`\n\n# Type\n\n```\nmkPackageOption :: pkgs -> (string|[string]) -> { nullable? :: bool, default? :: string|[string], example? :: null|string|[string], extraDescription? :: string, pkgsText? :: string } -> option\n```\n\n# Examples\n:::{.example}\n## `lib.options.mkPackageOption` usage example\n\n```nix\nmkPackageOption pkgs \"hello\" { }\n=> { ...; default = pkgs.hello; defaultText = literalExpression \"pkgs.hello\"; description = \"The hello package to use.\"; type = package; }\n\n\nmkPackageOption pkgs \"GHC\" {\n  default = [ \"ghc\" ];\n  example = \"pkgs.haskell.packages.ghc92.ghc.withPackages (hkgs: [ hkgs.primes ])\";\n}\n=> { ...; default = pkgs.ghc; defaultText = literalExpression \"pkgs.ghc\"; description = \"The GHC package to use.\"; example = literalExpression \"pkgs.haskell.packages.ghc92.ghc.withPackages (hkgs: [ hkgs.primes ])\"; type = package; }\n\n\nmkPackageOption pkgs [ \"python3Packages\" \"pytorch\" ] {\n  extraDescription = \"This is an example and doesn't actually do anything.\";\n}\n=> { ...; default = pkgs.python3Packages.pytorch; defaultText = literalExpression \"pkgs.python3Packages.pytorch\"; description = \"The pytorch package to use. This is an example and doesn't actually do anything.\"; type = package; }\n\n\nmkPackageOption pkgs \"nushell\" {\n  nullable = true;\n}\n=> { ...; default = pkgs.nushell; defaultText = literalExpression \"pkgs.nushell\"; description = \"The nushell package to use.\"; type = nullOr package; }\n\n\nmkPackageOption pkgs \"coreutils\" {\n  default = null;\n}\n=> { ...; description = \"The coreutils package to use.\"; type = package; }\n\n\nmkPackageOption pkgs \"dbus\" {\n  nullable = true;\n  default = null;\n}\n=> { ...; default = null; description = \"The dbus package to use.\"; type = nullOr package; }\n\n\nmkPackageOption pkgs.javaPackages \"OpenJFX\" {\n  default = \"openjfx20\";\n  pkgsText = \"pkgs.javaPackages\";\n}\n=> { ...; default = pkgs.javaPackages.openjfx20; defaultText = literalExpression \"pkgs.javaPackages.openjfx20\"; description = \"The OpenJFX package to use.\"; type = package; }\n```\n\n:::\n",
  "lib.options.mkPackageOptionMD": "\nDeprecated alias of mkPackageOption, to be removed in 25.05.\n\nPreviously used to create options with markdown documentation, which is no longer required.\n",
  "lib.options.mkSinkUndeclaredOptions": "\nThis option accepts arbitrary definitions, but it does not produce an option value.\n\nThis is useful for sharing a module across different module sets\nwithout having to implement similar features as long as the\nvalues of the options are not accessed.\n\n\n# Inputs\n\n`attrs`\n\n: Attribute set whose attributes override the argument to `mkOption`.\n",
  "lib.options.optionAttrSetToDocList": null,
  "lib.options.optionAttrSetToDocList' (Prime)": null,
  "lib.options.renderOptionValue": "\nEnsures that the given option value (default or example) is a `_type`d string\nby rendering Nix values to `literalExpression`s.\n\n\n# Inputs\n\n`v`\n\n: 1\\. Function argument\n",
  "lib.options.scrubOptionValue": "\nThis function recursively removes all derivation attributes from\n`x` except for the `name` attribute.\n\nThis is to make the generation of `options.xml` much more\nefficient: the XML representation of derivations is very large\n(on the order of megabytes) and is not actually used by the\nmanual generator.\n\nThis function was made obsolete by renderOptionValue and is kept for\ncompatibility with out-of-tree code.\n\n\n# Inputs\n\n`x`\n\n: 1\\. Function argument\n",
  "lib.options.showDefs": null,
  "lib.options.showFiles": null,
  "lib.options.showOption": "\nConvert an option, described as a list of the option parts to a\nhuman-readable version.\n\n\n# Inputs\n\n`parts`\n\n: 1\\. Function argument\n\n\n# Examples\n:::{.example}\n## `showOption` usage example\n\n```nix\n(showOption [\"foo\" \"bar\" \"baz\"]) == \"foo.bar.baz\"\n  (showOption [\"foo\" \"bar.baz\" \"tux\"]) == \"foo.\\\"bar.baz\\\".tux\"\n  (showOption [\"windowManager\" \"2bwm\" \"enable\"]) == \"windowManager.\\\"2bwm\\\".enable\"\n\nPlaceholders will not be quoted as they are not actual values:\n  (showOption [\"foo\" \"*\" \"bar\"]) == \"foo.*.bar\"\n  (showOption [\"foo\" \"<name>\" \"bar\"]) == \"foo.<name>.bar\"\n  (showOption [\"foo\" \"<myPlaceholder>\" \"bar\"]) == \"foo.<myPlaceholder>.bar\"\n```\n\n:::\n",
  "lib.options.showOptionWithDefLocs": "\nPretty prints all option definition locations\n\n# Inputs\n\n`option`\n: The option to pretty print\n\n# Examples\n:::{.example}\n## `lib.options.showOptionWithDefLocs` usage example\n\n\n```nix\nshowOptionWithDefLocs { loc = [\"x\" \"y\" ]; files = [ \"foo.nix\" \"bar.nix\" ];  }\n\"x.y, with values defined in:\\n  - foo.nix\\n  - bar.nix\\n\"\n```\n\n```nix\nnix-repl> eval = lib.evalModules {\n    modules = [\n      {\n        options = {\n          foo = lib.mkEnableOption \"foo\";\n        };\n      }\n    ];\n  }\n\nnix-repl> lib.options.showOptionWithDefLocs eval.options.foo\n\"foo, with values defined in:\\n  - <unknown-file>\\n\"\n```\n\n:::\n\n# Type\n\n```\nshowDefsSep :: { files :: [ String ]; loc :: [ String ]; ... } -> string\n```\n",
  "lib.path.append": "\nAppend a subpath string to a path.\n\nLike `path + (\"/\" + string)` but safer, because it errors instead of returning potentially surprising results.\nMore specifically, it checks that the first argument is a [path value type](https://nixos.org/manual/nix/stable/language/values.html#type-path\"),\nand that the second argument is a [valid subpath string](#function-library-lib.path.subpath.isValid).\n\nLaws:\n\n- Not influenced by subpath [normalisation](#function-library-lib.path.subpath.normalise):\n\n      append p s == append p (subpath.normalise s)\n\n# Inputs\n\n`path`\n\n: The absolute path to append to\n\n`subpath`\n\n: The subpath string to append\n\n# Type\n\n```\nappend :: Path -> String -> Path\n```\n\n# Examples\n:::{.example}\n## `append` usage example\n\n```nix\nappend /foo \"bar/baz\"\n=> /foo/bar/baz\n\n# subpaths don't need to be normalised\nappend /foo \"./bar//baz/./\"\n=> /foo/bar/baz\n\n# can append to root directory\nappend /. \"foo/bar\"\n=> /foo/bar\n\n# first argument needs to be a path value type\nappend \"/foo\" \"bar\"\n=> <error>\n\n# second argument needs to be a valid subpath string\nappend /foo /bar\n=> <error>\nappend /foo \"\"\n=> <error>\nappend /foo \"/bar\"\n=> <error>\nappend /foo \"../bar\"\n=> <error>\n```\n\n:::\n",
  "lib.path.hasPrefix": "\nWhether the first path is a component-wise prefix of the second path.\n\nLaws:\n\n- `hasPrefix p q` is only true if [`q == append p s`](#function-library-lib.path.append) for some [subpath](#function-library-lib.path.subpath.isValid) `s`.\n\n- `hasPrefix` is a [non-strict partial order](https://en.wikipedia.org/wiki/Partially_ordered_set#Non-strict_partial_order) over the set of all path values.\n\n# Inputs\n\n`path1`\n\n: 1\\. Function argument\n\n# Type\n\n```\nhasPrefix :: Path -> Path -> Bool\n```\n\n# Examples\n:::{.example}\n## `hasPrefix` usage example\n\n```nix\nhasPrefix /foo /foo/bar\n=> true\nhasPrefix /foo /foo\n=> true\nhasPrefix /foo/bar /foo\n=> false\nhasPrefix /. /foo\n=> true\n```\n\n:::\n",
  "lib.path.hasStorePathPrefix": "\nWhether a [path](https://nixos.org/manual/nix/stable/language/values.html#type-path)\nhas a [store path](https://nixos.org/manual/nix/stable/store/store-path.html#store-path)\nas a prefix.\n\n:::{.note}\nAs with all functions of this `lib.path` library, it does not work on paths in strings,\nwhich is how you'd typically get store paths.\n\nInstead, this function only handles path values themselves,\nwhich occur when Nix files in the store use relative path expressions.\n:::\n\n# Inputs\n\n`path`\n\n: 1\\. Function argument\n\n# Type\n\n```\nhasStorePathPrefix :: Path -> Bool\n```\n\n# Examples\n:::{.example}\n## `hasStorePathPrefix` usage example\n\n```nix\n# Subpaths of derivation outputs have a store path as a prefix\nhasStorePathPrefix /nix/store/nvl9ic0pj1fpyln3zaqrf4cclbqdfn1j-foo/bar/baz\n=> true\n\n# The store directory itself is not a store path\nhasStorePathPrefix /nix/store\n=> false\n\n# Derivation outputs are store paths themselves\nhasStorePathPrefix /nix/store/nvl9ic0pj1fpyln3zaqrf4cclbqdfn1j-foo\n=> true\n\n# Paths outside the Nix store don't have a store path prefix\nhasStorePathPrefix /home/user\n=> false\n\n# Not all paths under the Nix store are store paths\nhasStorePathPrefix /nix/store/.links/10gg8k3rmbw8p7gszarbk7qyd9jwxhcfq9i6s5i0qikx8alkk4hq\n=> false\n\n# Store derivations are also store paths themselves\nhasStorePathPrefix /nix/store/nvl9ic0pj1fpyln3zaqrf4cclbqdfn1j-foo.drv\n=> true\n```\n\n:::\n",
  "lib.path.removePrefix": "\nRemove the first path as a component-wise prefix from the second path.\nThe result is a [normalised subpath string](#function-library-lib.path.subpath.normalise).\n\nLaws:\n\n- Inverts [`append`](#function-library-lib.path.append) for [normalised subpath string](#function-library-lib.path.subpath.normalise):\n\n      removePrefix p (append p s) == subpath.normalise s\n\n# Inputs\n\n`path1`\n\n: 1\\. Function argument\n\n# Type\n\n```\nremovePrefix :: Path -> Path -> String\n```\n\n# Examples\n:::{.example}\n## `removePrefix` usage example\n\n```nix\nremovePrefix /foo /foo/bar/baz\n=> \"./bar/baz\"\nremovePrefix /foo /foo\n=> \"./.\"\nremovePrefix /foo/bar /foo\n=> <error>\nremovePrefix /. /foo\n=> \"./foo\"\n```\n\n:::\n",
  "lib.path.splitRoot": "\nSplit the filesystem root from a [path](https://nixos.org/manual/nix/stable/language/values.html#type-path).\nThe result is an attribute set with these attributes:\n- `root`: The filesystem root of the path, meaning that this directory has no parent directory.\n- `subpath`: The [normalised subpath string](#function-library-lib.path.subpath.normalise) that when [appended](#function-library-lib.path.append) to `root` returns the original path.\n\nLaws:\n- [Appending](#function-library-lib.path.append) the `root` and `subpath` gives the original path:\n\n      p ==\n        append\n          (splitRoot p).root\n          (splitRoot p).subpath\n\n- Trying to get the parent directory of `root` using [`readDir`](https://nixos.org/manual/nix/stable/language/builtins.html#builtins-readDir) returns `root` itself:\n\n      dirOf (splitRoot p).root == (splitRoot p).root\n\n# Inputs\n\n`path`\n\n: The path to split the root off of\n\n# Type\n\n```\nsplitRoot :: Path -> { root :: Path, subpath :: String }\n```\n\n# Examples\n:::{.example}\n## `splitRoot` usage example\n\n```nix\nsplitRoot /foo/bar\n=> { root = /.; subpath = \"./foo/bar\"; }\n\nsplitRoot /.\n=> { root = /.; subpath = \"./.\"; }\n\n# Nix neutralises `..` path components for all path values automatically\nsplitRoot /foo/../bar\n=> { root = /.; subpath = \"./bar\"; }\n\nsplitRoot \"/foo/bar\"\n=> <error>\n```\n\n:::\n",
  "lib.sources.canCleanSource": null,
  "lib.sources.cleanSource": "\nFilters a source tree removing version control files and directories using cleanSourceFilter.\n\n# Inputs\n\n`src`\n\n: 1\\. Function argument\n\n# Examples\n:::{.example}\n## `cleanSource` usage example\n\n```nix\ncleanSource ./.\n```\n\n:::\n",
  "lib.sources.cleanSourceFilter": "\nA basic filter for `cleanSourceWith` that removes\ndirectories of version control system, backup files (*~)\nand some generated files.\n\n# Inputs\n\n`name`\n\n: 1\\. Function argument\n\n`type`\n\n: 2\\. Function argument\n",
  "lib.sources.cleanSourceWith": "\nLike `builtins.filterSource`, except it will compose with itself,\nallowing you to chain multiple calls together without any\nintermediate copies being put in the nix store.\n\n# Examples\n:::{.example}\n## `cleanSourceWith` usage example\n\n```nix\nlib.cleanSourceWith {\n  filter = f;\n  src = lib.cleanSourceWith {\n    filter = g;\n    src = ./.;\n  };\n}\n# Succeeds!\n\nbuiltins.filterSource f (builtins.filterSource g ./.)\n# Fails!\n```\n\n:::\n",
  "lib.sources.commitIdFromGitRepo": "\nGet the commit id of a git repo.\n\n# Inputs\n\n`path`\n\n: 1\\. Function argument\n\n# Examples\n:::{.example}\n## `commitIdFromGitRepo` usage example\n\n```nix\ncommitIdFromGitRepo <nixpkgs/.git>\n```\n\n:::\n",
  "lib.sources.pathHasContext": "\nReturn `true` if string *s* has a non-empty context.\nThe context can be obtained with\n[`getContext`](#builtins-getContext).\n\n> **Example**\n>\n> Many operations require a string context to be empty because they are intended only to work with \"regular\" strings, and also to help users avoid unintentionally loosing track of string context elements.\n> `builtins.hasContext` can help create better domain-specific errors in those case.\n>\n> ```nix\n> name: meta:\n>\n> if builtins.hasContext name\n> then throw \"package name cannot contain string context\"\n> else { ${name} = meta; }\n> ```\n",
  "lib.sources.pathIsDirectory": "\nWhether a path exists and is a directory.\n\n\n# Inputs\n\n`path`\n\n: 1\\. Function argument\n\n# Type\n\n```\npathIsDirectory :: Path -> Bool\n```\n\n# Examples\n:::{.example}\n## `lib.filesystem.pathIsDirectory` usage example\n\n```nix\npathIsDirectory /.\n=> true\n\npathIsDirectory /this/does/not/exist\n=> false\n\npathIsDirectory /some/file.nix\n=> false\n```\n\n:::\n",
  "lib.sources.pathIsGitRepo": null,
  "lib.sources.pathIsRegularFile": "\nWhether a path exists and is a regular file, meaning not a symlink or any other special file type.\n\n\n# Inputs\n\n`path`\n\n: 1\\. Function argument\n\n# Type\n\n```\npathIsRegularFile :: Path -> Bool\n```\n\n# Examples\n:::{.example}\n## `lib.filesystem.pathIsRegularFile` usage example\n\n```nix\npathIsRegularFile /.\n=> false\n\npathIsRegularFile /this/does/not/exist\n=> false\n\npathIsRegularFile /some/file.nix\n=> true\n```\n\n:::\n",
  "lib.sources.pathType": "\nThe type of a path. The path needs to exist and be accessible.\nThe result is either \"directory\" for a directory, \"regular\" for a regular file, \"symlink\" for a symlink, or \"unknown\" for anything else.\n\n# Inputs\n\npath\n\n: The path to query\n\n# Type\n\n```\npathType :: Path -> String\n```\n\n# Examples\n:::{.example}\n## `lib.filesystem.pathType` usage example\n\n```nix\npathType /.\n=> \"directory\"\n\npathType /some/file.nix\n=> \"regular\"\n```\n\n:::\n",
  "lib.sources.sourceByRegex": "\nFilter sources by a list of regular expressions.\n\n# Inputs\n\n`src`\n\n: 1\\. Function argument\n\n`regexes`\n\n: 2\\. Function argument\n\n# Examples\n:::{.example}\n## `sourceByRegex` usage example\n\n```nix\nsrc = sourceByRegex ./my-subproject [\".*\\.py$\" \"^database.sql$\"]\n```\n\n:::\n",
  "lib.sources.sourceFilesBySuffices": "\nGet all files ending with the specified suffices from the given\nsource directory or its descendants, omitting files that do not match\nany suffix. The result of the example below will include files like\n`./dir/module.c` and `./dir/subdir/doc.xml` if present.\n\n# Inputs\n\n`src`\n\n: Path or source containing the files to be returned\n\n`exts`\n\n: A list of file suffix strings\n\n# Type\n\n```\nsourceLike -> [String] -> Source\n```\n\n# Examples\n:::{.example}\n## `sourceFilesBySuffices` usage example\n\n```nix\nsourceFilesBySuffices ./. [ \".xml\" \".c\" ]\n```\n\n:::\n",
  "lib.sources.trace": "\nAdd logging to a source, for troubleshooting the filtering behavior.\n\n# Inputs\n\n`src`\n\n: Source to debug. The returned source will behave like this source, but also log its filter invocations.\n\n# Type\n\n```\nsources.trace :: sourceLike -> Source\n```\n",
  "lib.strings.addContextFrom": "\nAppends string context from string like object `src` to `target`.\n\n:::{.warning}\nThis is an implementation\ndetail of Nix and should be used carefully.\n:::\n\nStrings in Nix carry an invisible `context` which is a list of strings\nrepresenting store paths. If the string is later used in a derivation\nattribute, the derivation will properly populate the inputDrvs and\ninputSrcs.\n\n\n# Inputs\n\n`src`\n: The string to take the context from. If the argument is not a string,\n  it will be implicitly converted to a string.\n\n`target`\n: The string to append the context to. If the argument is not a string,\n  it will be implicitly converted to a string.\n\n# Type\n\n```\naddContextFrom :: string -> string -> string\n```\n\n# Examples\n:::{.example}\n## `lib.strings.addContextFrom` usage example\n\n```nix\npkgs = import <nixpkgs> { };\naddContextFrom pkgs.coreutils \"bar\"\n=> \"bar\"\n```\n\nThe context can be displayed using the `toString` function:\n\n```nix\nnix-repl> builtins.getContext (lib.strings.addContextFrom pkgs.coreutils \"bar\")\n{\n  \"/nix/store/m1s1d2dk2dqqlw3j90jl3cjy2cykbdxz-coreutils-9.5.drv\" = { ... };\n}\n```\n\n:::\n",
  "lib.strings.charToInt": "\nConvert char to ascii value, must be in printable range\n\n\n# Inputs\n\n`c`\n: 1\\. Function argument\n\n# Type\n\n```\ncharToInt :: string -> int\n```\n\n# Examples\n:::{.example}\n## `lib.strings.charToInt` usage example\n\n```nix\ncharToInt \"A\"\n=> 65\ncharToInt \"(\"\n=> 40\n```\n\n:::\n",
  "lib.strings.cmakeBool": "\nCreate a -D<condition>={TRUE,FALSE} string that can be passed to typical\nCMake invocations.\n\n\n# Inputs\n\n`condition`\n: The condition to be made true or false\n\n`flag`\n: The controlling flag of the condition\n\n# Type\n\n```\ncmakeBool :: string -> bool -> string\n```\n\n# Examples\n:::{.example}\n## `lib.strings.cmakeBool` usage example\n\n```nix\ncmakeBool \"ENABLE_STATIC_LIBS\" false\n=> \"-DENABLESTATIC_LIBS:BOOL=FALSE\"\n```\n\n:::\n",
  "lib.strings.cmakeFeature": "\nCreate a -D<feature>:STRING=<value> string that can be passed to typical\nCMake invocations.\nThis is the most typical usage, so it deserves a special case.\n\n\n# Inputs\n\n`feature`\n: The feature to be set\n\n`value`\n: The desired value\n\n\n# Type\n\n```\ncmakeFeature :: string -> string -> string\n```\n\n# Examples\n:::{.example}\n## `lib.strings.cmakeFeature` usage example\n\n```nix\ncmakeFeature \"MODULES\" \"badblock\"\n=> \"-DMODULES:STRING=badblock\"\n```\n\n:::\n",
  "lib.strings.cmakeOptionType": "\nCreate a `\"-D<feature>:<type>=<value>\"` string that can be passed to typical\nCMake invocations.\n\n# Inputs\n\n`feature`\n: The feature to be set\n\n`type`\n: The type of the feature to be set, as described in\n  https://cmake.org/cmake/help/latest/command/set.html\n  the possible values (case insensitive) are:\n  BOOL FILEPATH PATH STRING INTERNAL\n\n`value`\n: The desired value\n\n# Type\n\n```\ncmakeOptionType :: string -> string -> string -> string\n```\n\n# Examples\n:::{.example}\n## `lib.strings.cmakeOptionType` usage example\n\n```nix\ncmakeOptionType \"string\" \"ENGINE\" \"sdl2\"\n=> \"-DENGINE:STRING=sdl2\"\n```\n\n:::\n",
  "lib.strings.commonPrefixLength": "\nReturns the length of the prefix that appears in both strings `a` and `b`.\n\n\n# Inputs\n\n`a`\n: 1\\. Function argument\n\n`b`\n: 2\\. Function argument\n\n# Type\n\n```\ncommonPrefixLength :: string -> string -> int\n```\n",
  "lib.strings.commonSuffixLength": "\nReturns the length of the suffix common to both strings `a` and `b`.\n\n\n# Inputs\n\n`a`\n: 1\\. Function argument\n\n`b`\n: 2\\. Function argument\n\n# Type\n\n```\ncommonSuffixLength :: string -> string -> int\n```\n",
  "lib.strings.compareVersions": "\nCompare two strings representing versions and return `-1` if\nversion *s1* is older than version *s2*, `0` if they are the same,\nand `1` if *s1* is newer than *s2*. The version comparison\nalgorithm is the same as the one used by [`nix-env\n-u`](../command-ref/nix-env.md#operation---upgrade).\n",
  "lib.strings.concatImapStrings": "\nLike `concatMapStrings` except that the f functions also gets the\nposition as a parameter.\n\n\n# Inputs\n\n`f`\n: 1\\. Function argument\n\n`list`\n: 2\\. Function argument\n\n# Type\n\n```\nconcatImapStrings :: (int -> a -> string) -> [a] -> string\n```\n\n# Examples\n:::{.example}\n## `lib.strings.concatImapStrings` usage example\n\n```nix\nconcatImapStrings (pos: x: \"${toString pos}-${x}\") [\"foo\" \"bar\"]\n=> \"1-foo2-bar\"\n```\n\n:::\n",
  "lib.strings.concatImapStringsSep": "\nSame as `concatMapStringsSep`, but the mapping function\nadditionally receives the position of its argument.\n\n\n# Inputs\n\n`sep`\n: Separator to add between elements\n\n`f`\n: Function that receives elements and their positions\n\n`list`\n: List of input strings\n\n# Type\n\n```\nconcatIMapStringsSep :: string -> (int -> a -> string) -> [a] -> string\n```\n\n# Examples\n:::{.example}\n## `lib.strings.concatImapStringsSep` usage example\n\n```nix\nconcatImapStringsSep \"-\" (pos: x: toString (x / pos)) [ 6 6 6 ]\n=> \"6-3-2\"\n```\n\n:::\n",
  "lib.strings.concatLines": "\nConcatenate a list of strings, adding a newline at the end of each one.\nDefined as `concatMapStrings (s: s + \"\\n\")`.\n\n# Inputs\n\n`list`\n: List of strings. Any element that is not a string will be implicitly converted to a string.\n\n# Type\n\n```\nconcatLines :: [string] -> string\n```\n\n# Examples\n:::{.example}\n## `lib.strings.concatLines` usage example\n\n```nix\nconcatLines [ \"foo\" \"bar\" ]\n=> \"foo\\nbar\\n\"\n```\n\n:::\n",
  "lib.strings.concatMapAttrsStringSep": "\nLike [`concatMapStringsSep`](#function-library-lib.strings.concatMapStringsSep)\nbut takes an attribute set instead of a list.\n\n# Inputs\n\n`sep`\n: Separator to add between item strings\n\n`f`\n: Function that takes each key and value and return a string\n\n`attrs`\n: Attribute set to map from\n\n# Type\n\n```\nconcatMapAttrsStringSep :: String -> (String -> Any -> String) -> AttrSet -> String\n```\n\n# Examples\n\n:::{.example}\n## `lib.strings.concatMapAttrsStringSep` usage example\n\n```nix\nconcatMapAttrsStringSep \"\\n\" (name: value: \"${name}: foo-${value}\") { a = \"0.1.0\"; b = \"0.2.0\"; }\n=> \"a: foo-0.1.0\\nb: foo-0.2.0\"\n```\n\n:::\n",
  "lib.strings.concatMapStrings": "\nMap a function over a list and concatenate the resulting strings.\n\n\n# Inputs\n\n`f`\n: 1\\. Function argument\n\n`list`\n: 2\\. Function argument\n\n# Type\n\n```\nconcatMapStrings :: (a -> string) -> [a] -> string\n```\n\n# Examples\n:::{.example}\n## `lib.strings.concatMapStrings` usage example\n\n```nix\nconcatMapStrings (x: \"a\" + x) [\"foo\" \"bar\"]\n=> \"afooabar\"\n```\n\n:::\n",
  "lib.strings.concatMapStringsSep": "\nMaps a function over a list of strings and then concatenates the\nresult with the specified separator interspersed between\nelements.\n\n\n# Inputs\n\n`sep`\n: Separator to add between elements\n\n`f`\n: Function to map over the list\n\n`list`\n: List of input strings\n\n# Type\n\n```\nconcatMapStringsSep :: string -> (a -> string) -> [a] -> string\n```\n\n# Examples\n:::{.example}\n## `lib.strings.concatMapStringsSep` usage example\n\n```nix\nconcatMapStringsSep \"-\" (x: toUpper x)  [\"foo\" \"bar\" \"baz\"]\n=> \"FOO-BAR-BAZ\"\n```\n\n:::\n",
  "lib.strings.concatStrings": "\nConcatenate a list of strings.\n\n# Type\n\n```\nconcatStrings :: [string] -> string\n```\n\n# Examples\n:::{.example}\n## `lib.strings.concatStrings` usage example\n\n```nix\nconcatStrings [\"foo\" \"bar\"]\n=> \"foobar\"\n```\n\n:::\n",
  "lib.strings.concatStringsSep": "\nConcatenate a list of strings with a separator between each element\n\n# Inputs\n\n`sep`\n: Separator to add between elements\n\n`list`\n: List of input strings\n\n# Type\n\n```\nconcatStringsSep :: string -> [string] -> string\n```\n\n# Examples\n:::{.example}\n## `lib.strings.concatStringsSep` usage example\n\n```nix\nconcatStringsSep \"/\" [\"usr\" \"local\" \"bin\"]\n=> \"usr/local/bin\"\n```\n\n:::\n",
  "lib.strings.elem": "\nReturn `true` if a value equal to *x* occurs in the list *xs*, and\n`false` otherwise.\n",
  "lib.strings.elemAt": "\nReturn element *n* from the list *xs*. Elements are counted starting\nfrom 0. A fatal error occurs if the index is out of bounds.\n",
  "lib.strings.enableFeature": "\nCreate an --{enable,disable}-<feature> string that can be passed to\nstandard GNU Autoconf scripts.\n\n\n# Inputs\n\n`flag`\n: 1\\. Function argument\n\n`feature`\n: 2\\. Function argument\n\n# Type\n\n```\nenableFeature :: bool -> string -> string\n```\n\n# Examples\n:::{.example}\n## `lib.strings.enableFeature` usage example\n\n```nix\nenableFeature true \"shared\"\n=> \"--enable-shared\"\nenableFeature false \"shared\"\n=> \"--disable-shared\"\n```\n\n:::\n",
  "lib.strings.enableFeatureAs": "\nCreate an --{enable-<feature>=<value>,disable-<feature>} string that can be passed to\nstandard GNU Autoconf scripts.\n\n\n# Inputs\n\n`flag`\n: 1\\. Function argument\n\n`feature`\n: 2\\. Function argument\n\n`value`\n: 3\\. Function argument\n\n# Type\n\n```\nenableFeatureAs :: bool -> string -> string -> string\n```\n\n# Examples\n:::{.example}\n## `lib.strings.enableFeatureAs` usage example\n\n```nix\nenableFeatureAs true \"shared\" \"foo\"\n=> \"--enable-shared=foo\"\nenableFeatureAs false \"shared\" (throw \"ignored\")\n=> \"--disable-shared\"\n```\n\n:::\n",
  "lib.strings.escape": "\nEscape occurrence of the elements of `list` in `string` by\nprefixing it with a backslash.\n\n\n# Inputs\n\n`list`\n: 1\\. Function argument\n\n`string`\n: 2\\. Function argument\n\n# Type\n\n```\nescape :: [string] -> string -> string\n```\n\n# Examples\n:::{.example}\n## `lib.strings.escape` usage example\n\n```nix\nescape [\"(\" \")\"] \"(foo)\"\n=> \"\\\\(foo\\\\)\"\n```\n\n:::\n",
  "lib.strings.escapeC": "\nEscape occurrence of the element of `list` in `string` by\nconverting to its ASCII value and prefixing it with \\\\x.\nOnly works for printable ascii characters.\n\n\n# Inputs\n\n`list`\n: 1\\. Function argument\n\n`string`\n: 2\\. Function argument\n\n# Type\n\n```\nescapeC = [string] -> string -> string\n```\n\n# Examples\n:::{.example}\n## `lib.strings.escapeC` usage example\n\n```nix\nescapeC [\" \"] \"foo bar\"\n=> \"foo\\\\x20bar\"\n```\n\n:::\n",
  "lib.strings.escapeNixIdentifier": "\nQuotes a string `s` if it can't be used as an identifier directly.\n\n\n# Inputs\n\n`s`\n: 1\\. Function argument\n\n# Type\n\n```\nescapeNixIdentifier :: string -> string\n```\n\n# Examples\n:::{.example}\n## `lib.strings.escapeNixIdentifier` usage example\n\n```nix\nescapeNixIdentifier \"hello\"\n=> \"hello\"\nescapeNixIdentifier \"0abc\"\n=> \"\\\"0abc\\\"\"\n```\n\n:::\n",
  "lib.strings.escapeNixString": "\nTurn a string `s` into a Nix expression representing that string\n\n# Inputs\n\n`s`\n: 1\\. Function argument\n\n# Type\n\n```\nescapeNixString :: string -> string\n```\n\n# Examples\n:::{.example}\n## `lib.strings.escapeNixString` usage example\n\n```nix\nescapeNixString \"hello\\${}\\n\"\n=> \"\\\"hello\\\\\\${}\\\\n\\\"\"\n```\n\n:::\n",
  "lib.strings.escapeRegex": "\nTurn a string `s` into an exact regular expression\n\n# Inputs\n\n`s`\n: 1\\. Function argument\n\n# Type\n\n```\nescapeRegex :: string -> string\n```\n\n# Examples\n:::{.example}\n## `lib.strings.escapeRegex` usage example\n\n```nix\nescapeRegex \"[^a-z]*\"\n=> \"\\\\[\\\\^a-z]\\\\*\"\n```\n\n:::\n",
  "lib.strings.escapeShellArg": "\nQuote `string` to be used safely within the Bourne shell if it has any\nspecial characters.\n\n\n# Inputs\n\n`string`\n: 1\\. Function argument\n\n# Type\n\n```\nescapeShellArg :: string -> string\n```\n\n# Examples\n:::{.example}\n## `lib.strings.escapeShellArg` usage example\n\n```nix\nescapeShellArg \"esc'ape\\nme\"\n=> \"'esc'\\\\''ape\\nme'\"\n```\n\n:::\n",
  "lib.strings.escapeShellArgs": "\nQuote all arguments that have special characters to be safely passed to the\nBourne shell.\n\n# Inputs\n\n`args`\n: 1\\. Function argument\n\n# Type\n\n```\nescapeShellArgs :: [string] -> string\n```\n\n# Examples\n:::{.example}\n## `lib.strings.escapeShellArgs` usage example\n\n```nix\nescapeShellArgs [\"one\" \"two three\" \"four'five\"]\n=> \"one 'two three' 'four'\\\\''five'\"\n```\n\n:::\n",
  "lib.strings.escapeURL": "\nEscape the `string` so it can be safely placed inside a URL\nquery.\n\n# Inputs\n\n`string`\n: 1\\. Function argument\n\n# Type\n\n```\nescapeURL :: string -> string\n```\n\n# Examples\n:::{.example}\n## `lib.strings.escapeURL` usage example\n\n```nix\nescapeURL \"foo/bar baz\"\n=> \"foo%2Fbar%20baz\"\n```\n\n:::\n",
  "lib.strings.escapeXML": "\nEscapes a string `s` such that it is safe to include verbatim in an XML\ndocument.\n\n# Inputs\n\n`s`\n: 1\\. Function argument\n\n# Type\n\n```\nescapeXML :: string -> string\n```\n\n# Examples\n:::{.example}\n## `lib.strings.escapeXML` usage example\n\n```nix\nescapeXML ''\"test\" 'test' < & >''\n=> \"&quot;test&quot; &apos;test&apos; &lt; &amp; &gt;\"\n```\n\n:::\n",
  "lib.strings.fileContents": "\nRead the contents of a file removing the trailing \\n\n\n\n# Inputs\n\n`file`\n: 1\\. Function argument\n\n# Type\n\n```\nfileContents :: path -> string\n```\n\n# Examples\n:::{.example}\n## `lib.strings.fileContents` usage example\n\n```nix\n$ echo \"1.0\" > ./version\n\nfileContents ./version\n=> \"1.0\"\n```\n\n:::\n",
  "lib.strings.filter": "\nReturn a list consisting of the elements of *list* for which the\nfunction *f* returns `true`.\n",
  "lib.strings.fixedWidthNumber": "\nFormat a number adding leading zeroes up to fixed width.\n\n\n# Inputs\n\n`width`\n: 1\\. Function argument\n\n`n`\n: 2\\. Function argument\n\n# Type\n\n```\nfixedWidthNumber :: int -> int -> string\n```\n\n# Examples\n:::{.example}\n## `lib.strings.fixedWidthNumber` usage example\n\n```nix\nfixedWidthNumber 5 15\n=> \"00015\"\n```\n\n:::\n",
  "lib.strings.fixedWidthString": "\nCreate a fixed width string with additional prefix to match\nrequired width.\n\nThis function will fail if the input string is longer than the\nrequested length.\n\n\n# Inputs\n\n`width`\n: 1\\. Function argument\n\n`filler`\n: 2\\. Function argument\n\n`str`\n: 3\\. Function argument\n\n# Type\n\n```\nfixedWidthString :: int -> string -> string -> string\n```\n\n# Examples\n:::{.example}\n## `lib.strings.fixedWidthString` usage example\n\n```nix\nfixedWidthString 5 \"0\" (toString 15)\n=> \"00015\"\n```\n\n:::\n",
  "lib.strings.floatToString": "\nConvert a float to a string, but emit a warning when precision is lost\nduring the conversion\n\n\n# Inputs\n\n`float`\n: 1\\. Function argument\n\n\n# Type\n\n```\nfloatToString :: float -> string\n```\n\n# Examples\n:::{.example}\n## `lib.strings.floatToString` usage example\n\n```nix\nfloatToString 0.000001\n=> \"0.000001\"\nfloatToString 0.0000001\n=> trace: warning: Imprecise conversion from float to string 0.000000\n   \"0.000000\"\n```\n\n:::\n",
  "lib.strings.fromJSON": "\nConvert a JSON string to a Nix value. For example,\n\n```nix\nbuiltins.fromJSON ''{\"x\": [1, 2, 3], \"y\": null}''\n```\n\nreturns the value `{ x = [ 1 2 3 ]; y = null; }`.\n",
  "lib.strings.genList": "\nGenerate list of size *length*, with each element *i* equal to the\nvalue returned by *generator* `i`. For example,\n\n```nix\nbuiltins.genList (x: x * x) 5\n```\n\nreturns the list `[ 0 1 4 9 16 ]`.\n",
  "lib.strings.getName": "\nThis function takes an argument `x` that's either a derivation or a\nderivation's \"name\" attribute and extracts the name part from that\nargument.\n\n# Inputs\n\n`x`\n: 1\\. Function argument\n\n# Type\n\n```\ngetName :: String | Derivation -> String\n```\n\n\n# Examples\n:::{.example}\n## `lib.strings.getName` usage example\n\n```nix\ngetName \"youtube-dl-2016.01.01\"\n=> \"youtube-dl\"\ngetName pkgs.youtube-dl\n=> \"youtube-dl\"\n```\n\n:::\n",
  "lib.strings.getVersion": "\nThis function takes an argument `x` that's either a derivation or a\nderivation's \"name\" attribute and extracts the version part from that\nargument.\n\n\n# Inputs\n\n`x`\n: 1\\. Function argument\n\n# Type\n\n```\ngetVersion :: String | Derivation -> String\n```\n\n# Examples\n:::{.example}\n## `lib.strings.getVersion` usage example\n\n```nix\ngetVersion \"youtube-dl-2016.01.01\"\n=> \"2016.01.01\"\ngetVersion pkgs.youtube-dl\n=> \"2016.01.01\"\n```\n\n:::\n",
  "lib.strings.hasInfix": "\nDetermine whether a string contains the given infix\n\n\n# Inputs\n\n`infix`\n: 1\\. Function argument\n\n`content`\n: 2\\. Function argument\n\n# Type\n\n```\nhasInfix :: string -> string -> bool\n```\n\n# Examples\n:::{.example}\n## `lib.strings.hasInfix` usage example\n\n```nix\nhasInfix \"bc\" \"abcd\"\n=> true\nhasInfix \"ab\" \"abcd\"\n=> true\nhasInfix \"cd\" \"abcd\"\n=> true\nhasInfix \"foo\" \"abcd\"\n=> false\n```\n\n:::\n",
  "lib.strings.hasPrefix": "\nDetermine whether a string has given prefix.\n\n\n# Inputs\n\n`pref`\n: Prefix to check for\n\n`str`\n: Input string\n\n# Type\n\n```\nhasPrefix :: string -> string -> bool\n```\n\n# Examples\n:::{.example}\n## `lib.strings.hasPrefix` usage example\n\n```nix\nhasPrefix \"foo\" \"foobar\"\n=> true\nhasPrefix \"foo\" \"barfoo\"\n=> false\n```\n\n:::\n",
  "lib.strings.hasSuffix": "\nDetermine whether a string has given suffix.\n\n\n# Inputs\n\n`suffix`\n: Suffix to check for\n\n`content`\n: Input string\n\n# Type\n\n```\nhasSuffix :: string -> string -> bool\n```\n\n# Examples\n:::{.example}\n## `lib.strings.hasSuffix` usage example\n\n```nix\nhasSuffix \"foo\" \"foobar\"\n=> false\nhasSuffix \"foo\" \"barfoo\"\n=> true\n```\n\n:::\n",
  "lib.strings.head": "\nReturn the first element of a list; abort evaluation if the argument\nisn’t a list or is an empty list. You can test whether a list is\nempty by comparing it with `[]`.\n",
  "lib.strings.intersperse": "\nPlace an element between each element of a list\n\n\n# Inputs\n\n`separator`\n: Separator to add between elements\n\n`list`\n: Input list\n\n# Type\n\n```\nintersperse :: a -> [a] -> [a]\n```\n\n# Examples\n:::{.example}\n## `lib.strings.intersperse` usage example\n\n```nix\nintersperse \"/\" [\"usr\" \"local\" \"bin\"]\n=> [\"usr\" \"/\" \"local\" \"/\" \"bin\"].\n```\n\n:::\n",
  "lib.strings.isAttrs": "\nReturn `true` if *e* evaluates to a set, and `false` otherwise.\n",
  "lib.strings.isCoercibleToString": "\nCheck whether a value `val` can be coerced to a string.\n\n:::{.warning}\nSoft-deprecated function. While the original implementation is available as\n`isConvertibleWithToString`, consider using `isStringLike` instead, if suitable.\n:::\n\n# Inputs\n\n`val`\n: 1\\. Function argument\n\n# Type\n\n```\nisCoercibleToString :: a -> bool\n```\n",
  "lib.strings.isConvertibleWithToString": "\nCheck whether a list or other value `x` can be passed to toString.\n\nMany types of value are coercible to string this way, including `int`, `float`,\n`null`, `bool`, `list` of similarly coercible values.\n\n# Inputs\n\n`val`\n: 1\\. Function argument\n\n# Type\n\n```\nisConvertibleWithToString :: a -> bool\n```\n",
  "lib.strings.isInt": "\nReturn `true` if *e* evaluates to an integer, and `false` otherwise.\n",
  "lib.strings.isList": "\nReturn `true` if *e* evaluates to a list, and `false` otherwise.\n",
  "lib.strings.isPath": "\nReturn `true` if *e* evaluates to a path, and `false` otherwise.\n",
  "lib.strings.isStorePath": "\nCheck whether a value `x` is a store path.\n\n\n# Inputs\n\n`x`\n: 1\\. Function argument\n\n# Type\n\n```\nisStorePath :: a -> bool\n```\n\n# Examples\n:::{.example}\n## `lib.strings.isStorePath` usage example\n\n```nix\nisStorePath \"/nix/store/d945ibfx9x185xf04b890y4f9g3cbb63-python-2.7.11/bin/python\"\n=> false\nisStorePath \"/nix/store/d945ibfx9x185xf04b890y4f9g3cbb63-python-2.7.11\"\n=> true\nisStorePath pkgs.python\n=> true\nisStorePath [] || isStorePath 42 || isStorePath {} || …\n=> false\n```\n\n:::\n",
  "lib.strings.isString": "\nReturn `true` if *e* evaluates to a string, and `false` otherwise.\n",
  "lib.strings.isStringLike": "\nCheck whether a value can be coerced to a string.\nThe value must be a string, path, or attribute set.\n\nString-like values can be used without explicit conversion in\nstring interpolations and in most functions that expect a string.\n\n\n# Inputs\n\n`x`\n: 1\\. Function argument\n\n# Type\n\n```\nisStringLike :: a -> bool\n```\n",
  "lib.strings.isValidPosixName": "\nTest whether the given `name` is a valid POSIX shell variable name.\n\n\n# Inputs\n\n`name`\n: 1\\. Function argument\n\n# Type\n\n```\nstring -> bool\n```\n\n# Examples\n:::{.example}\n## `lib.strings.isValidPosixName` usage example\n\n```nix\nisValidPosixName \"foo_bar000\"\n=> true\nisValidPosixName \"0-bad.jpg\"\n=> false\n```\n\n:::\n",
  "lib.strings.levenshtein": "\nComputes the Levenshtein distance between two strings `a` and `b`.\n\nComplexity O(n*m) where n and m are the lengths of the strings.\nAlgorithm adjusted from https://stackoverflow.com/a/9750974/6605742\n\n\n# Inputs\n\n`a`\n: 1\\. Function argument\n\n`b`\n: 2\\. Function argument\n\n# Type\n\n```\nlevenshtein :: string -> string -> int\n```\n\n# Examples\n:::{.example}\n## `lib.strings.levenshtein` usage example\n\n```nix\nlevenshtein \"foo\" \"foo\"\n=> 0\nlevenshtein \"book\" \"hook\"\n=> 1\nlevenshtein \"hello\" \"Heyo\"\n=> 3\n```\n\n:::\n",
  "lib.strings.levenshteinAtMost": "\nReturns whether the levenshtein distance between two strings `a` and `b` is at most some value `k`.\n\nComplexity is O(min(n,m)) for k <= 2 and O(n*m) otherwise\n\n# Inputs\n\n`k`\n: Distance threshold\n\n`a`\n: String `a`\n\n`b`\n: String `b`\n\n# Type\n\n```\nlevenshteinAtMost :: int -> string -> string -> bool\n```\n\n# Examples\n:::{.example}\n## `lib.strings.levenshteinAtMost` usage example\n\n```nix\nlevenshteinAtMost 0 \"foo\" \"foo\"\n=> true\nlevenshteinAtMost 1 \"foo\" \"boa\"\n=> false\nlevenshteinAtMost 2 \"foo\" \"boa\"\n=> true\nlevenshteinAtMost 2 \"This is a sentence\" \"this is a sentense.\"\n=> false\nlevenshteinAtMost 3 \"This is a sentence\" \"this is a sentense.\"\n=> true\n```\n\n:::\n",
  "lib.strings.makeBinPath": "\nConstruct a binary search path (such as $PATH) containing the\nbinaries for a set of packages.\n\n# Inputs\n\n`packages`\n: List of packages\n\n# Type\n\n```\nmakeBinPath :: [package] -> string\n```\n\n# Examples\n:::{.example}\n## `lib.strings.makeBinPath` usage example\n\n```nix\nmakeBinPath [\"/root\" \"/usr\" \"/usr/local\"]\n=> \"/root/bin:/usr/bin:/usr/local/bin\"\n```\n\n:::\n",
  "lib.strings.makeIncludePath": "\nConstruct an include search path (such as C_INCLUDE_PATH) containing the\nheader files for a set of packages or paths.\n\n# Inputs\n\n`packages`\n: List of packages\n\n# Type\n\n```\nmakeIncludePath :: [package] -> string\n```\n\n# Examples\n:::{.example}\n## `lib.strings.makeIncludePath` usage example\n\n```nix\nmakeIncludePath [ \"/usr\" \"/usr/local\" ]\n=> \"/usr/include:/usr/local/include\"\npkgs = import <nixpkgs> { }\nmakeIncludePath [ pkgs.openssl pkgs.zlib ]\n=> \"/nix/store/9rz8gxhzf8sw4kf2j2f1grr49w8zx5vj-openssl-1.0.1r-dev/include:/nix/store/wwh7mhwh269sfjkm6k5665b5kgp7jrk2-zlib-1.2.8-dev/include\"\n```\n\n:::\n",
  "lib.strings.makeLibraryPath": "\nConstruct a library search path (such as RPATH) containing the\nlibraries for a set of packages\n\n# Inputs\n\n`packages`\n: List of packages\n\n# Type\n\n```\nmakeLibraryPath :: [package] -> string\n```\n\n# Examples\n:::{.example}\n## `lib.strings.makeLibraryPath` usage example\n\n```nix\nmakeLibraryPath [ \"/usr\" \"/usr/local\" ]\n=> \"/usr/lib:/usr/local/lib\"\npkgs = import <nixpkgs> { }\nmakeLibraryPath [ pkgs.openssl pkgs.zlib ]\n=> \"/nix/store/9rz8gxhzf8sw4kf2j2f1grr49w8zx5vj-openssl-1.0.1r/lib:/nix/store/wwh7mhwh269sfjkm6k5665b5kgp7jrk2-zlib-1.2.8/lib\"\n```\n\n:::\n",
  "lib.strings.makeSearchPath": "\nConstruct a Unix-style, colon-separated search path consisting of\nthe given `subDir` appended to each of the given paths.\n\n# Inputs\n\n`subDir`\n: Directory name to append\n\n`paths`\n: List of base paths\n\n# Type\n\n```\nmakeSearchPath :: string -> [string] -> string\n```\n\n# Examples\n:::{.example}\n## `lib.strings.makeSearchPath` usage example\n\n```nix\nmakeSearchPath \"bin\" [\"/root\" \"/usr\" \"/usr/local\"]\n=> \"/root/bin:/usr/bin:/usr/local/bin\"\nmakeSearchPath \"bin\" [\"\"]\n=> \"/bin\"\n```\n\n:::\n",
  "lib.strings.makeSearchPathOutput": "\nConstruct a Unix-style search path by appending the given\n`subDir` to the specified `output` of each of the packages.\n\nIf no output by the given name is found, fallback to `.out` and then to\nthe default.\n\n\n# Inputs\n\n`output`\n: Package output to use\n\n`subDir`\n: Directory name to append\n\n`pkgs`\n: List of packages\n\n# Type\n\n```\nmakeSearchPathOutput :: string -> string -> [package] -> string\n```\n\n# Examples\n:::{.example}\n## `lib.strings.makeSearchPathOutput` usage example\n\n```nix\nmakeSearchPathOutput \"dev\" \"bin\" [ pkgs.openssl pkgs.zlib ]\n=> \"/nix/store/9rz8gxhzf8sw4kf2j2f1grr49w8zx5vj-openssl-1.0.1r-dev/bin:/nix/store/wwh7mhwh269sfjkm6k5665b5kgp7jrk2-zlib-1.2.8/bin\"\n```\n\n:::\n",
  "lib.strings.match": "\nReturns a list if the [extended POSIX regular\nexpression](http://pubs.opengroup.org/onlinepubs/9699919799/basedefs/V1_chap09.html#tag_09_04)\n*regex* matches *str* precisely, otherwise returns `null`. Each item\nin the list is a regex group.\n\n```nix\nbuiltins.match \"ab\" \"abc\"\n```\n\nEvaluates to `null`.\n\n```nix\nbuiltins.match \"abc\" \"abc\"\n```\n\nEvaluates to `[ ]`.\n\n```nix\nbuiltins.match \"a(b)(c)\" \"abc\"\n```\n\nEvaluates to `[ \"b\" \"c\" ]`.\n\n```nix\nbuiltins.match \"[[:space:]]+([[:upper:]]+)[[:space:]]+\" \"  FOO   \"\n```\n\nEvaluates to `[ \"FOO\" ]`.\n",
  "lib.strings.mesonBool": "\nCreate a -D<condition>={true,false} string that can be passed to typical\nMeson invocations.\n\n\n# Inputs\n\n`condition`\n: The condition to be made true or false\n\n`flag`\n: The controlling flag of the condition\n\n# Type\n\n```\nmesonBool :: string -> bool -> string\n```\n\n# Examples\n:::{.example}\n## `lib.strings.mesonBool` usage example\n\n```nix\nmesonBool \"hardened\" true\n=> \"-Dhardened=true\"\nmesonBool \"static\" false\n=> \"-Dstatic=false\"\n```\n\n:::\n",
  "lib.strings.mesonEnable": "\nCreate a -D<feature>={enabled,disabled} string that can be passed to\ntypical Meson invocations.\n\n\n# Inputs\n\n`feature`\n: The feature to be enabled or disabled\n\n`flag`\n: The controlling flag\n\n# Type\n\n```\nmesonEnable :: string -> bool -> string\n```\n\n# Examples\n:::{.example}\n## `lib.strings.mesonEnable` usage example\n\n```nix\nmesonEnable \"docs\" true\n=> \"-Ddocs=enabled\"\nmesonEnable \"savage\" false\n=> \"-Dsavage=disabled\"\n```\n\n:::\n",
  "lib.strings.mesonOption": "\nCreate a -D<feature>=<value> string that can be passed to typical Meson\ninvocations.\n\n\n# Inputs\n\n`feature`\n: The feature to be set\n\n`value`\n: The desired value\n\n# Type\n\n```\nmesonOption :: string -> string -> string\n```\n\n# Examples\n:::{.example}\n## `lib.strings.mesonOption` usage example\n\n```nix\nmesonOption \"engine\" \"opengl\"\n=> \"-Dengine=opengl\"\n```\n\n:::\n",
  "lib.strings.nameFromURL": "\nExtract name and version from a URL as shown in the examples.\n\nSeparator `sep` is used to determine the end of the extension.\n\n\n# Inputs\n\n`url`\n: 1\\. Function argument\n\n`sep`\n: 2\\. Function argument\n\n# Type\n\n```\nnameFromURL :: String -> String\n```\n\n# Examples\n:::{.example}\n## `lib.strings.nameFromURL` usage example\n\n```nix\nnameFromURL \"https://nixos.org/releases/nix/nix-1.7/nix-1.7-x86_64-linux.tar.bz2\" \"-\"\n=> \"nix\"\nnameFromURL \"https://nixos.org/releases/nix/nix-1.7/nix-1.7-x86_64-linux.tar.bz2\" \"_\"\n=> \"nix-1.7-x86\"\n```\n\n:::\n",
  "lib.strings.normalizePath": "\nNormalize path, removing extraneous /s\n\n\n# Inputs\n\n`s`\n: 1\\. Function argument\n\n# Type\n\n```\nnormalizePath :: string -> string\n```\n\n# Examples\n:::{.example}\n## `lib.strings.normalizePath` usage example\n\n```nix\nnormalizePath \"/a//b///c/\"\n=> \"/a/b/c/\"\n```\n\n:::\n",
  "lib.strings.optionalString": "\nDepending on the boolean `cond', return either the given string\nor the empty string. Useful to concatenate against a bigger string.\n\n\n# Inputs\n\n`cond`\n: Condition\n\n`string`\n: String to return if condition is true\n\n# Type\n\n```\noptionalString :: bool -> string -> string\n```\n\n# Examples\n:::{.example}\n## `lib.strings.optionalString` usage example\n\n```nix\noptionalString true \"some-string\"\n=> \"some-string\"\noptionalString false \"some-string\"\n=> \"\"\n```\n\n:::\n",
  "lib.strings.parseDrvName": "\nSplit the string *s* into a package name and version. The package\nname is everything up to but not including the first dash not followed\nby a letter, and the version is everything following that dash. The\nresult is returned in a set `{ name, version }`. Thus,\n`builtins.parseDrvName \"nix-0.12pre12876\"` returns `{ name =\n\"nix\"; version = \"0.12pre12876\"; }`.\n",
  "lib.strings.readFile": "\nReturn the contents of the file *path* as a string.\n",
  "lib.strings.readPathsFromFile": "\nRead a list of paths from `file`, relative to the `rootPath`.\nLines beginning with `#` are treated as comments and ignored.\nWhitespace is significant.\n\n:::{.warning}\nThis function is deprecated and should be avoided.\n:::\n\n:::{.note}\nThis function is not performant and should be avoided.\n:::\n\n# Inputs\n\n`rootPath`\n: 1\\. Function argument\n\n`file`\n: 2\\. Function argument\n\n# Type\n\n```\nreadPathsFromFile :: string -> string -> [string]\n```\n\n# Examples\n:::{.example}\n## `lib.strings.readPathsFromFile` usage example\n\n```nix\nreadPathsFromFile /prefix\n  ./pkgs/development/libraries/qt-5/5.4/qtbase/series\n=> [ \"/prefix/dlopen-resolv.patch\" \"/prefix/tzdir.patch\"\n     \"/prefix/dlopen-libXcursor.patch\" \"/prefix/dlopen-openssl.patch\"\n     \"/prefix/dlopen-dbus.patch\" \"/prefix/xdg-config-dirs.patch\"\n     \"/prefix/nix-profiles-library-paths.patch\"\n     \"/prefix/compose-search-path.patch\" ]\n```\n\n:::\n",
  "lib.strings.removePrefix": "\nReturn a string without the specified prefix, if the prefix matches.\n\n# Inputs\n\n`prefix`\n: Prefix to remove if it matches\n\n`str`\n: Input string\n\n# Type\n\n```\nremovePrefix :: string -> string -> string\n```\n\n# Examples\n:::{.example}\n## `lib.strings.removePrefix` usage example\n\n```nix\nremovePrefix \"foo.\" \"foo.bar.baz\"\n=> \"bar.baz\"\nremovePrefix \"xxx\" \"foo.bar.baz\"\n=> \"foo.bar.baz\"\n```\n\n:::\n",
  "lib.strings.removeSuffix": "\nReturn a string without the specified suffix, if the suffix matches.\n\n\n# Inputs\n\n`suffix`\n: Suffix to remove if it matches\n\n`str`\n: Input string\n\n# Type\n\n```\nremoveSuffix :: string -> string -> string\n```\n\n# Examples\n:::{.example}\n## `lib.strings.removeSuffix` usage example\n\n```nix\nremoveSuffix \"front\" \"homefront\"\n=> \"home\"\nremoveSuffix \"xxx\" \"homefront\"\n=> \"homefront\"\n```\n\n:::\n",
  "lib.strings.replaceChars": "\nGiven string *s*, replace every occurrence of the strings in *from*\nwith the corresponding string in *to*.\n\nThe argument *to* is lazy, that is, it is only evaluated when its corresponding pattern in *from* is matched in the string *s*\n\nExample:\n\n```nix\nbuiltins.replaceStrings [\"oo\" \"a\"] [\"a\" \"i\"] \"foobar\"\n```\n\nevaluates to `\"fabir\"`.\n",
  "lib.strings.replaceStrings": "\nGiven string *s*, replace every occurrence of the strings in *from*\nwith the corresponding string in *to*.\n\nThe argument *to* is lazy, that is, it is only evaluated when its corresponding pattern in *from* is matched in the string *s*\n\nExample:\n\n```nix\nbuiltins.replaceStrings [\"oo\" \"a\"] [\"a\" \"i\"] \"foobar\"\n```\n\nevaluates to `\"fabir\"`.\n",
  "lib.strings.replicate": "\nRepeat a string `n` times,\nand concatenate the parts into a new string.\n\n\n# Inputs\n\n`n`\n: 1\\. Function argument\n\n`s`\n: 2\\. Function argument\n\n# Type\n\n```\nreplicate :: int -> string -> string\n```\n\n# Examples\n:::{.example}\n## `lib.strings.replicate` usage example\n\n```nix\nreplicate 3 \"v\"\n=> \"vvv\"\nreplicate 5 \"hello\"\n=> \"hellohellohellohellohello\"\n```\n\n:::\n",
  "lib.strings.sanitizeDerivationName": "\nCreates a valid derivation name from a potentially invalid one.\n\n# Inputs\n\n`string`\n: 1\\. Function argument\n\n# Type\n\n```\nsanitizeDerivationName :: String -> String\n```\n\n# Examples\n:::{.example}\n## `lib.strings.sanitizeDerivationName` usage example\n\n```nix\nsanitizeDerivationName \"../hello.bar # foo\"\n=> \"-hello.bar-foo\"\nsanitizeDerivationName \"\"\n=> \"unknown\"\nsanitizeDerivationName pkgs.hello\n=> \"-nix-store-2g75chlbpxlrqn15zlby2dfh8hr9qwbk-hello-2.10\"\n```\n\n:::\n",
  "lib.strings.split": "\nReturns a list composed of non matched strings interleaved with the\nlists of the [extended POSIX regular\nexpression](http://pubs.opengroup.org/onlinepubs/9699919799/basedefs/V1_chap09.html#tag_09_04)\n*regex* matches of *str*. Each item in the lists of matched\nsequences is a regex group.\n\n```nix\nbuiltins.split \"(a)b\" \"abc\"\n```\n\nEvaluates to `[ \"\" [ \"a\" ] \"c\" ]`.\n\n```nix\nbuiltins.split \"([ac])\" \"abc\"\n```\n\nEvaluates to `[ \"\" [ \"a\" ] \"b\" [ \"c\" ] \"\" ]`.\n\n```nix\nbuiltins.split \"(a)|(c)\" \"abc\"\n```\n\nEvaluates to `[ \"\" [ \"a\" null ] \"b\" [ null \"c\" ] \"\" ]`.\n\n```nix\nbuiltins.split \"([[:upper:]]+)\" \" FOO \"\n```\n\nEvaluates to `[ \" \" [ \"FOO\" ] \" \" ]`.\n",
  "lib.strings.splitString": "\nCut a string with a separator and produces a list of strings which\nwere separated by this separator.\n\n# Inputs\n\n`sep`\n: 1\\. Function argument\n\n`s`\n: 2\\. Function argument\n\n# Type\n\n```\nsplitString :: string -> string -> [string]\n```\n\n# Examples\n:::{.example}\n## `lib.strings.splitString` usage example\n\n```nix\nsplitString \".\" \"foo.bar.baz\"\n=> [ \"foo\" \"bar\" \"baz\" ]\nsplitString \"/\" \"/usr/local/bin\"\n=> [ \"\" \"usr\" \"local\" \"bin\" ]\n```\n\n:::\n",
  "lib.strings.stringAsChars": "\nManipulate a string character by character and replace them by\nstrings before concatenating the results.\n\n\n# Inputs\n\n`f`\n: Function to map over each individual character\n\n`s`\n: Input string\n\n# Type\n\n```\nstringAsChars :: (string -> string) -> string -> string\n```\n\n# Examples\n:::{.example}\n## `lib.strings.stringAsChars` usage example\n\n```nix\nstringAsChars (x: if x == \"a\" then \"i\" else x) \"nax\"\n=> \"nix\"\n```\n\n:::\n",
  "lib.strings.stringLength": "\nReturn the number of bytes of the string *e*. If *e* is not a string,\nevaluation is aborted.\n",
  "lib.strings.stringToCharacters": "\nConvert a string `s` to a list of characters (i.e. singleton strings).\nThis allows you to, e.g., map a function over each character.  However,\nnote that this will likely be horribly inefficient; Nix is not a\ngeneral purpose programming language. Complex string manipulations\nshould, if appropriate, be done in a derivation.\nAlso note that Nix treats strings as a list of bytes and thus doesn't\nhandle unicode.\n\n\n# Inputs\n\n`s`\n: 1\\. Function argument\n\n# Type\n\n```\nstringToCharacters :: string -> [string]\n```\n\n# Examples\n:::{.example}\n## `lib.strings.stringToCharacters` usage example\n\n```nix\nstringToCharacters \"\"\n=> [ ]\nstringToCharacters \"abc\"\n=> [ \"a\" \"b\" \"c\" ]\nstringToCharacters \"🦄\"\n=> [ \"�\" \"�\" \"�\" \"�\" ]\n```\n\n:::\n",
  "lib.strings.substring": "\nReturn the substring of *s* from byte position *start*\n(zero-based) up to but not including *start + len*. If *start* is\ngreater than the length of the string, an empty string is returned.\nIf *start + len* lies beyond the end of the string or *len* is `-1`,\nonly the substring up to the end of the string is returned.\n*start* must be non-negative.\nFor example,\n\n```nix\nbuiltins.substring 0 3 \"nixos\"\n```\n\nevaluates to `\"nix\"`.\n",
  "lib.strings.tail": "\nReturn the list without its first item; abort evaluation if\nthe argument isn’t a list or is an empty list.\n\n> **Warning**\n>\n> This function should generally be avoided since it's inefficient:\n> unlike Haskell's `tail`, it takes O(n) time, so recursing over a\n> list by repeatedly calling `tail` takes O(n^2) time.\n",
  "lib.strings.toInt": "\nParse a string as an int. Does not support parsing of integers with preceding zero due to\nambiguity between zero-padded and octal numbers. See toIntBase10.\n\n# Inputs\n\n`str`\n: A string to be interpreted as an int.\n\n# Type\n\n```\ntoInt :: string -> int\n```\n\n# Examples\n:::{.example}\n## `lib.strings.toInt` usage example\n\n```nix\ntoInt \"1337\"\n=> 1337\n\ntoInt \"-4\"\n=> -4\n\ntoInt \" 123 \"\n=> 123\n\ntoInt \"00024\"\n=> error: Ambiguity in interpretation of 00024 between octal and zero padded integer.\n\ntoInt \"3.14\"\n=> error: floating point JSON numbers are not supported\n```\n\n:::\n",
  "lib.strings.toIntBase10": "\nParse a string as a base 10 int. This supports parsing of zero-padded integers.\n\n# Inputs\n\n`str`\n: A string to be interpreted as an int.\n\n# Type\n\n```\ntoIntBase10 :: string -> int\n```\n\n# Examples\n:::{.example}\n## `lib.strings.toIntBase10` usage example\n\n```nix\ntoIntBase10 \"1337\"\n=> 1337\n\ntoIntBase10 \"-4\"\n=> -4\n\ntoIntBase10 \" 123 \"\n=> 123\n\ntoIntBase10 \"00024\"\n=> 24\n\ntoIntBase10 \"3.14\"\n=> error: floating point JSON numbers are not supported\n```\n\n:::\n",
  "lib.strings.toJSON": "\nReturn a string containing a JSON representation of *e*. Strings,\nintegers, floats, booleans, nulls and lists are mapped to their JSON\nequivalents. Sets (except derivations) are represented as objects.\nDerivations are translated to a JSON string containing the\nderivation’s output path. Paths are copied to the store and\nrepresented as a JSON string of the resulting store path.\n",
  "lib.strings.toLower": "\nConverts an ASCII string `s` to lower-case.\n\n# Inputs\n\n`s`\n: The string to convert to lower-case.\n\n# Type\n\n```\ntoLower :: string -> string\n```\n\n# Examples\n:::{.example}\n## `lib.strings.toLower` usage example\n\n```nix\ntoLower \"HOME\"\n=> \"home\"\n```\n\n:::\n",
  "lib.strings.toSentenceCase": "\nConverts the first character of a string `s` to upper-case.\n\n# Inputs\n\n`str`\n: The string to convert to sentence case.\n\n# Type\n\n```\ntoSentenceCase :: string -> string\n```\n\n# Examples\n:::{.example}\n## `lib.strings.toSentenceCase` usage example\n\n```nix\ntoSentenceCase \"home\"\n=> \"Home\"\n```\n\n:::\n",
  "lib.strings.toShellVar": "\nTranslate a Nix value into a shell variable declaration, with proper escaping.\n\nThe value can be a string (mapped to a regular variable), a list of strings\n(mapped to a Bash-style array) or an attribute set of strings (mapped to a\nBash-style associative array). Note that \"string\" includes string-coercible\nvalues like paths or derivations.\n\nStrings are translated into POSIX sh-compatible code; lists and attribute sets\nassume a shell that understands Bash syntax (e.g. Bash or ZSH).\n\n\n# Inputs\n\n`name`\n: 1\\. Function argument\n\n`value`\n: 2\\. Function argument\n\n# Type\n\n```\nstring -> ( string | [string] | { ${name} :: string; } ) -> string\n```\n\n# Examples\n:::{.example}\n## `lib.strings.toShellVar` usage example\n\n```nix\n''\n  ${toShellVar \"foo\" \"some string\"}\n  [[ \"$foo\" == \"some string\" ]]\n''\n```\n\n:::\n",
  "lib.strings.toShellVars": "\nTranslate an attribute set `vars` into corresponding shell variable declarations\nusing `toShellVar`.\n\n\n# Inputs\n\n`vars`\n: 1\\. Function argument\n\n# Type\n\n```\ntoShellVars :: {\n  ${name} :: string | [ string ] | { ${key} :: string; };\n} -> string\n```\n\n# Examples\n:::{.example}\n## `lib.strings.toShellVars` usage example\n\n```nix\nlet\n  foo = \"value\";\n  bar = foo;\nin ''\n  ${toShellVars { inherit foo bar; }}\n  [[ \"$foo\" == \"$bar\" ]]\n''\n```\n\n:::\n",
  "lib.strings.toUpper": "\nConverts an ASCII string `s` to upper-case.\n\n# Inputs\n\n`s`\n: The string to convert to upper-case.\n\n\n# Type\n\n```\ntoUpper :: string -> string\n```\n\n# Examples\n:::{.example}\n## `lib.strings.toUpper` usage example\n\n```nix\ntoUpper \"home\"\n=> \"HOME\"\n```\n\n:::\n",
  "lib.strings.trim": "\nRemove leading and trailing whitespace from a string `s`.\n\nWhitespace is defined as any of the following characters:\n  \" \", \"\\t\" \"\\r\" \"\\n\"\n\n# Inputs\n\n`s`\n: The string to trim\n\n# Type\n\n```\ntrim :: string -> string\n```\n\n# Examples\n:::{.example}\n## `lib.strings.trim` usage example\n\n```nix\ntrim \"   hello, world!   \"\n=> \"hello, world!\"\n```\n\n:::\n",
  "lib.strings.trimWith": "\nRemove leading and/or trailing whitespace from a string `s`.\n\nTo remove both leading and trailing whitespace, you can also use [`trim`](#function-library-lib.strings.trim)\n\nWhitespace is defined as any of the following characters:\n  \" \", \"\\t\" \"\\r\" \"\\n\"\n\n# Inputs\n\n`config` (Attribute set)\n: `start`\n  : Whether to trim leading whitespace (`false` by default)\n\n: `end`\n  : Whether to trim trailing whitespace (`false` by default)\n\n`s`\n: The string to trim\n\n# Type\n\n```\ntrimWith :: { start :: Bool; end :: Bool } -> String -> String\n```\n\n# Examples\n:::{.example}\n## `lib.strings.trimWith` usage example\n\n```nix\ntrimWith { start = true; } \"   hello, world!   \"}\n=> \"hello, world!   \"\n\ntrimWith { end = true; } \"   hello, world!   \"}\n=> \"   hello, world!\"\n```\n:::\n",
  "lib.strings.typeOf": "\nReturn a string representing the type of the value *e*, namely\n`\"int\"`, `\"bool\"`, `\"string\"`, `\"path\"`, `\"null\"`, `\"set\"`,\n`\"list\"`, `\"lambda\"` or `\"float\"`.\n",
  "lib.strings.unsafeDiscardStringContext": "\nDiscard the [string context](@docroot@/language/string-context.md) from a value that can be coerced to a string.\n",
  "lib.strings.versionAtLeast": "\nReturn true if string v1 denotes a version equal to or newer than v2.\n\n\n# Inputs\n\n`v1`\n: 1\\. Function argument\n\n`v2`\n: 2\\. Function argument\n\n# Type\n\n```\nversionAtLeast :: String -> String -> Bool\n```\n\n# Examples\n:::{.example}\n## `lib.strings.versionAtLeast` usage example\n\n```nix\nversionAtLeast \"1.1\" \"1.0\"\n=> true\nversionAtLeast \"1.1\" \"1.1\"\n=> true\nversionAtLeast \"1.1\" \"1.2\"\n=> false\n```\n\n:::\n",
  "lib.strings.versionOlder": "\nReturn true if string `v1` denotes a version older than `v2`.\n\n\n# Inputs\n\n`v1`\n: 1\\. Function argument\n\n`v2`\n: 2\\. Function argument\n\n# Type\n\n```\nversionOlder :: String -> String -> Bool\n```\n\n# Examples\n:::{.example}\n## `lib.strings.versionOlder` usage example\n\n```nix\nversionOlder \"1.1\" \"1.2\"\n=> true\nversionOlder \"1.1\" \"1.1\"\n=> false\n```\n\n:::\n",
  "lib.strings.withFeature": "\nCreate an --{with,without}-<feature> string that can be passed to\nstandard GNU Autoconf scripts.\n\n\n# Inputs\n\n`flag`\n: 1\\. Function argument\n\n`feature`\n: 2\\. Function argument\n\n\n# Type\n\n```\nwithFeature :: bool -> string -> string\n```\n\n# Examples\n:::{.example}\n## `lib.strings.withFeature` usage example\n\n```nix\nwithFeature true \"shared\"\n=> \"--with-shared\"\nwithFeature false \"shared\"\n=> \"--without-shared\"\n```\n\n:::\n",
  "lib.strings.withFeatureAs": "\nCreate an --{with-<feature>=<value>,without-<feature>} string that can be passed to\nstandard GNU Autoconf scripts.\n\n\n# Inputs\n\n`flag`\n: 1\\. Function argument\n\n`feature`\n: 2\\. Function argument\n\n`value`\n: 3\\. Function argument\n\n# Type\n\n```\nwithFeatureAs :: bool -> string -> string -> string\n```\n\n\n# Examples\n:::{.example}\n## `lib.strings.withFeatureAs` usage example\n\n```nix\nwithFeatureAs true \"shared\" \"foo\"\n=> \"--with-shared=foo\"\nwithFeatureAs false \"shared\" (throw \"ignored\")\n=> \"--without-shared\"\n```\n\n:::\n",
  "lib.stringsWithDeps.fullDepEntry": null,
  "lib.stringsWithDeps.noDepEntry": null,
  "lib.stringsWithDeps.packEntry": null,
  "lib.stringsWithDeps.stringAfter": null,
  "lib.stringsWithDeps.textClosureList": "\nTopologically sort a collection of dependent strings.\nOnly the values to keys listed in `arg` and their dependencies will be included in the result.\n\n::: {.note}\nThis function doesn't formally fulfill the definition of topological sorting, but it's good enough for our purposes in Nixpkgs.\n:::\n\n# Inputs\n\n`predefined` (attribute set)\n\n: strings with annotated dependencies (strings or attribute set)\n  A value can be a simple string if it has no dependencies.\n  Otherwise, is can be an attribute set with the following attributes:\n  - `deps` (list of strings)\n  - `text` (Any\n\n`arg` (list of strings)\n\n: Keys for which the values in the dependency closure will be included in the result\n\n# Type\n\n```\ntextClosureList :: { ${phase} :: { deps :: [String]; text :: String; } | String; } -> [String] -> [String]\n```\n\n# Examples\n:::{.example}\n## `lib.stringsWithDeps.textClosureList` usage example\n\n```nix\ntextClosureList {\n  a = {\n    deps = [ \"b\" \"c\" \"e\" ];\n    text = \"a: depends on b, c and e\";\n  };\n  b = {\n    deps = [ ];\n    text = \"b: no dependencies\";\n  };\n  c = {\n    deps = [ \"b\" ];\n    text = \"c: depends on b\";\n  };\n  d = {\n    deps = [ \"c\" ];\n    text = \"d: not being depended on by anything in `arg`\";\n  };\n  e = {\n    deps = [ \"c\" ];\n    text = \"e: depends on c, depended on by a, not in `arg`\";\n  };\n} [\n  \"a\"\n  \"b\"\n  \"c\"\n]\n=> [\n  \"b: no dependencies\"\n  \"c: depends on b\"\n  \"e: depends on c, depended on by a, not in `arg`\"\n  \"a: depends on b, c and e\"\n]\n```\n:::\n\nCommon real world usages are:\n- Ordering the dependent phases of `system.activationScripts`\n- Ordering the dependent phases of `system.userActivationScripts`\n\nFor further examples see: [NixOS activation script](https://nixos.org/manual/nixos/stable/#sec-activation-script)\n\n",
  "lib.stringsWithDeps.textClosureMap": null,
  "lib.systems.elaborate": "always just used `final.*` would fail on both counts.",
  "lib.systems.equals": null,
  "lib.systems.systemToAttrs": "attrset.",
  "lib.trivial.add": "\nReturn the sum of the numbers *e1* and *e2*.\n",
  "lib.trivial.and": "\nboolean “and”\n\n\n# Inputs\n\n`x`\n\n: 1\\. Function argument\n\n`y`\n\n: 2\\. Function argument\n",
  "lib.trivial.bitAnd": "\nReturn the bitwise AND of the integers *e1* and *e2*.\n",
  "lib.trivial.bitNot": "\nbitwise “not”\n",
  "lib.trivial.bitOr": "\nReturn the bitwise OR of the integers *e1* and *e2*.\n",
  "lib.trivial.bitXor": "\nReturn the bitwise XOR of the integers *e1* and *e2*.\n",
  "lib.trivial.boolToString": "\nConvert a boolean to a string.\n\nThis function uses the strings \"true\" and \"false\" to represent\nboolean values. Calling `toString` on a bool instead returns \"1\"\nand \"\" (sic!).\n\n\n# Inputs\n\n`b`\n\n: 1\\. Function argument\n\n# Type\n\n```\nboolToString :: bool -> string\n```\n",
  "lib.trivial.checkListOfEnum": "\nCheck if the elements in a list are valid values from a enum, returning the identity function, or throwing an error message otherwise.\n\n\n# Inputs\n\n`msg`\n\n: 1\\. Function argument\n\n`valid`\n\n: 2\\. Function argument\n\n`given`\n\n: 3\\. Function argument\n\n# Type\n\n```\nString -> List ComparableVal -> List ComparableVal -> a -> a\n```\n\n# Examples\n:::{.example}\n## `lib.trivial.checkListOfEnum` usage example\n\n```nix\nlet colorVariants = [\"bright\" \"dark\" \"black\"]\nin checkListOfEnum \"color variants\" [ \"standard\" \"light\" \"dark\" ] colorVariants;\n=>\nerror: color variants: bright, black unexpected; valid ones: standard, light, dark\n```\n\n:::\n",
  "lib.trivial.compare": "\nC-style comparisons\n\na < b,  compare a b => -1\na == b, compare a b => 0\na > b,  compare a b => 1\n\n\n# Inputs\n\n`a`\n\n: 1\\. Function argument\n\n`b`\n\n: 2\\. Function argument\n",
  "lib.trivial.concat": "\nConcatenate two lists\n\n\n# Inputs\n\n`x`\n\n: 1\\. Function argument\n\n`y`\n\n: 2\\. Function argument\n\n# Type\n\n```\nconcat :: [a] -> [a] -> [a]\n```\n\n# Examples\n:::{.example}\n## `lib.trivial.concat` usage example\n\n```nix\nconcat [ 1 2 ] [ 3 4 ]\n=> [ 1 2 3 4 ]\n```\n\n:::\n",
  "lib.trivial.const": "\nThe constant function\n\nIgnores the second argument. If called with only one argument,\nconstructs a function that always returns a static value.\n\n\n# Inputs\n\n`x`\n\n: Value to return\n\n`y`\n\n: Value to ignore\n\n# Type\n\n```\nconst :: a -> b -> a\n```\n\n# Examples\n:::{.example}\n## `lib.trivial.const` usage example\n\n```nix\nlet f = const 5; in f 10\n=> 5\n```\n\n:::\n",
  "lib.trivial.deepSeq": "\nThis is like `seq e1 e2`, except that *e1* is evaluated *deeply*:\nif it’s a list or set, its elements or attributes are also\nevaluated recursively.\n",
  "lib.trivial.defaultTo": "\nReturn `maybeValue` if not null, otherwise return `default`.\n\n\n# Inputs\n\n`default`\n\n: 1\\. Function argument\n\n`maybeValue`\n\n: 2\\. Function argument\n\n\n# Examples\n:::{.example}\n## `lib.trivial.defaultTo` usage example\n\n```nix\ndefaultTo \"default\" null\n=> \"default\"\ndefaultTo \"default\" \"foo\"\n=> \"foo\"\ndefaultTo \"default\" false\n=> false\n```\n\n:::\n",
  "lib.trivial.flip": "\nFlip the order of the arguments of a binary function.\n\n\n# Inputs\n\n`f`\n\n: 1\\. Function argument\n\n`a`\n\n: 2\\. Function argument\n\n`b`\n\n: 3\\. Function argument\n\n# Type\n\n```\nflip :: (a -> b -> c) -> (b -> a -> c)\n```\n\n# Examples\n:::{.example}\n## `lib.trivial.flip` usage example\n\n```nix\nflip concat [1] [2]\n=> [ 2 1 ]\n```\n\n:::\n",
  "lib.trivial.fromHexString": "\nConvert a hexadecimal string to it's integer representation.\n\n# Type\n\n```\nfromHexString :: String -> [ String ]\n```\n\n# Examples\n\n```nix\nfromHexString \"FF\"\n=> 255\n\nfromHexString (builtins.hashString \"sha256\" \"test\")\n=> 9223372036854775807\n```\n",
  "lib.trivial.functionArgs": "\nExtract the expected function arguments from a function.\nThis works both with nix-native { a, b ? foo, ... }: style\nfunctions and functions with args set with 'setFunctionArgs'. It\nhas the same return type and semantics as builtins.functionArgs.\nsetFunctionArgs : (a → b) → Map String Bool.\n\n\n# Inputs\n\n`f`\n\n: 1\\. Function argument\n",
  "lib.trivial.genericClosure": "\n`builtins.genericClosure` iteratively computes the transitive closure over an arbitrary relation defined by a function.\n\nIt takes *attrset* with two attributes named `startSet` and `operator`, and returns a list of attribute sets:\n\n- `startSet`:\n  The initial list of attribute sets.\n\n- `operator`:\n  A function that takes an attribute set and returns a list of attribute sets.\n  It defines how each item in the current set is processed and expanded into more items.\n\nEach attribute set in the list `startSet` and the list returned by `operator` must have an attribute `key`, which must support equality comparison.\nThe value of `key` can be one of the following types:\n\n- [Int](@docroot@/language/types.md#type-int)\n- [Float](@docroot@/language/types.md#type-float)\n- [Boolean](@docroot@/language/types.md#type-boolean)\n- [String](@docroot@/language/types.md#type-string)\n- [Path](@docroot@/language/types.md#type-path)\n- [List](@docroot@/language/types.md#list)\n\nThe result is produced by calling the `operator` on each `item` that has not been called yet, including newly added items, until no new items are added.\nItems are compared by their `key` attribute.\n\nCommon usages are:\n\n- Generating unique collections of items, such as dependency graphs.\n- Traversing through structures that may contain cycles or loops.\n- Processing data structures with complex internal relationships.\n\n> **Example**\n>\n> ```nix\n> builtins.genericClosure {\n>   startSet = [ {key = 5;} ];\n>   operator = item: [{\n>     key = if (item.key / 2 ) * 2 == item.key\n>          then item.key / 2\n>          else 3 * item.key + 1;\n>   }];\n> }\n> ```\n>\n> evaluates to\n>\n> ```nix\n> [ { key = 5; } { key = 16; } { key = 8; } { key = 4; } { key = 2; } { key = 1; } ]\n> ```\n",
  "lib.trivial.id": "\nThe identity function\nFor when you need a function that does “nothing”.\n\n\n# Inputs\n\n`x`\n\n: The value to return\n\n# Type\n\n```\nid :: a -> a\n```\n",
  "lib.trivial.importJSON": "\nReads a JSON file.\n\n# Examples\n:::{.example}\n## `lib.trivial.importJSON` usage example\n\nexample.json\n```json\n{\n  \"title\": \"Example JSON\",\n  \"hello\": {\n    \"world\": \"foo\",\n    \"bar\": {\n      \"foobar\": true\n    }\n  }\n}\n```\n\n```nix\nimportJSON ./example.json\n=> {\n  title = \"Example JSON\";\n  hello = {\n    world = \"foo\";\n    bar = {\n      foobar = true;\n    };\n  };\n}\n```\n\n:::\n\n# Inputs\n\n`path`\n\n: 1\\. Function argument\n\n# Type\n\n```\nimportJSON :: path -> any\n```\n",
  "lib.trivial.importTOML": "\nReads a TOML file.\n\n# Examples\n:::{.example}\n## `lib.trivial.importTOML` usage example\n\nexample.toml\n```toml\ntitle = \"TOML Example\"\n\n[hello]\nworld = \"foo\"\n\n[hello.bar]\nfoobar = true\n```\n\n```nix\nimportTOML ./example.toml\n=> {\n  title = \"TOML Example\";\n  hello = {\n    world = \"foo\";\n    bar = {\n      foobar = true;\n    };\n  };\n}\n```\n\n:::\n\n# Inputs\n\n`path`\n\n: 1\\. Function argument\n\n# Type\n\n```\nimportTOML :: path -> any\n```\n",
  "lib.trivial.info": null,
  "lib.trivial.isBool": "\nReturn `true` if *e* evaluates to a bool, and `false` otherwise.\n",
  "lib.trivial.isFloat": "\nReturn `true` if *e* evaluates to a float, and `false` otherwise.\n",
  "lib.trivial.isFunction": "\nCheck whether something is a function or something\nannotated with function args.\n\n\n# Inputs\n\n`f`\n\n: 1\\. Function argument\n",
  "lib.trivial.isInOldestRelease": "\nWhether a feature is supported in all supported releases (at the time of\nrelease branch-off, if applicable). See `oldestSupportedRelease`.\n\n\n# Inputs\n\n`release`\n\n: Release number of feature introduction as an integer, e.g. 2111 for 21.11.\nSet it to the upcoming release, matching the nixpkgs/.version file.\n",
  "lib.trivial.isInt": "\nReturn `true` if *e* evaluates to an integer, and `false` otherwise.\n",
  "lib.trivial.lessThan": "\nReturn `true` if the number *e1* is less than the number *e2*, and\n`false` otherwise. Evaluation aborts if either *e1* or *e2* does not\nevaluate to a number.\n",
  "lib.trivial.mapNullable": "\nApply function if the supplied argument is non-null.\n\n\n# Inputs\n\n`f`\n\n: Function to call\n\n`a`\n\n: Argument to check for null before passing it to `f`\n\n\n# Examples\n:::{.example}\n## `lib.trivial.mapNullable` usage example\n\n```nix\nmapNullable (x: x+1) null\n=> null\nmapNullable (x: x+1) 22\n=> 23\n```\n\n:::\n",
  "lib.trivial.max": "\nReturn maximum of two numbers.\n\n\n# Inputs\n\n`x`\n\n: 1\\. Function argument\n\n`y`\n\n: 2\\. Function argument\n",
  "lib.trivial.mergeAttrs": "\nMerge two attribute sets shallowly, right side trumps left\n\nmergeAttrs :: attrs -> attrs -> attrs\n\n\n# Inputs\n\n`x`\n\n: Left attribute set\n\n`y`\n\n: Right attribute set (higher precedence for equal keys)\n\n\n# Examples\n:::{.example}\n## `lib.trivial.mergeAttrs` usage example\n\n```nix\nmergeAttrs { a = 1; b = 2; } { b = 3; c = 4; }\n=> { a = 1; b = 3; c = 4; }\n```\n\n:::\n",
  "lib.trivial.min": "\nReturn minimum of two numbers.\n\n\n# Inputs\n\n`x`\n\n: 1\\. Function argument\n\n`y`\n\n: 2\\. Function argument\n",
  "lib.trivial.mirrorFunctionArgs": "\n`mirrorFunctionArgs f g` creates a new function `g'` with the same behavior as `g` (`g' x == g x`)\nbut its function arguments mirroring `f` (`lib.functionArgs g' == lib.functionArgs f`).\n\n\n# Inputs\n\n`f`\n\n: Function to provide the argument metadata\n\n`g`\n\n: Function to set the argument metadata to\n\n# Type\n\n```\nmirrorFunctionArgs :: (a -> b) -> (a -> c) -> (a -> c)\n```\n\n# Examples\n:::{.example}\n## `lib.trivial.mirrorFunctionArgs` usage example\n\n```nix\naddab = {a, b}: a + b\naddab { a = 2; b = 4; }\n=> 6\nlib.functionArgs addab\n=> { a = false; b = false; }\naddab1 = attrs: addab attrs + 1\naddab1 { a = 2; b = 4; }\n=> 7\nlib.functionArgs addab1\n=> { }\naddab1' = lib.mirrorFunctionArgs addab addab1\naddab1' { a = 2; b = 4; }\n=> 7\nlib.functionArgs addab1'\n=> { a = false; b = false; }\n```\n\n:::\n",
  "lib.trivial.mod": "\nInteger modulus\n\n\n# Inputs\n\n`base`\n\n: 1\\. Function argument\n\n`int`\n\n: 2\\. Function argument\n\n\n# Examples\n:::{.example}\n## `lib.trivial.mod` usage example\n\n```nix\nmod 11 10\n=> 1\nmod 1 10\n=> 1\n```\n\n:::\n",
  "lib.trivial.oldestSupportedReleaseIsAtLeast": "\nAlias for `isInOldestRelease` introduced in 24.11.\nUse `isInOldestRelease` in expressions outside of Nixpkgs for greater compatibility.\n",
  "lib.trivial.or": "\nboolean “or”\n\n\n# Inputs\n\n`x`\n\n: 1\\. Function argument\n\n`y`\n\n: 2\\. Function argument\n",
  "lib.trivial.pathExists": "\nReturn `true` if the path *path* exists at evaluation time, and\n`false` otherwise.\n",
  "lib.trivial.pipe": "\nPipes a value through a list of functions, left to right.\n\n# Inputs\n\n`value`\n\n: Value to start piping.\n\n`fns`\n\n: List of functions to apply sequentially.\n\n# Type\n\n```\npipe :: a -> [<functions>] -> <return type of last function>\n```\n\n# Examples\n:::{.example}\n## `lib.trivial.pipe` usage example\n\n```nix\npipe 2 [\n    (x: x + 2)  # 2 + 2 = 4\n    (x: x * 2)  # 4 * 2 = 8\n  ]\n=> 8\n\n# ideal to do text transformations\npipe [ \"a/b\" \"a/c\" ] [\n\n  # create the cp command\n  (map (file: ''cp \"${src}/${file}\" $out\\n''))\n\n  # concatenate all commands into one string\n  lib.concatStrings\n\n  # make that string into a nix derivation\n  (pkgs.runCommand \"copy-to-out\" {})\n\n]\n=> <drv which copies all files to $out>\n\nThe output type of each function has to be the input type\nof the next function, and the last function returns the\nfinal value.\n```\n\n:::\n",
  "lib.trivial.readFile": "\nReturn the contents of the file *path* as a string.\n",
  "lib.trivial.revisionWithDefault": "\nAttempts to return the the current revision of nixpkgs and\nreturns the supplied default value otherwise.\n\n\n# Inputs\n\n`default`\n\n: Default value to return if revision can not be determined\n\n# Type\n\n```\nrevisionWithDefault :: string -> string\n```\n",
  "lib.trivial.seq": "\nEvaluate *e1*, then evaluate and return *e2*. This ensures that a\ncomputation is strict in the value of *e1*.\n",
  "lib.trivial.setFunctionArgs": "\nAdd metadata about expected function arguments to a function.\nThe metadata should match the format given by\nbuiltins.functionArgs, i.e. a set from expected argument to a bool\nrepresenting whether that argument has a default or not.\nsetFunctionArgs : (a → b) → Map String Bool → (a → b)\n\nThis function is necessary because you can't dynamically create a\nfunction of the { a, b ? foo, ... }: format, but some facilities\nlike callPackage expect to be able to query expected arguments.\n\n\n# Inputs\n\n`f`\n\n: 1\\. Function argument\n\n`args`\n\n: 2\\. Function argument\n",
  "lib.trivial.showWarnings": null,
  "lib.trivial.splitByAndCompare": "\nSplit type into two subtypes by predicate `p`, take all elements\nof the first subtype to be less than all the elements of the\nsecond subtype, compare elements of a single subtype with `yes`\nand `no` respectively.\n\n\n# Inputs\n\n`p`\n\n: Predicate\n\n`yes`\n\n: Comparison function if predicate holds for both values\n\n`no`\n\n: Comparison function if predicate holds for neither value\n\n`a`\n\n: First value to compare\n\n`b`\n\n: Second value to compare\n\n# Type\n\n```\n(a -> bool) -> (a -> a -> int) -> (a -> a -> int) -> (a -> a -> int)\n```\n\n# Examples\n:::{.example}\n## `lib.trivial.splitByAndCompare` usage example\n\n```nix\nlet cmp = splitByAndCompare (hasPrefix \"foo\") compare compare; in\n\ncmp \"a\" \"z\" => -1\ncmp \"fooa\" \"fooz\" => -1\n\ncmp \"f\" \"a\" => 1\ncmp \"fooa\" \"a\" => -1\n# while\ncompare \"fooa\" \"a\" => 1\n```\n\n:::\n",
  "lib.trivial.sub": "\nReturn the difference between the numbers *e1* and *e2*.\n",
  "lib.trivial.throwIf": "\nLike throwIfNot, but negated (throw if the first argument is `true`).\n\n\n# Inputs\n\n`cond`\n\n: 1\\. Function argument\n\n`msg`\n\n: 2\\. Function argument\n\n# Type\n\n```\nbool -> string -> a -> a\n```\n",
  "lib.trivial.throwIfNot": "\nLike the `assert b; e` expression, but with a custom error message and\nwithout the semicolon.\n\nIf true, return the identity function, `r: r`.\n\nIf false, throw the error message.\n\nCalls can be juxtaposed using function application, as `(r: r) a = a`, so\n`(r: r) (r: r) a = a`, and so forth.\n\n\n# Inputs\n\n`cond`\n\n: 1\\. Function argument\n\n`msg`\n\n: 2\\. Function argument\n\n# Type\n\n```\nbool -> string -> a -> a\n```\n\n# Examples\n:::{.example}\n## `lib.trivial.throwIfNot` usage example\n\n```nix\nthrowIfNot (lib.isList overlays) \"The overlays argument to nixpkgs must be a list.\"\nlib.foldr (x: throwIfNot (lib.isFunction x) \"All overlays passed to nixpkgs must be functions.\") (r: r) overlays\npkgs\n```\n\n:::\n",
  "lib.trivial.toBaseDigits": "\n`toBaseDigits base i` converts the positive integer i to a list of its\ndigits in the given base. For example:\n\ntoBaseDigits 10 123 => [ 1 2 3 ]\n\ntoBaseDigits 2 6 => [ 1 1 0 ]\n\ntoBaseDigits 16 250 => [ 15 10 ]\n\n\n# Inputs\n\n`base`\n\n: 1\\. Function argument\n\n`i`\n\n: 2\\. Function argument\n",
  "lib.trivial.toFunction": "\nTurns any non-callable values into constant functions.\nReturns callable values as is.\n\n\n# Inputs\n\n`v`\n\n: Any value\n\n\n# Examples\n:::{.example}\n## `lib.trivial.toFunction` usage example\n\n```nix\nnix-repl> lib.toFunction 1 2\n1\n\nnix-repl> lib.toFunction (x: x + 1) 2\n3\n```\n\n:::\n",
  "lib.trivial.toHexString": "\nConvert the given positive integer to a string of its hexadecimal\nrepresentation. For example:\n\ntoHexString 0 => \"0\"\n\ntoHexString 16 => \"10\"\n\ntoHexString 250 => \"FA\"\n",
  "lib.trivial.warn": "\n\n`warn` *`message`* *`value`*\n\nPrint a warning before returning the second argument.\n\nSee [`builtins.warn`](https://nix.dev/manual/nix/latest/language/builtins.html#builtins-warn) (Nix >= 2.23).\nOn older versions, the Nix 2.23 behavior is emulated with [`builtins.trace`](https://nix.dev/manual/nix/latest/language/builtins.html#builtins-warn), including the [`NIX_ABORT_ON_WARN`](https://nix.dev/manual/nix/latest/command-ref/conf-file#conf-abort-on-warn) behavior, but not the `nix.conf` setting or command line option.\n\n# Inputs\n\n*`message`* (String)\n\n: Warning message to print before evaluating *`value`*.\n\n*`value`* (any value)\n\n: Value to return as-is.\n\n# Type\n\n```\nString -> a -> a\n```\n",
  "lib.trivial.warnIf": "\n\n`warnIf` *`condition`* *`message`* *`value`*\n\nLike `warn`, but only warn when the first argument is `true`.\n\n# Inputs\n\n*`condition`* (Boolean)\n\n: `true` to trigger the warning before continuing with *`value`*.\n\n*`message`* (String)\n\n: Warning message to print before evaluating\n\n*`value`* (any value)\n\n: Value to return as-is.\n\n# Type\n\n```\nBool -> String -> a -> a\n```\n",
  "lib.trivial.warnIfNot": "\n\n`warnIfNot` *`condition`* *`message`* *`value`*\n\nLike `warnIf`, but negated: warn if the first argument is `false`.\n\n# Inputs\n\n*`condition`*\n\n: `false` to trigger the warning before continuing with `val`.\n\n*`message`*\n\n: Warning message to print before evaluating *`value`*.\n\n*`value`*\n\n: Value to return as-is.\n\n# Type\n\n```\nBoolean -> String -> a -> a\n```\n",
  "lib.trivial.xor": "\nboolean “exclusive or”\n\n\n# Inputs\n\n`x`\n\n: 1\\. Function argument\n\n`y`\n\n: 2\\. Function argument\n",
  "lib.types.addCheck": "Augment the given type with an additional type check function.",
  "lib.types.attrTag": null,
  "lib.types.attrsOf": null,
  "lib.types.attrsWith": null,
  "lib.types.coercedTo": "converted to `finalType` using `coerceFunc`.",
  "lib.types.defaultFunctor": "Default type functor",
  "lib.types.defaultTypeMerge": "takes two type functors and return the merged type",
  "lib.types.deferredModuleWith": "options declared via `config`.",
  "lib.types.either": "Either value of type `t1` or `t2`.",
  "lib.types.enum": "A value from a set of allowed ones.",
  "lib.types.functionTo": null,
  "lib.types.isOptionType": null,
  "lib.types.isType": null,
  "lib.types.lazyAttrsOf": "error that it's not defined. Use only if conditional definitions don't make sense.",
  "lib.types.listOf": null,
  "lib.types.loaOf": "TODO: deprecate this in the future:",
  "lib.types.mergeTypes": "\nMerges two option types together.\n\n:::{.note}\nUses the type merge function of the first type, to merge it with the second type.\n\nUsually types can only be merged if they are of the same type\n:::\n\n# Inputs\n\n: `a` (option type): The first option type.\n: `b` (option type): The second option type.\n\n# Returns\n\n- The merged option type.\n- `{ _type = \"merge-error\"; error = \"Cannot merge types\"; }` if the types can't be merged.\n\n# Examples\n:::{.example}\n## `lib.types.mergeTypes` usage example\n```nix\nlet\n  enumAB = lib.types.enum [\"A\" \"B\"];\n  enumXY = lib.types.enum [\"X\" \"Y\"];\n  # This operation could be notated as: [ A ] | [ B ] -> [ A B ]\n  merged = lib.types.mergeTypes enumAB enumXY; # -> enum [ \"A\" \"B\" \"X\" \"Y\" ]\nin\n  assert merged.check \"A\"; # true\n  assert merged.check \"B\"; # true\n  assert merged.check \"X\"; # true\n  assert merged.check \"Y\"; # true\n  merged.check \"C\" # false\n```\n:::\n",
  "lib.types.mkOptionType": null,
  "lib.types.nonEmptyListOf": null,
  "lib.types.nullOr": "Null or value of ...",
  "lib.types.oneOf": "Any of the types in the given list",
  "lib.types.optionDescriptionPhrase": "ambiguity.",
  "lib.types.passwdEntry": null,
  "lib.types.pathWith": null,
  "lib.types.separatedString": "separator between the values).",
  "lib.types.setType": null,
  "lib.types.strMatching": null,
  "lib.types.submodule": "A submodule (like typed attribute set). See NixOS manual.",
  "lib.types.submoduleWith": null,
  "lib.types.uniq": null,
  "lib.types.unique": null,
  "lib.versions.major": "\nGet the major version string from a string.\n\n# Inputs\n\n`v`\n\n: 1\\. Function argument\n\n# Examples\n:::{.example}\n## `major` usage example\n\n```nix\nmajor \"1.2.3\"\n=> \"1\"\n```\n\n:::\n",
  "lib.versions.majorMinor": "\nGet string of the first two parts (major and minor)\nof a version string.\n\n# Inputs\n\n`v`\n\n: 1\\. Function argument\n\n# Examples\n:::{.example}\n## `majorMinor` usage example\n\n```nix\nmajorMinor \"1.2.3\"\n=> \"1.2\"\n```\n\n:::\n",
  "lib.versions.minor": "\nGet the minor version string from a string.\n\n# Inputs\n\n`v`\n\n: 1\\. Function argument\n\n# Examples\n:::{.example}\n## `minor` usage example\n\n```nix\nminor \"1.2.3\"\n=> \"2\"\n```\n\n:::\n",
  "lib.versions.pad": "\nPad a version string with zeros to match the given number of components.\n\n# Inputs\n\n`n`\n\n: 1\\. Function argument\n\n`version`\n\n: 2\\. Function argument\n\n# Examples\n:::{.example}\n## `pad` usage example\n\n```nix\npad 3 \"1.2\"\n=> \"1.2.0\"\npad 3 \"1.3-rc1\"\n=> \"1.3.0-rc1\"\npad 3 \"1.2.3.4\"\n=> \"1.2.3\"\n```\n\n:::\n",
  "lib.versions.patch": "\nGet the patch version string from a string.\n\n# Inputs\n\n`v`\n\n: 1\\. Function argument\n\n# Examples\n:::{.example}\n## `patch` usage example\n\n```nix\npatch \"1.2.3\"\n=> \"3\"\n```\n\n:::\n",
  "lib.versions.splitVersion": "\nBreak a version string into its component parts.\n\n# Examples\n:::{.example}\n## `splitVersion` usage example\n\n```nix\nsplitVersion \"1.2.3\"\n=> [\"1\" \"2\" \"3\"]\n```\n\n:::\n",
  "lib.gvariant.type.arrayOf": null,
  "lib.gvariant.type.dictionaryEntryOf": null,
  "lib.gvariant.type.maybeOf": null,
  "lib.gvariant.type.tupleOf": null,
  "lib.misc.mergeAttrBy.buildInputs": "\nConcatenate two lists\n\n\n# Inputs\n\n`x`\n\n: 1\\. Function argument\n\n`y`\n\n: 2\\. Function argument\n\n# Type\n\n```\nconcat :: [a] -> [a] -> [a]\n```\n\n# Examples\n:::{.example}\n## `lib.trivial.concat` usage example\n\n```nix\nconcat [ 1 2 ] [ 3 4 ]\n=> [ 1 2 3 4 ]\n```\n\n:::\n",
  "lib.misc.mergeAttrBy.cfg": "\nMerge two attribute sets shallowly, right side trumps left\n\nmergeAttrs :: attrs -> attrs -> attrs\n\n\n# Inputs\n\n`x`\n\n: Left attribute set\n\n`y`\n\n: Right attribute set (higher precedence for equal keys)\n\n\n# Examples\n:::{.example}\n## `lib.trivial.mergeAttrs` usage example\n\n```nix\nmergeAttrs { a = 1; b = 2; } { b = 3; c = 4; }\n=> { a = 1; b = 3; c = 4; }\n```\n\n:::\n",
  "lib.misc.mergeAttrBy.configureFlags": "\nConcatenate two lists\n\n\n# Inputs\n\n`x`\n\n: 1\\. Function argument\n\n`y`\n\n: 2\\. Function argument\n\n# Type\n\n```\nconcat :: [a] -> [a] -> [a]\n```\n\n# Examples\n:::{.example}\n## `lib.trivial.concat` usage example\n\n```nix\nconcat [ 1 2 ] [ 3 4 ]\n=> [ 1 2 3 4 ]\n```\n\n:::\n",
  "lib.misc.mergeAttrBy.flags": "\nMerge two attribute sets shallowly, right side trumps left\n\nmergeAttrs :: attrs -> attrs -> attrs\n\n\n# Inputs\n\n`x`\n\n: Left attribute set\n\n`y`\n\n: Right attribute set (higher precedence for equal keys)\n\n\n# Examples\n:::{.example}\n## `lib.trivial.mergeAttrs` usage example\n\n```nix\nmergeAttrs { a = 1; b = 2; } { b = 3; c = 4; }\n=> { a = 1; b = 3; c = 4; }\n```\n\n:::\n",
  "lib.misc.mergeAttrBy.meta": "\nMerge two attribute sets shallowly, right side trumps left\n\nmergeAttrs :: attrs -> attrs -> attrs\n\n\n# Inputs\n\n`x`\n\n: Left attribute set\n\n`y`\n\n: Right attribute set (higher precedence for equal keys)\n\n\n# Examples\n:::{.example}\n## `lib.trivial.mergeAttrs` usage example\n\n```nix\nmergeAttrs { a = 1; b = 2; } { b = 3; c = 4; }\n=> { a = 1; b = 3; c = 4; }\n```\n\n:::\n",
  "lib.misc.mergeAttrBy.nativeBuildInputs": "\nConcatenate two lists\n\n\n# Inputs\n\n`x`\n\n: 1\\. Function argument\n\n`y`\n\n: 2\\. Function argument\n\n# Type\n\n```\nconcat :: [a] -> [a] -> [a]\n```\n\n# Examples\n:::{.example}\n## `lib.trivial.concat` usage example\n\n```nix\nconcat [ 1 2 ] [ 3 4 ]\n=> [ 1 2 3 4 ]\n```\n\n:::\n",
  "lib.misc.mergeAttrBy.passthru": "\nMerge two attribute sets shallowly, right side trumps left\n\nmergeAttrs :: attrs -> attrs -> attrs\n\n\n# Inputs\n\n`x`\n\n: Left attribute set\n\n`y`\n\n: Right attribute set (higher precedence for equal keys)\n\n\n# Examples\n:::{.example}\n## `lib.trivial.mergeAttrs` usage example\n\n```nix\nmergeAttrs { a = 1; b = 2; } { b = 3; c = 4; }\n=> { a = 1; b = 3; c = 4; }\n```\n\n:::\n",
  "lib.misc.mergeAttrBy.patches": "\nConcatenate two lists\n\n\n# Inputs\n\n`x`\n\n: 1\\. Function argument\n\n`y`\n\n: 2\\. Function argument\n\n# Type\n\n```\nconcat :: [a] -> [a] -> [a]\n```\n\n# Examples\n:::{.example}\n## `lib.trivial.concat` usage example\n\n```nix\nconcat [ 1 2 ] [ 3 4 ]\n=> [ 1 2 3 4 ]\n```\n\n:::\n",
  "lib.misc.mergeAttrBy.postAll": "\nConcatenate two lists\n\n\n# Inputs\n\n`x`\n\n: 1\\. Function argument\n\n`y`\n\n: 2\\. Function argument\n\n# Type\n\n```\nconcat :: [a] -> [a] -> [a]\n```\n\n# Examples\n:::{.example}\n## `lib.trivial.concat` usage example\n\n```nix\nconcat [ 1 2 ] [ 3 4 ]\n=> [ 1 2 3 4 ]\n```\n\n:::\n",
  "lib.misc.mergeAttrBy.postInstall": null,
  "lib.misc.mergeAttrBy.preConfigure": null,
  "lib.misc.mergeAttrBy.prePhases": "\nConcatenate two lists\n\n\n# Inputs\n\n`x`\n\n: 1\\. Function argument\n\n`y`\n\n: 2\\. Function argument\n\n# Type\n\n```\nconcat :: [a] -> [a] -> [a]\n```\n\n# Examples\n:::{.example}\n## `lib.trivial.concat` usage example\n\n```nix\nconcat [ 1 2 ] [ 3 4 ]\n=> [ 1 2 3 4 ]\n```\n\n:::\n",
  "lib.misc.mergeAttrBy.propagatedBuildInputs": "\nConcatenate two lists\n\n\n# Inputs\n\n`x`\n\n: 1\\. Function argument\n\n`y`\n\n: 2\\. Function argument\n\n# Type\n\n```\nconcat :: [a] -> [a] -> [a]\n```\n\n# Examples\n:::{.example}\n## `lib.trivial.concat` usage example\n\n```nix\nconcat [ 1 2 ] [ 3 4 ]\n=> [ 1 2 3 4 ]\n```\n\n:::\n",
  "lib.network.ipv6.fromString": "\nCreates an `IPv6Address` object from an IPv6 address as a string. If\nthe prefix length is omitted, it defaults to 64. The parser is limited\nto the first two versions of IPv6 addresses addressed in RFC 4291.\nThe form \"x:x:x:x:x:x:d.d.d.d\" is not yet implemented. Addresses are\nNOT compressed, so they are not always the same as the canonical text\nrepresentation of IPv6 addresses defined in RFC 5952.\n\n# Type\n\n```\nfromString :: String -> IPv6Address\n```\n\n# Examples\n\n```nix\nfromString \"2001:DB8::ffff/32\"\n=> {\n  address = \"2001:db8:0:0:0:0:0:ffff\";\n  prefixLength = 32;\n}\n```\n\n# Arguments\n\n- [addr] An IPv6 address with optional prefix length.\n",
  "lib.path.subpath.components": "\nSplit [a subpath](#function-library-lib.path.subpath.isValid) into its path component strings.\nThrow an error if the subpath isn't valid.\nNote that the returned path components are also [valid subpath strings](#function-library-lib.path.subpath.isValid), though they are intentionally not [normalised](#function-library-lib.path.subpath.normalise).\n\nLaws:\n\n- Splitting a subpath into components and [joining](#function-library-lib.path.subpath.join) the components gives the same subpath but [normalised](#function-library-lib.path.subpath.normalise):\n\n      subpath.join (subpath.components s) == subpath.normalise s\n\n# Inputs\n\n`subpath`\n\n: The subpath string to split into components\n\n# Type\n\n```\nsubpath.components :: String -> [ String ]\n```\n\n# Examples\n:::{.example}\n## `subpath.components` usage example\n\n```nix\nsubpath.components \".\"\n=> [ ]\n\nsubpath.components \"./foo//bar/./baz/\"\n=> [ \"foo\" \"bar\" \"baz\" ]\n\nsubpath.components \"/foo\"\n=> <error>\n```\n\n:::\n",
  "lib.path.subpath.isValid": "\nWhether a value is a valid subpath string.\n\nA subpath string points to a specific file or directory within an absolute base directory.\nIt is a stricter form of a relative path that excludes `..` components, since those could escape the base directory.\n\n- The value is a string.\n\n- The string is not empty.\n\n- The string doesn't start with a `/`.\n\n- The string doesn't contain any `..` path components.\n\n# Inputs\n\n`value`\n\n: The value to check\n\n# Type\n\n```\nsubpath.isValid :: String -> Bool\n```\n\n# Examples\n:::{.example}\n## `subpath.isValid` usage example\n\n```nix\n# Not a string\nsubpath.isValid null\n=> false\n\n# Empty string\nsubpath.isValid \"\"\n=> false\n\n# Absolute path\nsubpath.isValid \"/foo\"\n=> false\n\n# Contains a `..` path component\nsubpath.isValid \"../foo\"\n=> false\n\n# Valid subpath\nsubpath.isValid \"foo/bar\"\n=> true\n\n# Doesn't need to be normalised\nsubpath.isValid \"./foo//bar/\"\n=> true\n```\n\n:::\n",
  "lib.path.subpath.join": "\nJoin subpath strings together using `/`, returning a normalised subpath string.\n\nLike `concatStringsSep \"/\"` but safer, specifically:\n\n- All elements must be [valid subpath strings](#function-library-lib.path.subpath.isValid).\n\n- The result gets [normalised](#function-library-lib.path.subpath.normalise).\n\n- The edge case of an empty list gets properly handled by returning the neutral subpath `\"./.\"`.\n\nLaws:\n\n- Associativity:\n\n      subpath.join [ x (subpath.join [ y z ]) ] == subpath.join [ (subpath.join [ x y ]) z ]\n\n- Identity - `\"./.\"` is the neutral element for normalised paths:\n\n      subpath.join [ ] == \"./.\"\n      subpath.join [ (subpath.normalise p) \"./.\" ] == subpath.normalise p\n      subpath.join [ \"./.\" (subpath.normalise p) ] == subpath.normalise p\n\n- Normalisation - the result is [normalised](#function-library-lib.path.subpath.normalise):\n\n      subpath.join ps == subpath.normalise (subpath.join ps)\n\n- For non-empty lists, the implementation is equivalent to [normalising](#function-library-lib.path.subpath.normalise) the result of `concatStringsSep \"/\"`.\n  Note that the above laws can be derived from this one:\n\n      ps != [] -> subpath.join ps == subpath.normalise (concatStringsSep \"/\" ps)\n\n# Inputs\n\n`subpaths`\n\n: The list of subpaths to join together\n\n# Type\n\n```\nsubpath.join :: [ String ] -> String\n```\n\n# Examples\n:::{.example}\n## `subpath.join` usage example\n\n```nix\nsubpath.join [ \"foo\" \"bar/baz\" ]\n=> \"./foo/bar/baz\"\n\n# normalise the result\nsubpath.join [ \"./foo\" \".\" \"bar//./baz/\" ]\n=> \"./foo/bar/baz\"\n\n# passing an empty list results in the current directory\nsubpath.join [ ]\n=> \"./.\"\n\n# elements must be valid subpath strings\nsubpath.join [ /foo ]\n=> <error>\nsubpath.join [ \"\" ]\n=> <error>\nsubpath.join [ \"/foo\" ]\n=> <error>\nsubpath.join [ \"../foo\" ]\n=> <error>\n```\n\n:::\n",
  "lib.path.subpath.normalise": "\nNormalise a subpath. Throw an error if the subpath isn't [valid](#function-library-lib.path.subpath.isValid).\n\n- Limit repeating `/` to a single one.\n\n- Remove redundant `.` components.\n\n- Remove trailing `/` and `/.`.\n\n- Add leading `./`.\n\nLaws:\n\n- Idempotency - normalising multiple times gives the same result:\n\n      subpath.normalise (subpath.normalise p) == subpath.normalise p\n\n- Uniqueness - there's only a single normalisation for the paths that lead to the same file system node:\n\n      subpath.normalise p != subpath.normalise q -> $(realpath ${p}) != $(realpath ${q})\n\n- Don't change the result when [appended](#function-library-lib.path.append) to a Nix path value:\n\n      append base p == append base (subpath.normalise p)\n\n- Don't change the path according to `realpath`:\n\n      $(realpath ${p}) == $(realpath ${subpath.normalise p})\n\n- Only error on [invalid subpaths](#function-library-lib.path.subpath.isValid):\n\n      builtins.tryEval (subpath.normalise p)).success == subpath.isValid p\n\n# Inputs\n\n`subpath`\n\n: The subpath string to normalise\n\n# Type\n\n```\nsubpath.normalise :: String -> String\n```\n\n# Examples\n:::{.example}\n## `subpath.normalise` usage example\n\n```nix\n# limit repeating `/` to a single one\nsubpath.normalise \"foo//bar\"\n=> \"./foo/bar\"\n\n# remove redundant `.` components\nsubpath.normalise \"foo/./bar\"\n=> \"./foo/bar\"\n\n# add leading `./`\nsubpath.normalise \"foo/bar\"\n=> \"./foo/bar\"\n\n# remove trailing `/`\nsubpath.normalise \"foo/bar/\"\n=> \"./foo/bar\"\n\n# remove trailing `/.`\nsubpath.normalise \"foo/bar/.\"\n=> \"./foo/bar\"\n\n# Return the current directory as `./.`\nsubpath.normalise \".\"\n=> \"./.\"\n\n# error on `..` path components\nsubpath.normalise \"foo/../bar\"\n=> <error>\n\n# error on empty string\nsubpath.normalise \"\"\n=> <error>\n\n# error on absolute path\nsubpath.normalise \"/foo\"\n=> <error>\n```\n\n:::\n",
  "lib.systems.inspect.matchAnyAttrs": null,
  "lib.systems.inspect.patternLogicalAnd": "Since a pattern is a list-of-disjuncts, this needs to",
  "lib.systems.parse.doubleFromSystem": null,
  "lib.systems.parse.gnuNetBSDDefaultExecFormat": "GNU build systems assume that older NetBSD architectures are using a.out.",
  "lib.systems.parse.isCompatible": null,
  "lib.systems.parse.isSystem": null,
  "lib.systems.parse.kernelName": null,
  "lib.systems.parse.mkSkeletonFromList": null,
  "lib.systems.parse.mkSystem": null,
  "lib.systems.parse.mkSystemFromSkeleton": "This should revert the job done by config.guess from the gcc compiler.",
  "lib.systems.parse.mkSystemFromString": null,
  "lib.systems.parse.tripleFromSystem": null,
  "lib.systems.platforms.select": "included in the platform in order to further elaborate it.",
  "lib.types.ints.between": null,
  "lib.types.numbers.between": null,
  "lib.systems.architectures.predicates.aesSupport": null,
  "lib.systems.architectures.predicates.avx2Support": null,
  "lib.systems.architectures.predicates.avx512Support": null,
  "lib.systems.architectures.predicates.avxSupport": null,
  "lib.systems.architectures.predicates.fma4Support": null,
  "lib.systems.architectures.predicates.fmaSupport": null,
  "lib.systems.architectures.predicates.sse3Support": null,
  "lib.systems.architectures.predicates.sse4_1Support": null,
  "lib.systems.architectures.predicates.sse4_2Support": null,
  "lib.systems.architectures.predicates.sse4_aSupport": null,
  "lib.systems.architectures.predicates.ssse3Support": null,
  "lib.systems.inspect.predicates.is32bit": null,
  "lib.systems.inspect.predicates.is64bit": null,
  "lib.systems.inspect.predicates.isAarch": null,
  "lib.systems.inspect.predicates.isAarch32": null,
  "lib.systems.inspect.predicates.isAarch64": null,
  "lib.systems.inspect.predicates.isAbiElfv2": null,
  "lib.systems.inspect.predicates.isAlpha": null,
  "lib.systems.inspect.predicates.isAndroid": null,
  "lib.systems.inspect.predicates.isArmv7": null,
  "lib.systems.inspect.predicates.isAvr": null,
  "lib.systems.inspect.predicates.isBSD": null,
  "lib.systems.inspect.predicates.isBigEndian": null,
  "lib.systems.inspect.predicates.isCygwin": null,
  "lib.systems.inspect.predicates.isDarwin": null,
  "lib.systems.inspect.predicates.isEfi": null,
  "lib.systems.inspect.predicates.isElf": null,
  "lib.systems.inspect.predicates.isFreeBSD": null,
  "lib.systems.inspect.predicates.isGenode": null,
  "lib.systems.inspect.predicates.isGhcjs": null,
  "lib.systems.inspect.predicates.isGnu": null,
  "lib.systems.inspect.predicates.isILP32": null,
  "lib.systems.inspect.predicates.isJavaScript": null,
  "lib.systems.inspect.predicates.isLLVMLibc": null,
  "lib.systems.inspect.predicates.isLinux": null,
  "lib.systems.inspect.predicates.isLittleEndian": null,
  "lib.systems.inspect.predicates.isLoongArch64": null,
  "lib.systems.inspect.predicates.isM68k": null,
  "lib.systems.inspect.predicates.isMacOS": null,
  "lib.systems.inspect.predicates.isMacho": null,
  "lib.systems.inspect.predicates.isMicroBlaze": null,
  "lib.systems.inspect.predicates.isMinGW": null,
  "lib.systems.inspect.predicates.isMips": null,
  "lib.systems.inspect.predicates.isMips32": null,
  "lib.systems.inspect.predicates.isMips64": null,
  "lib.systems.inspect.predicates.isMips64n32": null,
  "lib.systems.inspect.predicates.isMips64n64": null,
  "lib.systems.inspect.predicates.isMmix": null,
  "lib.systems.inspect.predicates.isMsp430": null,
  "lib.systems.inspect.predicates.isMusl": null,
  "lib.systems.inspect.predicates.isNetBSD": null,
  "lib.systems.inspect.predicates.isNone": null,
  "lib.systems.inspect.predicates.isOpenBSD": null,
  "lib.systems.inspect.predicates.isOr1k": null,
  "lib.systems.inspect.predicates.isPower": null,
  "lib.systems.inspect.predicates.isPower64": null,
  "lib.systems.inspect.predicates.isRedox": null,
  "lib.systems.inspect.predicates.isRiscV": null,
  "lib.systems.inspect.predicates.isRiscV32": null,
  "lib.systems.inspect.predicates.isRiscV64": null,
  "lib.systems.inspect.predicates.isRx": null,
  "lib.systems.inspect.predicates.isS390": null,
  "lib.systems.inspect.predicates.isS390x": null,
  "lib.systems.inspect.predicates.isSparc": null,
  "lib.systems.inspect.predicates.isSparc64": null,
  "lib.systems.inspect.predicates.isSunOS": null,
  "lib.systems.inspect.predicates.isUClibc": null,
  "lib.systems.inspect.predicates.isUnix": null,
  "lib.systems.inspect.predicates.isVc4": null,
  "lib.systems.inspect.predicates.isWasi": null,
  "lib.systems.inspect.predicates.isWasm": null,
  "lib.systems.inspect.predicates.isWindows": null,
  "lib.systems.inspect.predicates.isi686": null,
  "lib.systems.inspect.predicates.isiOS": null,
  "lib.systems.inspect.predicates.isx86": null,
  "lib.systems.inspect.predicates.isx86_32": null,
  "lib.systems.inspect.predicates.isx86_64": null,
  "make-disk-image": "\nTechnical details\n\n`make-disk-image` has a bit of magic to minimize the amount of work to do in a virtual machine.\n\nIt relies on the [LKL (Linux Kernel Library) project](https://github.com/lkl/linux) which provides Linux kernel as userspace library.\n\nThe Nix-store only image only need to run LKL tools to produce an image and will never spawn a virtual machine, whereas full images will always require a virtual machine, but also use LKL.\n\n### Image preparation phase\n\nImage preparation phase will produce the initial image layout in a folder:\n\n- devise a root folder based on `$PWD`\n- prepare the contents by copying and restoring ACLs in this root folder\n- load in the Nix store database all additional paths computed by `pkgs.closureInfo` in a temporary Nix store\n- run `nixos-install` in a temporary folder\n- transfer from the temporary store the additional paths registered to the installed NixOS\n- compute the size of the disk image based on the apparent size of the root folder\n- partition the disk image using the corresponding script according to the partition table type\n- format the partitions if needed\n- use `cptofs` (LKL tool) to copy the root folder inside the disk image\n\nAt this step, the disk image already contains the Nix store, it now only needs to be converted to the desired format to be used.\n\n### Image conversion phase\n\nUsing `qemu-img`, the disk image is converted from a raw format to the desired format: qcow2(-compressed), vdi, vpc.\n\n### Image Partitioning\n\n#### `none`\n\nNo partition table layout is written. The image is a bare filesystem image.\n\n#### `legacy`\n\nThe image is partitioned using MBR. There is one primary ext4 partition starting at 1 MiB that fills the rest of the disk image.\n\nThis partition layout is unsuitable for UEFI.\n\n#### `legacy+gpt`\n\nThis partition table type uses GPT and:\n\n- create a \"no filesystem\" partition from 1MiB to 2MiB ;\n- set `bios_grub` flag on this \"no filesystem\" partition, which marks it as a [GRUB BIOS partition](https://www.gnu.org/software/parted/manual/html_node/set.html) ;\n- create a primary ext4 partition starting at 2MiB and extending to the full disk image ;\n- perform optimal alignments checks on each partition\n\nThis partition layout is unsuitable for UEFI boot, because it has no ESP (EFI System Partition) partition. It can work with CSM (Compatibility Support Module) which emulates legacy (BIOS) boot for UEFI.\n\n#### `efi`\n\nThis partition table type uses GPT and:\n\n- creates an FAT32 ESP partition from 8MiB to specified `bootSize` parameter (256MiB by default), set it bootable ;\n- creates an primary ext4 partition starting after the boot partition and extending to the full disk image\n\n#### `efixbootldr`\n\nThis partition table type uses GPT and:\n\n- creates an FAT32 ESP partition from 8MiB to 100MiB, set it bootable ;\n- creates an FAT32 BOOT partition from 100MiB to specified `bootSize` parameter (256MiB by default), set `bls_boot` flag ;\n- creates an primary ext4 partition starting after the boot partition and extending to the full disk image\n\n#### `hybrid`\n\nThis partition table type uses GPT and:\n\n- creates a \"no filesystem\" partition from 0 to 1MiB, set `bios_grub` flag on it ;\n- creates an FAT32 ESP partition from 8MiB to specified `bootSize` parameter (256MiB by default), set it bootable ;\n- creates a primary ext4 partition starting after the boot one and extending to the full disk image\n\nThis partition could be booted by a BIOS able to understand GPT layouts and recognizing the MBR at the start.\n\n### How to run determinism analysis on results?\n\nBuild your derivation with `--check` to rebuild it and verify it is the same.\n\nIf it fails, you will be left with two folders with one having `.check`.\n\nYou can use `diffoscope` to see the differences between the folders.\n\nHowever, `diffoscope` is currently not able to diff two QCOW2 filesystems, thus, it is advised to use raw format.\n\nEven if you use raw disks, `diffoscope` cannot diff the partition table and partitions recursively.\n\nTo solve this, you can run `fdisk -l $image` and generate `dd if=$image of=$image-p$i.raw skip=$start count=$sectors` for each `(start, sectors)` listed in the `fdisk` output. Now, you will have each partition as a separate file and you can compare them in pairs.\n",
  "pkgs.ociTools.buildContainer": null,
  "pkgs.ociTools.override": null,
  "pkgs.ociTools.overrideDerivation": null,
  "pkgs._internalCallByNamePackageFile": "Because at that point the code in ./stage.nix can be changed to not allow definitions in `all-packages.nix` to override ones from `pkgs/by-name` anymore and throw an error if that happens instead.",
  "pkgs.addAttrsToDerivation": "\nModify a stdenv so that the specified attributes are added to\nevery derivation returned by its mkDerivation function.\n\n\n# Inputs\n\n`extraAttrs`\n\n: 1\\. Function argument\n\n`stdenv`\n\n: 2\\. Function argument\n\n\n# Examples\n:::{.example}\n## `addAttrsToDerivation` usage example\n\n```nix\nstdenvNoOptimise =\n  addAttrsToDerivation\n    { env.NIX_CFLAGS_COMPILE = \"-O0\"; }\n    stdenv;\n```\n\n:::\n",
  "pkgs.aggregateModules": null,
  "pkgs.apacheHttpdPackagesFor": null,
  "pkgs.apparmorRulesFromClosure": "include \"${apparmorRulesFromClosure { } [ pkgs.hello ]}\"",
  "pkgs.appendOverlays": "in one go when calling Nixpkgs, for performance and simplicity.",
  "pkgs.applyPatches": "\nApplies a list of patches to a source directory.\n\n\n# Examples\n:::{.example}\n## `applyPatches` usage example\n\n```nix\n# Patching nixpkgs:\n\napplyPatches {\n  src = pkgs.path;\n  patches = [\n    (pkgs.fetchpatch {\n      url = \"https://github.com/NixOS/nixpkgs/commit/1f770d20550a413e508e081ddc08464e9d08ba3d.patch\";\n      sha256 = \"1nlzx171y3r3jbk0qhvnl711kmdk57jlq4na8f8bs8wz2pbffymr\";\n    })\n  ];\n}\n```\n\n:::\n",
  "pkgs.aspellWithDicts": null,
  "pkgs.bitlbee-plugins": null,
  "pkgs.blender-with-packages": "Added 2024-02-25",
  "pkgs.buildArmTrustedFirmware": null,
  "pkgs.buildBarebox": null,
  "pkgs.buildBazelPackage": null,
  "pkgs.buildBowerComponents": null,
  "pkgs.buildDartApplication": null,
  "pkgs.buildDotnetGlobalTool": null,
  "pkgs.buildDotnetModule": null,
  "pkgs.buildDotnetPackage": null,
  "pkgs.buildDubPackage": null,
  "pkgs.buildEmscriptenPackage": null,
  "pkgs.buildEnv": null,
  "pkgs.buildFHSEnv": null,
  "pkgs.buildFHSEnvBubblewrap": null,
  "pkgs.buildFHSEnvChroot": null,
  "pkgs.buildFHSUserEnv": null,
  "pkgs.buildFHSUserEnvBubblewrap": null,
  "pkgs.buildFHSUserEnvChroot": null,
  "pkgs.buildGo122Module": null,
  "pkgs.buildGo123Module": null,
  "pkgs.buildGo124Module": null,
  "pkgs.buildGoModule": null,
  "pkgs.buildGraalvmNativeImage": null,
  "pkgs.buildHomeAssistantComponent": null,
  "pkgs.buildLinux": null,
  "pkgs.buildMaven": null,
  "pkgs.buildMozillaMach": null,
  "pkgs.buildNimPackage": null,
  "pkgs.buildNimSbom": null,
  "pkgs.buildNpmPackage": null,
  "pkgs.buildPgrxExtension": null,
  "pkgs.buildRubyGem": null,
  "pkgs.buildRustCrate": "\nThe overridable pkgs.buildRustCrate function.\n*\n* Any unrecognized parameters will be passed as to\n* the underlying stdenv.mkDerivation.\n",
  "pkgs.buildUBoot": null,
  "pkgs.buildWasmBindgenCli": null,
  "pkgs.buildXenPackage": null,
  "pkgs.bundlerApp": null,
  "pkgs.bundlerEnv": null,
  "pkgs.bundlerUpdateScript": null,
  "pkgs.callPackage": null,
  "pkgs.callPackage_i686": null,
  "pkgs.callPackages": null,
  "pkgs.closureInfo": null,
  "pkgs.compressDrv": "\nCompresses files of a given derivation, and returns a new derivation with\ncompressed files\n\n# Inputs\n\n`formats` ([String])\n\n: List of file extensions to compress. Example: `[\"txt\" \"svg\" \"xml\"]`.\n\n`extraFindOperands` (String)\n\n: Extra command line parameters to pass to the find command.\n  This can be used to exclude certain files.\n  For example: `-not -iregex \".*(\\/apps\\/.*\\/l10n\\/).*\"`\n\n`compressors` ( { ${fileExtension} :: String })\n\n: Map a desired extension (e.g. `gz`) to a compress program.\n\n  The compressor program that will be executed to get the `COMPRESSOR` extension.\n  The program should have a single \" {}\", which will be the replaced with the\n  target filename.\n\n  Compressor must:\n\n  - read symlinks (thus --force is needed to gzip, zstd, xz).\n  - keep the original file in place (--keep).\n\n# Type\n\n```\ncompressDrv :: Derivation -> { formats :: [ String ]; compressors :: { ${fileExtension} :: String; } } -> Derivation\n```\n\n# Examples\n:::{.example}\n## `pkgs.compressDrv` usage example\n```\ncompressDrv pkgs.spdx-license-list-data.json {\n  formats = [\"json\"];\n  compressors = {\n    gz = \"${zopfli}/bin/zopfli --keep {}\";\n  };\n}\n=>\n«derivation /nix/store/...-spdx-license-list-data-3.24.0-compressed.drv»\n```\n\nSee also pkgs.compressDrvWeb, which is a wrapper on top of compressDrv, for broader usage\nexamples.\n:::\n",
  "pkgs.compressDrvWeb": "\ncompressDrvWeb compresses a derivation for common web server use.\n\nUseful when one wants to pre-compress certain static assets and pass them to\nthe web server.\n\n# Inputs\n\n`formats` ([String])\n\n: List of file extensions to compress.\n\n  Defaults to common formats that compress well.\n\n`extraFindOperands` (String)\n\n: See compressDrv for details.\n\n`extraFormats` ([ String ])\n\n: Extra extensions to compress in addition to `formats`.\n\n`compressors` ( { ${fileExtension} :: String })\n\n: Map a desired extension (e.g. `gz`) to a compress program.\n\n# Type\n\n```\ncompressDrvWeb :: Derivation -> { formats :: [ String ]; extraFormats :: [ String ]; compressors :: { ${fileExtension} :: String; } } -> Derivation\n```\n\n# Examples\n:::{.example}\n## `pkgs.compressDrvWeb` full usage example with `pkgs.gamja` and a webserver\n```nix\n\nFor example, building `pkgs.gamja` produces the following output:\n\n  /nix/store/2wn1qbk8gp4y2m8xvafxv1b2dcdqj8fz-gamja-1.0.0-beta.9/\n  ├── index.2fd01148.js\n  ├── index.2fd01148.js.map\n  ├── index.37aa9a8a.css\n  ├── index.37aa9a8a.css.map\n  ├── index.html\n  └── manifest.webmanifest\n\nWith `pkgs.compressDrvWeb`, one can compress these files:\n\n```nix\npkgs.compressDrvWeb pkgs.gamja {}\n=>\n«derivation /nix/store/...-gamja-compressed.drv»\n```\n\n```bash\n/nix/store/f5ryid7zrw2hid7h9kil5g5j29q5r2f7-gamja-1.0.0-beta.9-compressed\n├── index.2fd01148.js -> /nix/store/2wn1qbk8gp4y2m8xvafxv1b2dcdqj8fz-gamja-1.0.0-beta.9/index.2fd01148.js\n├── index.2fd01148.js.br\n├── index.2fd01148.js.gz\n├── index.2fd01148.js.map -> /nix/store/2wn1qbk8gp4y2m8xvafxv1b2dcdqj8fz-gamja-1.0.0-beta.9/index.2fd01148.js.map\n├── index.2fd01148.js.map.br\n├── index.2fd01148.js.map.gz\n├── index.37aa9a8a.css -> /nix/store/2wn1qbk8gp4y2m8xvafxv1b2dcdqj8fz-gamja-1.0.0-beta.9/index.37aa9a8a.css\n├── index.37aa9a8a.css.br\n├── index.37aa9a8a.css.gz\n├── index.37aa9a8a.css.map -> /nix/store/2wn1qbk8gp4y2m8xvafxv1b2dcdqj8fz-gamja-1.0.0-beta.9/index.37aa9a8a.css.map\n├── index.37aa9a8a.css.map.br\n├── index.37aa9a8a.css.map.gz\n├── index.html -> /nix/store/2wn1qbk8gp4y2m8xvafxv1b2dcdqj8fz-gamja-1.0.0-beta.9/index.html\n├── index.html.br\n├── index.html.gz\n├── manifest.webmanifest -> /nix/store/2wn1qbk8gp4y2m8xvafxv1b2dcdqj8fz-gamja-1.0.0-beta.9/manifest.webmanifest\n├── manifest.webmanifest.br\n└── manifest.webmanifest.gz\n```\n\nWhen the `-compressed` derivation is passed to a properly configured web server,\nit enables direct serving of the pre-compressed files.\n\n```shell-session\n$ curl -I -H 'Accept-Encoding: br' https://irc.example.org/\n<...>\ncontent-encoding: br\n<...>\n```\n\nFor example, a caddy configuration snippet for gamja to serve\nthe static assets (JS, CSS files) pre-compressed:\n\n```nix\n{\n  virtualHosts.\"irc.example.org\".extraConfig = ''\n    root * ${pkgs.compressDrvWeb pkgs.gamja {}}\n    file_server browse {\n        precompressed br gzip\n    }\n  '';\n}\n```\n\nThis feature is also available in nginx via `ngx_brotli` and\n`ngx_http_gzip_static_module`.\n:::\n",
  "pkgs.compressFirmwareXz": null,
  "pkgs.compressFirmwareZstd": null,
  "pkgs.concatScript": "\nWrites a text file to nix store with and mark it as executable.\n\n\n# Inputs\n\n`name`\n\n: 1\\. Function argument\n\n`files`\n\n: 2\\. Function argument\n\n\n# Examples\n:::{.example}\n## `concatScript` usage example\n\n```nix\n# Writes contents of files to /nix/store/<store path>\nconcatScript \"my-file\" [ file1 file2 ]\n```\n\n:::\n",
  "pkgs.concatText": "\nWrites a text file to nix store with no optional parameters available.\n\n\n# Inputs\n\n`name`\n\n: 1\\. Function argument\n\n`files`\n\n: 2\\. Function argument\n\n\n# Examples\n:::{.example}\n## `concatText` usage example\n\n```nix\n# Writes contents of files to /nix/store/<store path>\nconcatText \"my-file\" [ file1 file2 ]\n```\n\n:::\n",
  "pkgs.concatTextFile": "\nconcat a list of files to the nix store.\nThe contents of files are added to the file in the store.\n\n\n# Examples\n:::{.example}\n## `concatTextFile` usage example\n\n```nix\n# Writes my-file to /nix/store/<store path>\nconcatTextFile {\n  name = \"my-file\";\n  files = [ drv1 \"${drv2}/path/to/file\" ];\n}\n\n\nSee also the `concatText` helper function below.\n\n\n# Writes executable my-file to /nix/store/<store path>/bin/my-file\nconcatTextFile {\n  name = \"my-file\";\n  files = [ drv1 \"${drv2}/path/to/file\" ];\n  executable = true;\n  destination = \"/bin/my-file\";\n}\n```\n\n:::\n",
  "pkgs.copyPathToStore": "\nCopy a path to the Nix store.\nNix automatically copies files to the store before stringifying paths.\nIf you need the store path of a file, ${copyPathToStore <path>} can be\nshortened to ${<path>}.\n",
  "pkgs.copyPathsToStore": "\nCopy a list of paths to the Nix store.\n",
  "pkgs.darwinMinVersionHook": null,
  "pkgs.datadog-integrations-core": null,
  "pkgs.dhallDirectoryToNix": null,
  "pkgs.dhallPackageToNix": null,
  "pkgs.dhallToNix": null,
  "pkgs.dictDBCollector": null,
  "pkgs.diffPlugins": "\nTakes a list of expected plugin names\nand compares it to the found plugins given in the file,\none plugin per line.\nIf the lists differ, the build fails with a nice message.\n\nThis is helpful to ensure maintainers don’t miss\nthe addition or removal of a plugin.\n\n\n# Inputs\n\n`expectedPlugins`\n\n: 1\\. Function argument\n\n`foundPluginsFilePath`\n\n: 2\\. Function argument\n",
  "pkgs.directoryListingUpdater": null,
  "pkgs.dockerMakeLayers": null,
  "pkgs.dontRecurseIntoAttrs": "\nUndo the effect of recurseIntoAttrs.\n\n\n# Inputs\n\n`attrs`\n\n: An attribute set to not scan for derivations.\n\n# Type\n\n```\ndontRecurseIntoAttrs :: AttrSet -> AttrSet\n```\n",
  "pkgs.eggDerivation": null,
  "pkgs.emacsPackagesFor": null,
  "pkgs.enableDebugging": "intended to be used like nix-build -E 'with import <nixpkgs> { }; enableDebugging fooPackage'",
  "pkgs.ensureNewerSourcesHook": null,
  "pkgs.extend": "Prefer appendOverlays if used repeatedly.",
  "pkgs.fetchCrate": null,
  "pkgs.fetchDebianPatch": null,
  "pkgs.fetchDockerConfig": null,
  "pkgs.fetchDockerLayer": null,
  "pkgs.fetchFirefoxAddon": null,
  "pkgs.fetchFrom9Front": null,
  "pkgs.fetchFromBitbucket": null,
  "pkgs.fetchFromGitHub": null,
  "pkgs.fetchFromGitLab": null,
  "pkgs.fetchFromGitea": null,
  "pkgs.fetchFromGitiles": null,
  "pkgs.fetchFromRepoOrCz": null,
  "pkgs.fetchFromSavannah": null,
  "pkgs.fetchFromSourcehut": null,
  "pkgs.fetchHex": null,
  "pkgs.fetchMavenArtifact": null,
  "pkgs.fetchNextcloudApp": null,
  "pkgs.fetchNpmDeps": null,
  "pkgs.fetchNuGet": null,
  "pkgs.fetchPypi": null,
  "pkgs.fetchPypiLegacy": null,
  "pkgs.fetchRepoProject": null,
  "pkgs.fetchYarnDeps": null,
  "pkgs.fetchbower": null,
  "pkgs.fetchbzr": null,
  "pkgs.fetchcvs": null,
  "pkgs.fetchdarcs": null,
  "pkgs.fetchdocker": null,
  "pkgs.fetchegg": null,
  "pkgs.fetchfossil": null,
  "pkgs.fetchgit": null,
  "pkgs.fetchgitLocal": null,
  "pkgs.fetchgx": null,
  "pkgs.fetchhg": null,
  "pkgs.fetchipfs": null,
  "pkgs.fetchmtn": null,
  "pkgs.fetchpatch": null,
  "pkgs.fetchpatch2": null,
  "pkgs.fetchpijul": null,
  "pkgs.fetchs3": null,
  "pkgs.fetchsvn": null,
  "pkgs.fetchsvnrevision": null,
  "pkgs.fetchsvnssh": null,
  "pkgs.fetchtorrent": null,
  "pkgs.fetchurl": null,
  "pkgs.fetchzip": null,
  "pkgs.forceSystem": "Added 2018-07-16 preserve, reason: forceSystem should not be used directly in Nixpkgs.",
  "pkgs.gccFun": null,
  "pkgs.generateSplicesForMkScope": "generate 'otherSplices' for 'makeScopeWithSplicing'",
  "pkgs.genericUpdater": null,
  "pkgs.ghc-standalone-archive": null,
  "pkgs.gitUpdater": null,
  "pkgs.gradleGen": null,
  "pkgs.hardenedLinuxPackagesFor": null,
  "pkgs.hiPrio": "\nIncrease the nix-env priority of the package, i.e., this\nversion/variant of the package will be preferred.\n\n# Inputs\n\n`drv`\n\n: 1\\. Function argument\n",
  "pkgs.httpTwoLevelsUpdater": null,
  "pkgs.hunspellWithDicts": null,
  "pkgs.importNpmLock": null,
  "pkgs.impureUseNativeOptimizations": "\nModify a stdenv so that it builds binaries optimized specifically\nfor the machine they are built on.\n\nWARNING: this breaks purity!\n\n\n# Inputs\n\n`stdenv`\n\n: 1\\. Function argument\n",
  "pkgs.invalidateFetcherByDrvHash": "or doc/build-helpers/testers.chapter.md",
  "pkgs.keepDebugInfo": "\nModify a stdenv so that it produces debug builds; that is,\nbinaries have debug info, and compiler optimisations are\ndisabled.\n\n\n# Inputs\n\n`stdenv`\n\n: 1\\. Function argument\n",
  "pkgs.libcCrossChooser": "We can choose:",
  "pkgs.libcIconv": null,
  "pkgs.linkFarm": "\nQuickly create a set of symlinks to derivations.\n\nThis creates a simple derivation with symlinks to all inputs.\n\nentries can be a list of attribute sets like\n\n[ { name = \"name\" ; path = \"/nix/store/...\"; } ]\n\n\nor an attribute set name -> path like:\n\n{ name = \"/nix/store/...\"; other = \"/nix/store/...\"; }\n\n\n# Inputs\n\n`name`\n\n: 1\\. Function argument\n\n`entries`\n\n: 2\\. Function argument\n\n\n# Examples\n:::{.example}\n## `linkFarm` usage example\n\n```nix\n# Symlinks hello and stack paths in store to current $out/hello-test and\n# $out/foobar.\nlinkFarm \"myexample\" [ { name = \"hello-test\"; path = pkgs.hello; } { name = \"foobar\"; path = pkgs.stack; } ]\n\nThis creates a derivation with a directory structure like the following:\n\n/nix/store/qc5728m4sa344mbks99r3q05mymwm4rw-myexample\n|-- foobar -> /nix/store/6lzdpxshx78281vy056lbk553ijsdr44-stack-2.1.3.1\n`-- hello-test -> /nix/store/qy93dp4a3rqyn2mz63fbxjg228hffwyw-hello-2.10\n\n\nSee the note on symlinkJoin for the difference between linkFarm and symlinkJoin.\n```\n\n:::\n",
  "pkgs.linkFarmFromDrvs": "\nEasily create a linkFarm from a set of derivations.\n\nThis calls linkFarm with a list of entries created from the list of input\nderivations.  It turns each input derivation into an attribute set\nlike { name = drv.name ; path = drv }, and passes this to linkFarm.\n\n\n# Inputs\n\n`name`\n\n: 1\\. Function argument\n\n`drvs`\n\n: 2\\. Function argument\n\n\n# Examples\n:::{.example}\n## `linkFarmFromDrvs` usage example\n\n```nix\n# Symlinks the hello, gcc, and ghc derivations in $out\nlinkFarmFromDrvs \"myexample\" [ pkgs.hello pkgs.gcc pkgs.ghc ]\n\nThis creates a derivation with a directory structure like the following:\n\n\n/nix/store/m3s6wkjy9c3wy830201bqsb91nk2yj8c-myexample\n|-- gcc-wrapper-9.2.0 -> /nix/store/fqhjxf9ii4w4gqcsx59fyw2vvj91486a-gcc-wrapper-9.2.0\n|-- ghc-8.6.5 -> /nix/store/gnf3s07bglhbbk4y6m76sbh42siym0s6-ghc-8.6.5\n`-- hello-2.10 -> /nix/store/k0ll91c4npk4lg8lqhx00glg2m735g74-hello-2.10\n```\n\n:::\n",
  "pkgs.linuxConfig": "Derive one of the default .config files",
  "pkgs.linuxManualConfig": null,
  "pkgs.linuxPackagesFor": "\nLinux kernel modules are inherently tied to a specific kernel.  So\nrather than provide specific instances of those packages for a\nspecific kernel, we have a function that builds those packages\nfor a specific kernel.  This function can then be called for\nwhatever kernel you're using.\n\n\n# Inputs\n\n`kernel_`\n\n: 1\\. Function argument\n",
  "pkgs.linuxPackages_custom": null,
  "pkgs.lowPrio": "\nDecrease the nix-env priority of the package, i.e., other\nversions/variants of the package will be preferred.\n\n# Inputs\n\n`drv`\n\n: 1\\. Function argument\n\n",
  "pkgs.makeAutostartItem": null,
  "pkgs.makeDarwinBundle": null,
  "pkgs.makeDesktopItem": null,
  "pkgs.makeFontsCache": null,
  "pkgs.makeFontsConf": null,
  "pkgs.makeHardcodeGsettingsPatch": "\nCreates a patch that replaces every instantiation of GSettings in a C project\nwith a code that loads a GSettings schema from a hardcoded path.\n\nThis is useful so that libraries can find schemas even though Nix lacks\na standard location like /usr/share, where GSettings system could look for schemas.\nThe derivation is is somewhat dependency-heavy so it is best used as part of an update script.\n\nFor each schema id referenced in the source code (e.g. org.gnome.evolution),\na variable name such as `EVOLUTION` must be provided.\nIt will end up in the generated patch as `@EVOLUTION@` placeholder, which should be replaced at build time\nwith a path to the directory containing a `gschemas.compiled` file that includes the schema.\n\nArguments:\n- `src`: source to generate the patch for.\n\n- `schemaIdToVariableMapping`: attrset assigning schema ids to variable names.\n  All used schemas must be listed.\n\n  For example, `{ \"org.gnome.evolution\" = \"EVOLUTION_SCHEMA_PATH\"; }`\n  hardcodes looking for `org.gnome.evolution` into `@EVOLUTION_SCHEMA_PATH@`.\n\n- `patches`: A list of patches to apply before generating the patch.\n\n\n# Examples\n:::{.example}\n\n```nix\npassthru = {\n  hardcodeGsettingsPatch = makeHardcodeGsettingsPatch {\n    inherit (finalAttrs) src;\n    schemaIdToVariableMapping = {\n       ...\n    };\n  };\n\n  updateScript =\n    let\n      updateSource = ...;\n      updatePatch = _experimental-update-script-combinators.copyAttrOutputToFile \"evolution-ews.hardcodeGsettingsPatch\" ./hardcode-gsettings.patch;\n    in\n    _experimental-update-script-combinators.sequence [\n      updateSource\n      updatePatch\n    ];\n  };\n}\n```\n\n:::\n",
  "pkgs.makeImpureTest": null,
  "pkgs.makeInitrd": null,
  "pkgs.makeInitrdNG": null,
  "pkgs.makeLinuxHeaders": null,
  "pkgs.makeModulesClosure": null,
  "pkgs.makeOverridable": "\n`makeOverridable` takes a function from attribute set to attribute set and\ninjects `override` attribute which can be used to override arguments of\nthe function.\n\nPlease refer to  documentation on [`<pkg>.overrideDerivation`](#sec-pkg-overrideDerivation) to learn about `overrideDerivation` and caveats\nrelated to its use.\n\n# Inputs\n\n`f`\n\n: 1\\. Function argument\n\n# Type\n\n```\nmakeOverridable :: (AttrSet -> a) -> AttrSet -> a\n```\n\n# Examples\n:::{.example}\n## `lib.customisation.makeOverridable` usage example\n\n```nix\nnix-repl> x = {a, b}: { result = a + b; }\n\nnix-repl> y = lib.makeOverridable x { a = 1; b = 2; }\n\nnix-repl> y\n{ override = «lambda»; overrideDerivation = «lambda»; result = 3; }\n\nnix-repl> y.override { a = 10; }\n{ override = «lambda»; overrideDerivation = «lambda»; result = 12; }\n```\n\n:::\n",
  "pkgs.makePkgconfigItem": null,
  "pkgs.makeRustPlatform": null,
  "pkgs.makeScopeWithSplicing": null,
  "pkgs.makeScopeWithSplicing' (Prime)": null,
  "pkgs.makeSetupHook": "See https://nixos.org/manual/nixpkgs/unstable/#sec-pkgs.makeSetupHook",
  "pkgs.makeStatic": "Puts all the other ones together",
  "pkgs.makeStaticBinaries": "binaries.",
  "pkgs.makeStaticDarwin": "but more portable than Nix store binaries.",
  "pkgs.makeStaticLibraries": "shared libraries.",
  "pkgs.mkBinaryCache": null,
  "pkgs.mkCoqPackages": "\nThe function `mkCoqPackages` takes as input a derivation for Coq and produces\n* a set of libraries built with that specific Coq. More libraries are known to\n* this function than what is compatible with that version of Coq. Therefore,\n* libraries that are not known to be compatible are removed (filtered out) from\n* the resulting set. For meta-programming purposes (inpecting the derivations\n* rather than building the libraries) this filtering can be disabled by setting\n* a `dontFilter` attribute into the Coq derivation.\n\n\n# Inputs\n\n`coq`\n\n: 1\\. Function argument\n",
  "pkgs.mkKops": null,
  "pkgs.mkNugetDeps": null,
  "pkgs.mkNugetSource": null,
  "pkgs.mkRocqPackages": "\nThe function `mkRocqPackages` takes as input a derivation for Rocq and produces\n* a set of libraries built with that specific Rocq. More libraries are known to\n* this function than what is compatible with that version of Rocq. Therefore,\n* libraries that are not known to be compatible are removed (filtered out) from\n* the resulting set. For meta-programming purposes (inpecting the derivations\n* rather than building the libraries) this filtering can be disabled by setting\n* a `dontFilter` attribute into the Rocq derivation.\n\n\n# Inputs\n\n`rocq-core`\n\n: 1\\. Function argument\n",
  "pkgs.mkRuby": null,
  "pkgs.mkRubyVersion": "The returned set should be immutable",
  "pkgs.mkSaneConfig": null,
  "pkgs.mkShell": null,
  "pkgs.mkShellNoCC": null,
  "pkgs.mkStdenvNoLibs": null,
  "pkgs.mkTerraform": "Constructor for other terraform versions",
  "pkgs.mkYarnModules": null,
  "pkgs.mkYarnPackage": null,
  "pkgs.mpdWithFeatures": null,
  "pkgs.myEnvFun": null,
  "pkgs.newScope": null,
  "pkgs.nix-update-script": null,
  "pkgs.nixos": "\nEvaluate a NixOS configuration using this evaluation of Nixpkgs.\n\nWith this function you can write, for example, a package that\ndepends on a custom virtual machine image.\n\nParameter:  A module, path or list of those that represent the\n            configuration of the NixOS system to be constructed.\n\nResult: An attribute set containing packages produced by this\n        evaluation of NixOS, such as toplevel, kernel and\n        initialRamdisk.\n        The result can be extended in the modules by defining\n        extra attributes in system.build.\n        Alternatively, you may use the result's config and\n        options attributes to query any option.\n\n\n# Inputs\n\n`configuration`\n\n: 1\\. Function argument\n\n\n# Examples\n:::{.example}\n## `nixos` usage example\n\n```nix\nlet\n      myOS = pkgs.nixos ({ lib, pkgs, config, ... }: {\n\n        config.services.nginx = {\n          enable = true;\n          # ...\n        };\n\n        # Use config.system.build to exports relevant parts of a\n        # configuration. The runner attribute should not be\n        # considered a fully general replacement for systemd\n        # functionality.\n        config.system.build.run-nginx = config.systemd.services.nginx.runner;\n      });\n    in\n      myOS.run-nginx\n\nUnlike in plain NixOS, the nixpkgs.config and\nnixpkgs.system options will be ignored by default. Instead,\nnixpkgs.pkgs will have the default value of pkgs as it was\nconstructed right after invoking the nixpkgs function (e.g. the\nvalue of import <nixpkgs> { overlays = [./my-overlay.nix]; }\nbut not the value of (import <nixpkgs> {} // { extra = ...; }).\n\nIf you do want to use the config.nixpkgs options, you are\nprobably better off by calling nixos/lib/eval-config.nix\ndirectly, even though it is possible to set config.nixpkgs.pkgs.\n\nFor more information about writing NixOS modules, see\nhttps://nixos.org/nixos/manual/index.html#sec-writing-modules\n\nNote that you will need to have called Nixpkgs with the system\nparameter set to the right value for your deployment target.\n```\n\n:::\n",
  "pkgs.nixosOptionsDoc": null,
  "pkgs.nixosTest": null,
  "pkgs.nuspellWithDicts": null,
  "pkgs.onlyBin": "\nProduce a derivation that links to the target derivation's `/bin`,\nand *only* `/bin`.\n\nThis is useful when your favourite package doesn't have a separate\nbin output and other contents of the package's output (e.g. setup\nhooks) cause trouble when used in your environment.\n\n\n# Inputs\n\n`drv`\n\n: 1\\. Function argument\n",
  "pkgs.overrideCC": "Override the compiler in stdenv for specific packages.",
  "pkgs.overrideInStdenv": "for other dependencies.",
  "pkgs.overrideLibcxx": "because older compilers may not be able to parse the headers from the default stdenv’s libc++.",
  "pkgs.overrideSDK": null,
  "pkgs.overrideSetup": "};",
  "pkgs.pkgsModule": "\nA NixOS/home-manager/arion/... module that sets the `pkgs` module argument.\n",
  "pkgs.portableService": "\nCreate a systemd portable service image\nhttps://systemd.io/PORTABLE_SERVICES/\n\n\n# Examples\n:::{.example}\n\n```nix\npkgs.portableService {\n  pname = \"demo\";\n  version = \"1.0\";\n  units = [ demo-service demo-socket ];\n}\n```\n\n:::\n",
  "pkgs.prefer-remote-fetch": null,
  "pkgs.propagateBuildInputs": "\nModify a stdenv so that all buildInputs are implicitly propagated to\nconsuming derivations\n\n\n# Inputs\n\n`stdenv`\n\n: 1\\. Function argument\n",
  "pkgs.puredata-with-plugins": null,
  "pkgs.python-setup-hook": null,
  "pkgs.qtEnv": null,
  "pkgs.quake3wrapper": null,
  "pkgs.rebar3WithPlugins": null,
  "pkgs.recurseIntoAttrs": "\nMake various Nix tools consider the contents of the resulting\nattribute set when looking for what to build, find, etc.\n\nThis function only affects a single attribute set; it does not\napply itself recursively for nested attribute sets.\n\n\n# Inputs\n\n`attrs`\n\n: An attribute set to scan for derivations.\n\n# Type\n\n```\nrecurseIntoAttrs :: AttrSet -> AttrSet\n```\n\n# Examples\n:::{.example}\n## `lib.attrsets.recurseIntoAttrs` usage example\n\n```nix\n{ pkgs ? import <nixpkgs> {} }:\n{\n  myTools = pkgs.lib.recurseIntoAttrs {\n    inherit (pkgs) hello figlet;\n  };\n}\n```\n\n:::\n",
  "pkgs.referencesByPopularity": null,
  "pkgs.replaceDependencies": null,
  "pkgs.replaceDependency": null,
  "pkgs.replaceDirectDependencies": null,
  "pkgs.replaceVars": "\n`replaceVars` is a wrapper around the [bash function `substitute`](https://nixos.org/manual/nixpkgs/stable/#fun-substitute)\nin the stdenv. It allows for terse replacement of names in the specified path, while checking\nfor common mistakes such as naming a replacement that does nothing or forgetting a variable which\nneeds to be replaced.\n\nAs with the [`--subst-var-by`](https://nixos.org/manual/nixpkgs/stable/#fun-substitute-subst-var-by)\nflag, names are encoded as `@name@` in the provided file at the provided path.\n\nAny unmatched variable names in the file at the provided path will cause a build failure.\n\nBy default, any remaining text that matches `@[A-Za-z_][0-9A-Za-z_'-]@` in the output after replacement\nhas occurred will cause a build failure. Variables can be excluded from this check by passing \"null\" for them.\n\n# Inputs\n\n`src` ([Store Path](https://nixos.org/manual/nix/latest/store/store-path.html#store-path) String)\n: The file in which to replace variables.\n\n`replacements` (AttrsOf String)\n: Each entry in this set corresponds to a `--subst-var-by` entry in [`substitute`](https://nixos.org/manual/nixpkgs/stable/#fun-substitute) or\n  null to keep it unchanged.\n\n# Example\n\n```nix\n{ replaceVars }:\n\nreplaceVars ./greeting.txt { world = \"hello\"; }\n```\n\nSee `../../test/replace-vars/default.nix` for tests of this function.\n",
  "pkgs.replaceVarsWith": "\n`replaceVarsWith` is a wrapper around the [bash function `substitute`](https://nixos.org/manual/nixpkgs/stable/#fun-substitute)\nin the stdenv. It allows for terse replacement of names in the specified path, while checking\nfor common mistakes such as naming a replacement that does nothing or forgetting a variable which\nneeds to be replaced.\n\nAs with the [`--subst-var-by`](https://nixos.org/manual/nixpkgs/stable/#fun-substitute-subst-var-by)\nflag, names are encoded as `@name@` in the provided file at the provided path.\n\nAny unmatched variable names in the file at the provided path will cause a build failure.\n\nBy default, any remaining text that matches `@[A-Za-z_][0-9A-Za-z_'-]@` in the output after replacement\nhas occurred will cause a build failure. Variables can be excluded from this check by passing \"null\" for them.\n\n# Inputs\n\n`src` ([Store Path](https://nixos.org/manual/nix/latest/store/store-path.html#store-path) String)\n: The file in which to replace variables.\n\n`replacements` (AttrsOf String)\n: Each entry in this set corresponds to a `--subst-var-by` entry in [`substitute`](https://nixos.org/manual/nixpkgs/stable/#fun-substitute) or\n  null to keep it unchanged.\n\n`dir` (String)\n: Sub directory in $out to store the result in. Commonly set to \"bin\".\n\n`isExecutable` (Boolean)\n: Whether to mark the output file as executable.\n\nMost arguments supported by mkDerivation are also supported, with some exceptions for which\nan error will be thrown.\n\n# Example\n\n```nix\n{ replaceVarsWith }:\n\nreplaceVarsWith {\n  src = ./my-setup-hook.sh;\n  replacements = { world = \"hello\"; };\n  dir = \"bin\";\n  isExecutable = true;\n}\n```\n\nSee `../../test/replace-vars/default.nix` for tests of this function. Also see `replaceVars` for a short\nversion with src and replacements only.\n",
  "pkgs.requireFile": "See https://nixos.org/manual/nixpkgs/unstable/#requirefile",
  "pkgs.resolveMirrorURLs": null,
  "pkgs.runCommand": "See https://nixos.org/manual/nixpkgs/unstable/#trivial-builder-runCommand",
  "pkgs.runCommandCC": "See https://nixos.org/manual/nixpkgs/unstable/#trivial-builder-runCommandCC",
  "pkgs.runCommandLocal": "See https://nixos.org/manual/nixpkgs/unstable/#trivial-builder-runCommandLocal",
  "pkgs.runCommandNoCC": "See https://nixos.org/manual/nixpkgs/unstable/#trivial-builder-runCommand",
  "pkgs.runCommandNoCCLocal": "See https://nixos.org/manual/nixpkgs/unstable/#trivial-builder-runCommandLocal",
  "pkgs.runCommandWith": null,
  "pkgs.setupSystemdUnits": null,
  "pkgs.sourceFromHead": null,
  "pkgs.splicePackages": null,
  "pkgs.srcOnly": "\nA utility builder to get the source code of the input derivation, with any patches applied.\n\n# Examples\n\n```nix\nsrcOnly pkgs.hello\n=> «derivation /nix/store/gyfk2jg9079ga5g5gfms5i4h0k9jhf0f-hello-2.12.1-source.drv»\n\nsrcOnly {\n  inherit (pkgs.hello) name version src stdenv;\n}\n=> «derivation /nix/store/vf9hdhz38z7rfhzhrk0vi70h755fnsw7-hello-2.12.1-source.drv»\n```\n\n# Type\n\n```\nsrcOnly :: (Derivation | AttrSet) -> Derivation\n```\n\n# Input\n\n`attrs`\n\n: One of the following:\n\n  - A derivation with (at minimum) an unpackPhase and a patchPhase.\n  - A set of attributes that would be passed to a `stdenv.mkDerivation` or `stdenvNoCC.mkDerivation` call.\n\n# Output\n\nA derivation that runs a derivation's `unpackPhase` and `patchPhase`, and then copies the result to the output path.\n",
  "pkgs.substitute": "\nThis is a wrapper around `substitute` in the stdenv.\n\nAttribute arguments:\n- `name` (optional): The name of the resulting derivation\n- `src`: The path to the file to substitute\n- `substitutions`: The list of substitution arguments to pass\n  See https://nixos.org/manual/nixpkgs/stable/#fun-substitute\n- `replacements`: Deprecated version of `substitutions`\n  that doesn't support spaces in arguments.\n\n\n# Examples\n:::{.example}\n\n```nix\n```nix\n{ substitute }:\nsubstitute {\n  src = ./greeting.txt;\n  substitutions = [\n    \"--replace\"\n    \"world\"\n    \"paul\"\n  ];\n}\n```\n\nSee ../../test/substitute for tests\n```\n\n:::\n",
  "pkgs.substituteAll": null,
  "pkgs.substituteAllFiles": null,
  "pkgs.symlinkJoin": "\nTODO: Deduplicate this documentation.\nMore docs in doc/build-helpers/trivial-build-helpers.chapter.md\nSee https://nixos.org/manual/nixpkgs/unstable/#trivial-builder-symlinkJoin\n\nCreate a forest of symlinks to the files in `paths`.\n\nThis creates a single derivation that replicates the directory structure\nof all the input paths.\n\nBEWARE: it may not \"work right\" when the passed paths contain symlinks to directories.\n\n\n# Examples\n:::{.example}\n## `symlinkJoin` usage example\n\n```nix\n# adds symlinks of hello to current build.\nsymlinkJoin { name = \"myhello\"; paths = [ pkgs.hello ]; }\n\n\n\n\n# adds symlinks of hello and stack to current build and prints \"links added\"\nsymlinkJoin { name = \"myexample\"; paths = [ pkgs.hello pkgs.stack ]; postBuild = \"echo links added\"; }\n\n\nThis creates a derivation with a directory structure like the following:\n\n\n/nix/store/sglsr5g079a5235hy29da3mq3hv8sjmm-myexample\n|-- bin\n|   |-- hello -> /nix/store/qy93dp4a3rqyn2mz63fbxjg228hffwyw-hello-2.10/bin/hello\n|   `-- stack -> /nix/store/6lzdpxshx78281vy056lbk553ijsdr44-stack-2.1.3.1/bin/stack\n`-- share\n    |-- bash-completion\n    |   `-- completions\n    |       `-- stack -> /nix/store/6lzdpxshx78281vy056lbk553ijsdr44-stack-2.1.3.1/share/bash-completion/completions/stack\n    |-- fish\n    |   `-- vendor_completions.d\n    |       `-- stack.fish -> /nix/store/6lzdpxshx78281vy056lbk553ijsdr44-stack-2.1.3.1/share/fish/vendor_completions.d/stack.fish\n...\n\n\nsymlinkJoin and linkFarm are similar functions, but they output\nderivations with different structure.\n\nsymlinkJoin is used to create a derivation with a familiar directory\nstructure (top-level bin/, share/, etc), but with all actual files being symlinks to\nthe files in the input derivations.\n\nsymlinkJoin is used many places in nixpkgs to create a single derivation\nthat appears to contain binaries, libraries, documentation, etc from\nmultiple input derivations.\n\nlinkFarm is instead used to create a simple derivation with symlinks to\nother derivations.  A derivation created with linkFarm is often used in CI\nas a easy way to build multiple derivations at once.\n```\n\n:::\n",
  "pkgs.testVersion": "or doc/build-helpers/testers.chapter.md",
  "pkgs.themes": null,
  "pkgs.traceDrvLicenses": "\nUse the trace output to report all processed derivations with their\nlicense name.\n\n\n# Inputs\n\n`stdenv`\n\n: 1\\. Function argument\n",
  "pkgs.unstableGitUpdater": null,
  "pkgs.useGoldLinker": "\nModify a stdenv so that it uses the Gold linker.\n\n\n# Inputs\n\n`stdenv`\n\n: 1\\. Function argument\n",
  "pkgs.useLibsFrom": "\nCopy the libstdc++ from the model stdenv to the target stdenv.\n*\n* TODO(@connorbaker):\n* This interface provides behavior which should be revisited prior to the\n* release of 24.05. For a more detailed explanation and discussion, see\n* https://github.com/NixOS/nixpkgs/issues/283517.\n\n\n# Inputs\n\n`modelStdenv`\n\n: 1\\. Function argument\n\n`targetStdenv`\n\n: 2\\. Function argument\n",
  "pkgs.useMoldLinker": null,
  "pkgs.vscode-fhsWithPackages": null,
  "pkgs.vscodium-fhsWithPackages": null,
  "pkgs.winePackagesFor": null,
  "pkgs.withCFlags": "\nModify a stdenv so that it builds binaries with the specified list of\ncompilerFlags appended and passed to the compiler.\n\nThis example would recompile every derivation on the system with\n-funroll-loops and -O3 passed to each gcc invocation.\n\n\n# Inputs\n\n`compilerFlags`\n\n: 1\\. Function argument\n\n`stdenv`\n\n: 2\\. Function argument\n\n\n# Examples\n:::{.example}\n## `withCFlags` usage example\n\n```nix\nnixpkgs.overlays = [\n  (self: super: {\n    stdenv = super.withCFlags [ \"-funroll-loops\" \"-O3\" ] super.stdenv;\n  })\n];\n```\n\n:::\n",
  "pkgs.withDefaultHardeningFlags": null,
  "pkgs.wrapBintoolsWith": null,
  "pkgs.wrapCC": null,
  "pkgs.wrapCCMulti": null,
  "pkgs.wrapCCWith": null,
  "pkgs.wrapClangMulti": null,
  "pkgs.wrapFirefox": null,
  "pkgs.wrapFish": null,
  "pkgs.wrapGradle": null,
  "pkgs.wrapHelm": null,
  "pkgs.wrapKakoune": null,
  "pkgs.wrapLisp": null,
  "pkgs.wrapLispi686Linux": null,
  "pkgs.wrapNeovim": null,
  "pkgs.wrapNeovimUnstable": null,
  "pkgs.wrapNonDeterministicGcc": null,
  "pkgs.wrapOBS": null,
  "pkgs.wrapQemuBinfmtP": null,
  "pkgs.wrapRetroArch": null,
  "pkgs.wrapRustc": null,
  "pkgs.wrapRustcWith": null,
  "pkgs.wrapThunderbird": null,
  "pkgs.wrapWatcom": null,
  "pkgs.wrapWeechat": null,
  "pkgs.writeCBin": "TODO: add to writers? pkgs/build-support/writers",
  "pkgs.writeClosure": "See https://nixos.org/manual/nixpkgs/unstable/#trivial-builder-writeClosure",
  "pkgs.writeCueValidator": null,
  "pkgs.writeDirectReferencesToFile": "See https://nixos.org/manual/nixpkgs/unstable/#trivial-builder-writeDirectReferencesToFile",
  "pkgs.writeScript": "or https://nixos.org/manual/nixpkgs/unstable/#trivial-builder-text-writing",
  "pkgs.writeScriptBin": "or https://nixos.org/manual/nixpkgs/unstable/#trivial-builder-text-writing",
  "pkgs.writeShellApplication": "or https://nixos.org/manual/nixpkgs/unstable/#trivial-builder-writeShellApplication",
  "pkgs.writeShellScript": "or https://nixos.org/manual/nixpkgs/unstable/#trivial-builder-text-writing",
  "pkgs.writeShellScriptBin": "or https://nixos.org/manual/nixpkgs/unstable/#trivial-builder-text-writing",
  "pkgs.writeStringReferencesToFile": "\nExtract a string's references to derivations and paths (its\ncontext) and write them to a text file, removing the input string\nitself from the dependency graph. This is useful when you want to\nmake a derivation depend on the string's references, but not its\ncontents (to avoid unnecessary rebuilds, for example).\n\nNote that this only works as intended on Nix >= 2.3.\n\n\n# Inputs\n\n`string`\n\n: 1\\. Function argument\n",
  "pkgs.writeText": "or https://nixos.org/manual/nixpkgs/unstable/#trivial-builder-text-writing",
  "pkgs.writeTextDir": "or https://nixos.org/manual/nixpkgs/unstable/#trivial-builder-text-writing",
  "pkgs.writeTextFile": "See https://nixos.org/manual/nixpkgs/unstable/#trivial-builder-writeTextFile",
  "pkgs.zabbixFor": null,
  "pkgs.pythonPackages.buildPythonApplication": null,
  "pkgs.pythonPackages.buildPythonPackage": null,
  "pkgs.pythonPackages.callPackage": null,
  "pkgs.pythonPackages.disabled": null,
  "pkgs.pythonPackages.disabledIf": null,
  "pkgs.pythonPackages.fetchPypi": null,
  "pkgs.pythonPackages.hasPythonModule": "Check whether a derivation provides a Python module.",
  "pkgs.pythonPackages.makePythonHook": null,
  "pkgs.pythonPackages.makePythonPath": "providing Python modules.",
  "pkgs.pythonPackages.mkPythonEditablePackage": null,
  "pkgs.pythonPackages.mkPythonMetaPackage": null,
  "pkgs.pythonPackages.newScope": null,
  "pkgs.pythonPackages.override": null,
  "pkgs.pythonPackages.overrideDerivation": null,
  "pkgs.pythonPackages.overrideScope": "overridden.",
  "pkgs.pythonPackages.packages": null,
  "pkgs.pythonPackages.pythonAtLeast": null,
  "pkgs.pythonPackages.pythonOlder": null,
  "pkgs.pythonPackages.requiredPythonModules": "Get list of required Python modules given a list of derivations.",
  "pkgs.pythonPackages.toPythonApplication": "Convert a Python library to an application.",
  "pkgs.pythonPackages.toPythonModule": "Convert derivation to a Python module.",
  "pkgs.releaseTools.aggregate": null,
  "pkgs.releaseTools.binaryTarball": "compatibility",
  "pkgs.releaseTools.channel": "\nCreate a channel job which success depends on the success of all of\nits contituents. Channel jobs are a special type of jobs that are\nlisted in the channel tab of Hydra and that can be suscribed.\nA tarball of the src attribute is distributed via the channel.\n\n- constituents: a list of derivations on which the channel success depends.\n- name: the channel name that will be used in the hydra interface.\n- src: should point to the root folder of the nix-expressions used by the\n       channel, typically a folder containing a `default.nix`.\n\n  channel {\n    constituents = [ foo bar baz ];\n    name = \"my-channel\";\n    src = ./.;\n  };\n",
  "pkgs.releaseTools.clangAnalysis": null,
  "pkgs.releaseTools.coverageAnalysis": null,
  "pkgs.releaseTools.coverityAnalysis": null,
  "pkgs.releaseTools.debBuild": null,
  "pkgs.releaseTools.makeSourceTarball": null,
  "pkgs.releaseTools.mvnBuild": null,
  "pkgs.releaseTools.nixBuild": null,
  "pkgs.releaseTools.override": null,
  "pkgs.releaseTools.overrideDerivation": null,
  "pkgs.releaseTools.rpmBuild": null,
  "pkgs.releaseTools.sourceTarball": null,
  "pkgs.rustPackages.callPackage": null,
  "pkgs.rustPackages.newScope": null,
  "pkgs.rustPackages.overrideScope": null,
  "pkgs.rustPackages.packages": null,
  "pkgs.rustPackages.buildRustPackages.callPackage": null,
  "pkgs.rustPackages.buildRustPackages.newScope": null,
  "pkgs.rustPackages.buildRustPackages.overrideScope": null,
  "pkgs.rustPackages.buildRustPackages.packages": null,
  "pkgs.rustPackages.rustPlatform.buildRustPackage": null,
  "pkgs.rustPackages.rustPlatform.callPackage": null,
  "pkgs.rustPackages.rustPlatform.fetchCargoTarball": null,
  "pkgs.rustPackages.rustPlatform.fetchCargoVendor": null,
  "pkgs.rustPackages.rustPlatform.importCargoLock": null,
  "pkgs.rustPackages.rustPlatform.newScope": null,
  "pkgs.rustPackages.rustPlatform.overrideScope": "overridden.",
  "pkgs.rustPackages.rustPlatform.packages": null,
  "pkgs.rustPackages.buildRustPackages.rustPlatform.buildRustPackage": null,
  "pkgs.rustPackages.buildRustPackages.rustPlatform.callPackage": null,
  "pkgs.rustPackages.buildRustPackages.rustPlatform.fetchCargoTarball": null,
  "pkgs.rustPackages.buildRustPackages.rustPlatform.fetchCargoVendor": null,
  "pkgs.rustPackages.buildRustPackages.rustPlatform.importCargoLock": null,
  "pkgs.rustPackages.buildRustPackages.rustPlatform.newScope": null,
  "pkgs.rustPackages.buildRustPackages.rustPlatform.overrideScope": "overridden.",
  "pkgs.rustPackages.buildRustPackages.rustPlatform.packages": null,
  "pkgs.rustPackages.rustPlatform.buildRustPackage.override": null,
  "pkgs.rustPackages.rustPlatform.fetchCargoTarball.override": null,
  "pkgs.rustPackages.rustPlatform.fetchCargoVendor.override": null,
  "pkgs.rustPackages.rustPlatform.importCargoLock.override": null,
  "pkgs.rustPackages.buildRustPackages.rustPlatform.buildRustPackage.override": null,
  "pkgs.rustPackages.buildRustPackages.rustPlatform.fetchCargoTarball.override": null,
  "pkgs.rustPackages.buildRustPackages.rustPlatform.fetchCargoVendor.override": null,
  "pkgs.rustPackages.buildRustPackages.rustPlatform.importCargoLock.override": null,
  "pkgs.stdenv.fetchurlBoot": null,
  "pkgs.stdenv.mkDerivation": "\nThis function creates a derivation, and returns it in the form of a [package attribute set](https://nix.dev/manual/nix/latest/glossary#package-attribute-set)\nthat refers to the derivation's outputs.\n\n`mkDerivation` takes many argument attributes, most of which affect the derivation environment,\nbut [`meta`](#chap-meta) and [`passthru`](#var-stdenv-passthru) only directly affect package attributes.\n\nThe `mkDerivation` argument attributes can be made to refer to one another by passing a function to `mkDerivation`.\nSee [Fixed-point argument of `mkDerivation`](#mkderivation-recursive-attributes).\n\nReference documentation see: https://nixos.org/manual/nixpkgs/stable/#sec-using-stdenv\n\n:::{.note}\nThis is used as the fundamental building block of most other functions in Nixpkgs for creating derivations.\n\nMost arguments are also passed through to the underlying call of [`builtins.derivation`](https://nixos.org/manual/nix/stable/language/derivations).\n:::\n",
  "pkgs.stdenv.override": null,
  "pkgs.stdenv.overrideDerivation": null,
  "pkgs.stdenv.overrides": null,
  "pkgs.testers.hasPkgConfigModule": null,
  "pkgs.testers.hasPkgConfigModules": null,
  "pkgs.testers.invalidateFetcherByDrvHash": "or doc/build-helpers/testers.chapter.md",
  "pkgs.testers.lycheeLinkCheck": "or doc/build-helpers/testers.chapter.md",
  "pkgs.testers.nixosTest": null,
  "pkgs.testers.override": null,
  "pkgs.testers.overrideDerivation": null,
  "pkgs.testers.runCommand": null,
  "pkgs.testers.runNixOSTest": null,
  "pkgs.testers.shellcheck": null,
  "pkgs.testers.testBuildFailure": "or doc/build-helpers/testers.chapter.md",
  "pkgs.testers.testEqualContents": "or doc/build-helpers/testers.chapter.md",
  "pkgs.testers.testEqualDerivation": null,
  "pkgs.testers.testMetaPkgConfig": null,
  "pkgs.testers.testVersion": "or doc/build-helpers/testers.chapter.md",
  "pkgs.testers.hasPkgConfigModules.override": null,
  "pkgs.testers.shellcheck.override": null,
  "pkgs.testers.testEqualDerivation.override": null,
  "pkgs.testers.testMetaPkgConfig.override": null,
  "pkgs.vmTools.buildRPM": "\nBuild RPM packages from the tarball `src' in the Linux\ndistribution installed in the filesystem `diskImage'.  The\ntarball must contain an RPM specfile.\n\n\n# Inputs\n\n`attrs`\n\n: 1\\. Function argument\n",
  "pkgs.vmTools.createEmptyImage": "\nA bash script fragment that produces a disk image at `destination`.\n",
  "pkgs.vmTools.debClosureGenerator": "\nLike `rpmClosureGenerator', but now for Debian/Ubuntu releases\n(i.e. generate a closure from a Packages.bz2 file).\n",
  "pkgs.vmTools.extractFs": null,
  "pkgs.vmTools.extractMTDfs": null,
  "pkgs.vmTools.fillDiskWithDebs": "\nCreate a filesystem image of the specified size and fill it with\na set of Debian packages.  `debs' must be a list of list of\n.deb files, namely, the Debian packages grouped together into\nstrongly connected components.  See deb/deb-closure.nix.\n",
  "pkgs.vmTools.fillDiskWithRPMs": "\nCreate a filesystem image of the specified size and fill it with\na set of RPM packages.\n",
  "pkgs.vmTools.makeImageFromDebDist": "\nHelper function that combines debClosureGenerator and\nfillDiskWithDebs to generate a disk image from a set of package\nnames.\n",
  "pkgs.vmTools.makeImageFromRPMDist": "\nHelper function that combines rpmClosureGenerator and\nfillDiskWithRPMs to generate a disk image from a set of package\nnames.\n",
  "pkgs.vmTools.makeImageTestScript": "\nGenerate a script that can be used to run an interactive session\nin the given image.\n\n\n# Inputs\n\n`image`\n\n: 1\\. Function argument\n",
  "pkgs.vmTools.override": null,
  "pkgs.vmTools.overrideDerivation": null,
  "pkgs.vmTools.rpmClosureGenerator": "\nGenerate a Nix expression containing fetchurl calls for the\nclosure of a set of top-level RPM packages from the\n`primary.xml.gz' file of a Fedora or openSUSE distribution.\n",
  "pkgs.vmTools.runInLinuxImage": "\nLike runInLinuxVM, but run the build not using the stdenv from\nthe Nix store, but using the tools provided by /bin, /usr/bin\netc. from the specified filesystem image, which typically is a\nfilesystem containing a non-NixOS Linux distribution.\n\n\n# Inputs\n\n`drv`\n\n: 1\\. Function argument\n",
  "pkgs.vmTools.runInLinuxVM": "\nRun a derivation in a Linux virtual machine (using Qemu/KVM).  By\ndefault, there is no disk image; the root filesystem is a tmpfs,\nand the nix store is shared with the host (via the 9P protocol).\nThus, any pure Nix derivation should run unmodified, e.g. the\ncall\n\n  runInLinuxVM patchelf\n\nwill build the derivation `patchelf' inside a VM.  The attribute\n`preVM' can optionally contain a shell command to be evaluated\n*before* the VM is started (i.e., on the host).  The attribute\n`memSize' specifies the memory size of the VM in megabytes,\ndefaulting to 512.  The attribute `diskImage' can optionally\nspecify a file system image to be attached to /dev/sda.  (Note\nthat currently we expect the image to contain a filesystem, not a\nfull disk image with a partition table etc.)\n\nIf the build fails and Nix is run with the `-K' option, a script\n`run-vm' will be left behind in the temporary build directory\nthat allows you to boot into the VM and debug it interactively.\n\n\n# Inputs\n\n`drv`\n\n: 1\\. Function argument\n",
  "pkgs.vmTools.vmRunCommand": null,
  "pkgs.vmTools.diskImageExtraFuns.centos6i386": null,
  "pkgs.vmTools.diskImageExtraFuns.centos6x86_64": null,
  "pkgs.vmTools.diskImageExtraFuns.centos7x86_64": null,
  "pkgs.vmTools.diskImageExtraFuns.debian10i386": null,
  "pkgs.vmTools.diskImageExtraFuns.debian10x86_64": null,
  "pkgs.vmTools.diskImageExtraFuns.debian11i386": null,
  "pkgs.vmTools.diskImageExtraFuns.debian11x86_64": null,
  "pkgs.vmTools.diskImageExtraFuns.debian12i386": null,
  "pkgs.vmTools.diskImageExtraFuns.debian12x86_64": null,
  "pkgs.vmTools.diskImageExtraFuns.fedora26x86_64": null,
  "pkgs.vmTools.diskImageExtraFuns.fedora27x86_64": null,
  "pkgs.vmTools.diskImageExtraFuns.ubuntu1404i386": null,
  "pkgs.vmTools.diskImageExtraFuns.ubuntu1404x86_64": null,
  "pkgs.vmTools.diskImageExtraFuns.ubuntu1604i386": null,
  "pkgs.vmTools.diskImageExtraFuns.ubuntu1604x86_64": null,
  "pkgs.vmTools.diskImageExtraFuns.ubuntu1804i386": null,
  "pkgs.vmTools.diskImageExtraFuns.ubuntu1804x86_64": null,
  "pkgs.vmTools.diskImageExtraFuns.ubuntu2004i386": null,
  "pkgs.vmTools.diskImageExtraFuns.ubuntu2004x86_64": null,
  "pkgs.vmTools.diskImageExtraFuns.ubuntu2204i386": null,
  "pkgs.vmTools.diskImageExtraFuns.ubuntu2204x86_64": null,
  "pkgs.vmTools.diskImageFuns.centos6i386": null,
  "pkgs.vmTools.diskImageFuns.centos6x86_64": null,
  "pkgs.vmTools.diskImageFuns.centos7x86_64": null,
  "pkgs.vmTools.diskImageFuns.debian10i386": null,
  "pkgs.vmTools.diskImageFuns.debian10x86_64": null,
  "pkgs.vmTools.diskImageFuns.debian11i386": null,
  "pkgs.vmTools.diskImageFuns.debian11x86_64": null,
  "pkgs.vmTools.diskImageFuns.debian12i386": null,
  "pkgs.vmTools.diskImageFuns.debian12x86_64": null,
  "pkgs.vmTools.diskImageFuns.fedora26x86_64": null,
  "pkgs.vmTools.diskImageFuns.fedora27x86_64": null,
  "pkgs.vmTools.diskImageFuns.ubuntu1404i386": null,
  "pkgs.vmTools.diskImageFuns.ubuntu1404x86_64": null,
  "pkgs.vmTools.diskImageFuns.ubuntu1604i386": null,
  "pkgs.vmTools.diskImageFuns.ubuntu1604x86_64": null,
  "pkgs.vmTools.diskImageFuns.ubuntu1804i386": null,
  "pkgs.vmTools.diskImageFuns.ubuntu1804x86_64": null,
  "pkgs.vmTools.diskImageFuns.ubuntu2004i386": null,
  "pkgs.vmTools.diskImageFuns.ubuntu2004x86_64": null,
  "pkgs.vmTools.diskImageFuns.ubuntu2204i386": null,
  "pkgs.vmTools.diskImageFuns.ubuntu2204x86_64": null,
  "pkgs.vmTools.qemu-common.qemuBinary": null,
  "pkgs.vmTools.qemu-common.qemuNICFlags": null,
  "pkgs.vmTools.qemu-common.qemuNicMac": null,
  "pkgs.writers.makeBinWriter": "\n`makeBinWriter` returns a derivation which compiles the given script into an executable format.\n\n:::{.note}\nThis function is the base implementation for other compile language `writers`, such as `writeHaskell` and `writeRust`.\n:::\n\n# Inputs\n\nconfig (AttrSet)\n: `compileScript` (String)\n  : The script that compiles the given content into an executable.\n\n: `strip` (Boolean, Default: true)\n  : Whether to [strip](https://nixos.org/manual/nixpkgs/stable/#ssec-fixup-phase) the executable or not.\n\n: `makeWrapperArgs` (Optional, [ String ], Default: [])\n  : Arguments forwarded to (`makeWrapper`)[#fun-makeWrapper]\n\n`nameOrPath` (String)\n: The name of the script or the path to the script.\n\n  When a `string` starting with \"/\" is passed, the script will be created at the specified path in $out.\n  For example, `\"/bin/hello\"` will create a script at `$out/bin/hello`.\n\n  Any other `string` is interpreted as a filename.\n  It must be a [POSIX filename](https://en.wikipedia.org/wiki/Filename) starting with a letter, digit, dot, or underscore.\n  Spaces or special characters are not allowed.\n\n# Examples\n:::{.example}\n## `pkgs.writers.makeBinWriter` example\n\n```c\n// main.c\n#include <stdio.h>\n\nint main()\n{\n    printf(\"Hello, World!\\n\");\n    return 0;\n}\n```\n\n```nix-repl\n:b makeBinWriter { compileScript = \"${pkgs.gcc}/bin/gcc -o $out $contentPath\"; } \"hello\" ./main.c\nout -> /nix/store/f6crc8mwj3lvcxqclw7n09cm8nb6kxbh-hello\n```\n\nThe above example creates an executable named `hello` that outputs `Hello, World!` when executed.\n\n```sh\n> /nix/store/f6crc8mwj3lvcxqclw7n09cm8nb6kxbh-hello\nHello, World!\n```\n:::\n",
  "pkgs.writers.makeDataWriter": null,
  "pkgs.writers.makeFSharpWriter": null,
  "pkgs.writers.makeLuaWriter": "\nmakeLuaWriter takes lua and compatible luaPackages and produces lua script writer,\nwhich validates the script with luacheck at build time. If any libraries are specified,\nlua.withPackages is used as interpreter, otherwise the \"bare\" lua is used.\n",
  "pkgs.writers.makePythonWriter": "\nmakePythonWriter takes python and compatible pythonPackages and produces python script writer,\nwhich validates the script with flake8 at build time. If any libraries are specified,\npython.withPackages is used as interpreter, otherwise the \"bare\" python is used.\n\n# Inputs\n\n`python`\n\n: 1\\. Function argument\n\n`pythonPackages`\n\n: 2\\. Function argument\n\n`buildPythonPackages`\n\n: 3\\. Function argument\n\n`name`\n\n: 4\\. Function argument\n\n`attrs`\n\n: 5\\. Function argument\n",
  "pkgs.writers.makeRubyWriter": "\nmakeRubyWriter takes ruby and compatible rubyPackages and produces ruby script writer,\nIf any libraries are specified, ruby.withPackages is used as interpreter, otherwise the \"bare\" ruby is used.\n",
  "pkgs.writers.makeScriptWriter": "\n`makeScriptWriter` returns a derivation which creates an executable script.\n\n# Inputs\n\nconfig (AttrSet)\n: `interpreter` (String)\n  : the [interpreter](https://en.wikipedia.org/wiki/Shebang_(Unix)) to use for the script.\n: `check` (String)\n  : A command to check the script. For example, this could be a linting check.\n: `makeWrapperArgs` (Optional, [ String ], Default: [])\n  : Arguments forwarded to (`makeWrapper`)[#fun-makeWrapper].\n\n`nameOrPath` (String)\n: The name of the script or the path to the script.\n\n  When a `string` starting with \"/\" is passed, the script will be created at the specified path in $out.\n  I.e. `\"/bin/hello\"` will create a script at `$out/bin/hello`.\n\n  Any other `string` is interpreted as a filename.\n  It must be a [POSIX filename](https://en.wikipedia.org/wiki/Filename) starting with a letter, digit, dot, or underscore.\n  Spaces or special characters are not allowed.\n\n`content` (String)\n: The content of the script.\n\n:::{.note}\nThis function is used as base implementation for other high-level writer functions.\n\nFor example, `writeBash` can (roughly) be implemented as:\n\n```nix\nwriteBash = makeScriptWriter { interpreter = \"${pkgs.bash}/bin/bash\"; }\n```\n:::\n\n# Examples\n:::{.example}\n## `pkgs.writers.makeScriptWriter` dash example\n\n```nix-repl\n:b makeScriptWriter { interpreter = \"${pkgs.dash}/bin/dash\"; } \"hello\" \"echo hello world\"\n-> /nix/store/indvlr9ckmnv4f0ynkmasv2h4fxhand0-hello\n```\n\nThe above example creates a script named `hello` that outputs `hello world` when executed.\n\n```sh\n> /nix/store/indvlr9ckmnv4f0ynkmasv2h4fxhand0-hello\nhello world\n```\n:::\n\n:::{.example}\n## `pkgs.writers.makeScriptWriter` python example\n\n```nix-repl\n:b makeScriptWriter { interpreter = \"${pkgs.python3}/bin/python\"; } \"python-hello\" \"print('hello world')\"\n-> /nix/store/4kvby1hqr45ffcdrvfpnpj62hanskw93-python-hello\n```\n\n```sh\n> /nix/store/4kvby1hqr45ffcdrvfpnpj62hanskw93-python-hello\nhello world\n```\n:::\n",
  "pkgs.writers.override": null,
  "pkgs.writers.overrideDerivation": null,
  "pkgs.writers.writeBabashka": "\nwriteBabashka takes a name, an attrset with babashka interpreter and linting check (both optional)\nand some babashka source code and returns an executable.\n\n`pkgs.babashka-unwrapped` is used as default interpreter for small closure size. If dependencies needed, use `pkgs.babashka` instead. Pass empty string to check to disable the default clj-kondo linting.\n\n# Examples\n:::{.example}\n## `pkgs.writers.writeBabashka` with empty arguments\n\n```nix\nwriteBabashka \"example\" { } ''\n  (println \"hello world\")\n''\n```\n:::\n\n:::{.example}\n## `pkgs.writers.writeBabashka` with arguments\n\n```nix\nwriteBabashka \"example\"\n{\n  makeWrapperArgs = [\n    \"--prefix\" \"PATH\" \":\" \"${lib.makeBinPath [ pkgs.hello ]}\"\n  ];\n}\n''\n  (require '[babashka.tasks :as tasks])\n  (tasks/shell \"hello\" \"-g\" \"Hello babashka!\")\n''\n```\n:::\n\n:::{.note}\nBabashka needs Java for fetching dependencies. Wrapped babashka contains jdk,\npass wrapped version `pkgs.babashka` to babashka if dependencies are required.\n\nFor example:\n\n```nix\nwriteBabashka \"example\"\n{\n  babashka = pkgs.babashka;\n}\n''\n  (require '[babashka.deps :as deps])\n  (deps/add-deps '{:deps {medley/medley {:mvn/version \"1.3.0\"}}})\n  (require '[medley.core :as m])\n  (prn (m/index-by :id [{:id 1} {:id 2}]))\n''\n```\n:::\n\n:::{.note}\nDisable clj-kondo linting:\n\n```nix\nwriteBabashka \"example\"\n{\n  check = \"\";\n}\n''\n  (println \"hello world\")\n''\n```\n:::\n",
  "pkgs.writers.writeBabashkaBin": "\nwriteBabashkaBin takes the same arguments as writeBabashka but outputs a directory\n(like writeScriptBin)\n",
  "pkgs.writers.writeBash": "\nLike writeScript but the first line is a shebang to bash\nCan be called with or without extra arguments.\n\n# Examples\n:::{.example}\n\n## Without arguments\n\n```nix\nwriteBash \"example\" ''\necho hello world\n''\n```\n\n## With arguments\n\n```nix\nwriteBash \"example\"\n{\n  makeWrapperArgs = [\n    \"--prefix\" \"PATH\" \":\" \"${lib.makeBinPath [ pkgs.hello ]}\"\n  ];\n}\n''\n  hello\n''\n```\n:::\n",
  "pkgs.writers.writeBashBin": "\nLike writeScriptBin but the first line is a shebang to bash\n\nCan be called with or without extra arguments.\n\n## Examples\n:::{.example}\n## `pkgs.writers.writeBashBin` example without arguments\n\n```nix\nwriteBashBin \"example\" ''\n  echo hello world\n''\n```\n:::\n\n:::{.example}\n## `pkgs.writers.writeBashBin` example with arguments\n\n```nix\nwriteBashBin \"example\"\n{\n  makeWrapperArgs = [\n    \"--prefix\" \"PATH\" \":\" \"${lib.makeBinPath [ pkgs.hello ]}\"\n  ];\n}\n''\n  hello\n''\n```\n:::\n",
  "pkgs.writers.writeDash": "\nLike writeScript but the first line is a shebang to dash\n\nCan be called with or without extra arguments.\n\n# Example\n:::{.example}\n## `pkgs.writers.writeDash` example without arguments\n\n```nix\nwriteDash \"example\" ''\n  echo hello world\n''\n```\n:::\n\n:::{.example}\n## `pkgs.writers.writeDash` example with arguments\n\n```nix\nwriteDash \"example\"\n{\n  makeWrapperArgs = [\n    \"--prefix\" \"PATH\" \":\" \"${lib.makeBinPath [ pkgs.hello ]}\"\n  ];\n}\n''\n  hello\n''\n```\n:::\n",
  "pkgs.writers.writeDashBin": "\nLike writeScriptBin but the first line is a shebang to dash\n\nCan be called with or without extra arguments.\n\n# Examples\n:::{.example}\n## `pkgs.writers.writeDashBin` without arguments\n\n```nix\nwriteDashBin \"example\" ''\n  echo hello world\n''\n```\n:::\n\n:::{.example}\n## `pkgs.writers.writeDashBin` with arguments\n\n```nix\nwriteDashBin \"example\"\n{\n  makeWrapperArgs = [\n    \"--prefix\" \"PATH\" \":\" \"${lib.makeBinPath [ pkgs.hello ]}\"\n  ];\n}\n''\n  hello\n''\n```\n:::\n",
  "pkgs.writers.writeFSharp": null,
  "pkgs.writers.writeFSharpBin": null,
  "pkgs.writers.writeFish": "\nLike writeScript but the first line is a shebang to fish\n\nCan be called with or without extra arguments.\n\n:::{.example}\n## `pkgs.writers.writeFish` without arguments\n\n```nix\nwriteFish \"example\" ''\n  echo hello world\n''\n```\n:::\n\n:::{.example}\n## `pkgs.writers.writeFish` with arguments\n\n```nix\nwriteFish \"example\"\n{\n  makeWrapperArgs = [\n    \"--prefix\" \"PATH\" \":\" \"${lib.makeBinPath [ pkgs.hello ]}\"\n  ];\n}\n''\n  hello\n''\n```\n:::\n",
  "pkgs.writers.writeFishBin": "\nLike writeScriptBin but the first line is a shebang to fish\n\nCan be called with or without extra arguments.\n\n# Examples\n:::{.example}\n## `pkgs.writers.writeFishBin` without arguments\n\n```nix\nwriteFishBin \"example\" ''\n  echo hello world\n''\n```\n:::\n\n:::{.example}\n## `pkgs.writers.writeFishBin` with arguments\n\n```nix\nwriteFishBin \"example\"\n{\n  makeWrapperArgs = [\n    \"--prefix\" \"PATH\" \":\" \"${lib.makeBinPath [ pkgs.hello ]}\"\n  ];\n}\n''\n  hello\n''\n```\n:::\n",
  "pkgs.writers.writeGuile": "\n`writeGuile` returns a derivation that creates an executable Guile script.\n\n# Inputs\n\n`nameOrPath` (String)\n: Name of or path to the script. The semantics is the same as that of\n `makeScriptWriter`.\n\n`config` (AttrSet)\n: `guile` (Optional, Derivation, Default: `pkgs.guile`)\n  : Guile package used for the script.\n: `libraries` (Optional, [ Derivation ], Default: [])\n  : Extra Guile libraries exposed to the script.\n: `r6rs` and `r7rs` (Optional, Boolean, Default: false)\n  : Whether to adapt Guile’s initial environment to better support R6RS/\n    R7RS. See the [Guile Reference Manual](https://www.gnu.org/software/guile/manual/html_node/index.html)\n    for details.\n: `srfi` (Optional, [ Int ], Default: [])\n  : SRFI module to be loaded into the interpreter before evaluating a\n    script file or starting the REPL. See the Guile Reference Manual to\n    know which SRFI are supported.\n: Other attributes are directly passed to `makeScriptWriter`.\n\n`content` (String)\n: Content of the script.\n\n# Examples\n\n:::{.example}\n## `pkgs.writers.writeGuile` with default config\n\n```nix\nwriteGuile \"guile-script\" { }\n''\n  (display \"Hello, world!\")\n''\n```\n:::\n\n:::{.example}\n## `pkgs.writers.writeGuile` with SRFI-1 enabled and extra libraries\n\n```nix\nwriteGuile \"guile-script\" {\n  libraries = [ pkgs.guile-semver ];\n  srfi = [ 1 ];\n}\n''\n  (use-modules (semver))\n  (make-semver 1 (third '(2 3 4)) 5) ; => #<semver 1.4.5>\n''\n```\n:::\n",
  "pkgs.writers.writeGuileBin": "\nwriteGuileBin takes the same arguments as writeGuile but outputs a directory\n(like writeScriptBin)\n",
  "pkgs.writers.writeHaskell": "\nwriteHaskell takes a name, an attrset with libraries and haskell version (both optional)\nand some haskell source code and returns an executable.\n\n# Examples\n:::{.example}\n## `pkgs.writers.writeHaskell` usage example\n\n```nix\nwriteHaskell \"missiles\" { libraries = [ pkgs.haskellPackages.acme-missiles ]; } ''\n  import Acme.Missiles\n\n  main = launchMissiles\n'';\n```\n:::\n",
  "pkgs.writers.writeHaskellBin": "\nwriteHaskellBin takes the same arguments as writeHaskell but outputs a directory (like writeScriptBin)\n",
  "pkgs.writers.writeJS": "\nwriteJS takes a name an attributeset with libraries and some JavaScript sourcecode and\nreturns an executable\n\n# Inputs\n\n`name`\n\n: 1\\. Function argument\n\n`attrs`\n\n: 2\\. Function argument\n\n`content`\n\n: 3\\. Function argument\n\n# Examples\n:::{.example}\n## `pkgs.writers.writeJS` usage example\n\n```nix\nwriteJS \"example\" { libraries = [ pkgs.uglify-js ]; } ''\n  var UglifyJS = require(\"uglify-js\");\n  var code = \"function add(first, second) { return first + second; }\";\n  var result = UglifyJS.minify(code);\n  console.log(result.code);\n''\n```\n\n:::\n",
  "pkgs.writers.writeJSBin": "\nwriteJSBin takes the same arguments as writeJS but outputs a directory (like writeScriptBin)\n",
  "pkgs.writers.writeJSON": null,
  "pkgs.writers.writeLua": null,
  "pkgs.writers.writeLuaBin": null,
  "pkgs.writers.writeNginxConfig": null,
  "pkgs.writers.writeNim": "\nwriteNim takes a name, an attrset with an optional Nim compiler, and some\nNim source code, returning an executable.\n\n# Examples\n:::{.example}\n## `pkgs.writers.writeNim` usage example\n\n```nix\n  writeNim \"hello-nim\" { nim = pkgs.nim2; } ''\n    echo \"hello nim\"\n  '';\n```\n:::\n",
  "pkgs.writers.writeNimBin": "\nwriteNimBin takes the same arguments as writeNim but outputs a directory\n(like writeScriptBin)\n",
  "pkgs.writers.writeNu": "\nLike writeScript but the first line is a shebang to nu\n\nCan be called with or without extra arguments.\n\n# Examples\n:::{.example}\n## `pkgs.writers.writeNu` without arguments\n\n```nix\nwriteNu \"example\" ''\n  echo hello world\n''\n```\n:::\n\n:::{.example}\n## `pkgs.writers.writeNu` with arguments\n\n```nix\nwriteNu \"example\"\n  {\n    makeWrapperArgs = [\n      \"--prefix\" \"PATH\" \":\" \"${lib.makeBinPath [ pkgs.hello ]}\"\n    ];\n  }\n  ''\n    hello\n  ''\n```\n:::\n",
  "pkgs.writers.writeNuBin": "\nLike writeScriptBin but the first line is a shebang to nu\n\nCan be called with or without extra arguments.\n\n# Examples\n:::{.example}\n## `pkgs.writers.writeNuBin` without arguments\n\n```nix\nwriteNuBin \"example\" ''\n  echo hello world\n''\n```\n:::\n\n:::{.example}\n## `pkgs.writers.writeNuBin` with arguments\n\n```nix\nwriteNuBin \"example\"\n  {\n    makeWrapperArgs = [\n      \"--prefix\" \"PATH\" \":\" \"${lib.makeBinPath [ pkgs.hello ]}\"\n    ];\n  }\n  ''\n    hello\n  ''\n```\n:::\n",
  "pkgs.writers.writePerl": "\nwritePerl takes a name an attributeset with libraries and some perl sourcecode and\nreturns an executable\n\n# Examples\n:::{.example}\n## `pkgs.writers.writePerl` usage example\n\n```nix\nwritePerl \"example\" { libraries = [ pkgs.perlPackages.boolean ]; } ''\n  use boolean;\n  print \"Howdy!\\n\" if true;\n''\n```\n\n:::\n",
  "pkgs.writers.writePerlBin": "\nwritePerlBin takes the same arguments as writePerl but outputs a directory (like writeScriptBin)\n",
  "pkgs.writers.writePyPy2": null,
  "pkgs.writers.writePyPy2Bin": "\nwritePyPy2Bin takes the same arguments as writePyPy2 but outputs a directory (like writeScriptBin)\n",
  "pkgs.writers.writePyPy3": null,
  "pkgs.writers.writePyPy3Bin": "\nwritePyPy3Bin takes the same arguments as writePyPy3 but outputs a directory (like writeScriptBin)\n",
  "pkgs.writers.writePython3": null,
  "pkgs.writers.writePython3Bin": "writePython3Bin takes the same arguments as writePython3 but outputs a directory (like writeScriptBin)",
  "pkgs.writers.writeRuby": null,
  "pkgs.writers.writeRubyBin": null,
  "pkgs.writers.writeRust": null,
  "pkgs.writers.writeRustBin": null,
  "pkgs.writers.writeTOML": null,
  "pkgs.writers.writeText": "or https://nixos.org/manual/nixpkgs/unstable/#trivial-builder-text-writing",
  "pkgs.writers.writeYAML": null
}
