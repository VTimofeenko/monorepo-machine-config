#+TITLE: My machine configs
#+AUTHOR: Vladimir Timofeenko
#+EMAIL: id@vtimofeenko.com
#+DATE: <2022-11-09 Wed>
#+TAGS: { fix(b) feat(f) doc(d) chore(c) to_think(t) }
#+HEADER-ARGS:nix: :padline no

# TODO Not right now
# #+HUGO_BASE_DIR: ~/Documents/vtimofeenko.com/
# #+HUGO_SECTION: posts
# #+HUGO_LEVEL_OFFSET: 0
# #+HUGO_CODE_FENCE: nil
# #+EXPORT_FILE_NAME: TODO:

* README

#+begin_src md :tangle README.md

This is my set of dotfiles in a single flake. The README contains a high-level description of the outputs and the `project.org` file contains the details and rationalization of implementation.

# Background

I have migrated to using Nix(ideally, NixOS) on all machines that I get my hands on. This repo contains the configurations for the common tools I use across the machines.

Certain components of my config (mostly dealing with passwords and such) are not included in this flake but rather managed through a separate flake called ~private-config~

# Usage

```nix
{
    inputs= {
        monorepo = {
            url = "github:VTimofeenko/monorepo-machine-config";
            inputs = {
                infra.follows = "stub-flake";
                private-config.follows = "stub-flake";
            };
        };
        stub-flake.url = "github:VTimofeenko/stub-flake"; # A completely empty flake
    };
    outputs = inputs@{ ... }:
    {
        # Import modules/overlays from inputs.monorepo. See the rest of README for more details
    };
}
```

# Specific outputs description

## Modules

The flake comes with a `default` module that currently includes:

- [zsh config](#ZSH-module)
- nix-the-package-manager config

It can be imported as

```nix
{
    outputs = inputs@{ ... }:
    {
        nixosConfigurations.machine-name = nixpkgs.lib.nixosSystem {
            # ...
            modules =
            [
                inputs.monorepo.nixosModules.default
            ];
        };
    };
}
```

#+end_src

* Project TOOD stats :noexport:

#+BEGIN: tagblock :todo ("DONE" "CNCL") :caption done :tags ("fix" "feat" "doc" "chore")
#+caption: done
| fix   | 2 |
| feat  | 7 |
| doc   | 1 |
| chore | 9 |
#+END

#+BEGIN: tagblock :todo t :caption todo :tags ("fix" "feat" "doc" "chore")
#+caption: todo
| fix   | 2 |
| feat  | 9 |
| doc   | 2 |
| chore | 7 |
#+END

* Project structure

- `project.org` :: file, from which everything gets tangled
- `hosts/` :: directory where per-machine configs are stored
- `modules/` :: top-level directory to contain all categories of modules

* Intro :noexport:

Boring technical stuff

#+begin_src nix :tangle flake.nix
{
  description = "NixOS configuration by Vladimir Timofeenko";
#+end_src

* Inputs
:PROPERTIES:
:CATEGORY: INPUTS
:END:

#+begin_src nix :tangle flake.nix
  inputs = {
    nixpkgs.url = "nixpkgs/nixos-22.11";
    nixos-hardware.url = "github:NixOS/nixos-hardware/master";
    home-manager.url = "github:rycee/home-manager/release-22.11";
    agenix.url = "github:ryantm/agenix";

    # Theming and stuff
    base16 = {
      url = "github:SenchoPens/base16.nix";
      # One input only
      inputs.nixpkgs.follows = "nixpkgs";
    };

    color_scheme = {
      url = "github:ajlende/base16-atlas-scheme";
      flake = false;
    };
    private-config = {
      url = "git+ssh://gitea@gitea.srv.vtimofeenko.com/spacecadet/private-flake.git";
      inputs = {
        agenix.follows = "agenix";
        nixpkgs.follows = "nixpkgs";
      };
    };
    my-tmux = {
      url = "github:VTimofeenko/tmux-flake";
      inputs = {
        nixpkgs.follows = "nixpkgs";
        base16.follows = "base16";
        color_scheme.follows = "color_scheme";
      };
    };

    my-nvim-flake.url = "github:VTimofeenko/nvim-flake";

    my-sway-config = {
      url = "git+file:///home/spacecadet/code/sway-flake?ref=master";
      inputs = {
        base16.follows = "base16";
        color-scheme.follows = "color_scheme";
      };
    };
    # nur.url = "github:nix-community/NUR";
    my-doom-config = {
      url = "git+ssh://gitea@gitea.srv.vtimofeenko.com/spacecadet/doom-config.git";
    };
    wg-namespace-flake = {
      url = "git+ssh://gitea@gitea.srv.vtimofeenko.com/spacecadet/wireguard-namespace-flake.git";
      inputs.nixpkgs.follows = "nixpkgs";
    };

    infra = {
      url = "git+ssh://gitea@gitea.srv.vtimofeenko.com/spacecadet/infra-hosts.git";
      flake = false;
    };

    hyprland.url = "github:hyprwm/Hyprland";

  };
#+end_src

*** CNCL Consider dropping nixos-hardware and merging everything here by hand :chore:
CLOSED: [2022-12-09 Fri 17:25]

*** DONE Make sure all inputs of base16 are tracking other inputs :chore:
CLOSED: [2022-12-12 Mon 19:39]

*** DONE Unify naming scheme (some inputs are called "my-", others - "vt-") :chore:
CLOSED: [2022-12-12 Mon 19:43]

*** DONE Evaluate vt-colors input :to_think:
CLOSED: [2022-12-12 Mon 19:45]

*** DONE Move all path:// inputs to at least git+file, ideally - git+ssh on gitea :chore:
CLOSED: [2022-12-14 Wed 21:54]

* Outputs
:PROPERTIES:
:header-args:nix: :tangle flake.nix
:END:

** Intro
First, the plumbing:

#+begin_src nix
outputs = inputs@{ flake-parts
                 , nixos-hardware
                 , home-manager
                 , agenix
                 , my-nvim-flake
                 , private-config
                 , my-sway-config
                 , self
                 , ...
                 }:
    flake-parts.lib.mkFlake {inherit inputs; } {
      imports = [];
      systems = [ "x86_64-linux" "aarch64-darwin" ];
#+end_src

** perSystem output
I prefer nixpkgs-fmt formatter. Using ~formatter~ output, one can be specified in the flake itself:

#+begin_src nix :tangle flake.nix
  perSystem = { config, self', inputs', pkgs, system, ... }:
    {
      formatter = pkgs.nixpkgs-fmt;
#+end_src

*** homeConfigurations
**** Flake.nix

This section contains modules that can be imported into home manager.

#+begin_src nix :tangle flake.nix

legacyPackages.homeConfigurations =
  let
    hmc = attrset: home-manager.lib.homeManagerConfiguration ({ inherit pkgs; } // attrset);  # shortcut
    _defaultModules =
          [
            ./homeConfigurations/home.nix
            ./homeConfigurations/vim
            ./homeConfigurations/kitty
            ./homeConfigurations/zsh
          ];
  in
  rec {
    deck = hmc
      {
        modules =
          _defaultModules
          ++
          [ ./homeConfigurations/_perUser/deck.nix ];
      };
    vtimofeenko = hmc
      {
        modules =
          [
            ./homeConfigurations/home.nix
            ./homeConfigurations/vim
            ./homeConfigurations/_perUser/vtimofeenko.nix
          ];
      };
    spacecadet = hmc
      {
        modules =
          [
            ./homeConfigurations/home.nix
            ./homeConfigurations/vim
          ];
      };
#+end_src

***** TODO Add kitty and zsh to spacecadet config once system zsh is gone
**** Modules

***** Base home.nix

#+begin_src nix :tangle homeConfigurations/home.nix
{ config, pkgs, ... }:
{
  home.stateVersion = "22.11";
  programs.home-manager.enable = true;
}
#+end_src

****** Reference

- Add a per-user package through ~home.packages = [ ... ]~
- Add per-user file:

  #+begin_src nix :tangle no
home.file =
  {
    ".screenrc".text = "foo";
  };

  #+end_src

***** Vim

Having switched to emacs for most of text-based work, I still use neovim for one-off editing stuff in terminal.

The module described in this section should be used by root and human users on my machines as well as on MacOS, thus I am using home manager module as the platform-agnostic way.

#+begin_src nix :tangle homeConfigurations/vim/default.nix
# Home manager module that configures neovim with some plugins
{ pkgs, config, lib, ... }:
{
  programs.neovim =
    {
      enable = true;
      viAlias = true;
      vimAlias = true;
      vimdiffAlias = true;
      plugins =
        with pkgs.vimPlugins; [
          vim-surround
          vim-commentary
          vim-nix
          delimitMate
        ];
      extraConfig =
        ''
          syntax on

          let mapleader="\<Space>"

          nnoremap <leader>wl <C-w>l
          nnoremap <leader>wk <C-w>k
          nnoremap <leader>wj <C-w>j
          nnoremap <leader>wh <C-w>h

          nnoremap <silent> <leader>ws :split<CR>
          nnoremap <silent> <leader>wv :vsplit<CR>
          " close the _window_, not the buffer
          nnoremap <silent> <leader>wd <C-w>c

          set number relativenumber
          set modelines=1
          set autoindent
          set ignorecase
          set smartcase incsearch
          filetype plugin on

          " cursor shapes in insert/normal modes
          let &t_SI = "\e[6 q"
          let &t_EI = "\e[2 q"
          hi Visual term=bold,reverse cterm=bold,reverse
          set expandtab
          set tabstop=4
          set shiftwidth=4
          set autoread
          autocmd FileType nix setlocal tabstop=2 shiftwidth=2
          autocmd BufWritePost,FileWritePost *.nix silent !nix fmt >/dev/null 2>&1
 
          set clipboard=unnamed${if pkgs.stdenv.system != "aarch64-darwin" then "plus" else ""}
          set mouse=
        '';
    };
}
#+end_src

****** TODO Make nix fmt async :feat:

***** Zsh

****** Base module

#+begin_src nix :tangle homeConfigurations/zsh/default.nix
# home-manager clone of the OG zsh
{ pkgs, config, lib, ... }:
{
  home.packages = [
    pkgs.fzf
  ];
  programs.zsh =
    {
      enable = true;
      enableAutosuggestions = true;
      enableCompletion = true;
      enableSyntaxHighlighting = true;
      autocd = true;
      defaultKeymap = "vicmd";
      dotDir = ".config/zsh";
      history =
        {
          extended = true;
          ignoreDups = true;
          ignorePatterns = [ "rm *" "pkill *" ];
          ignoreSpace = false;
        };
      initExtra =
        ''
          setopt BANG_HIST
          setopt INTERACTIVE_COMMENTS
          setopt HIST_VERIFY
          setopt HIST_FCNTL_LOCK
          # Enable vim editing of command line
          ${builtins.readFile ./plugins/01-vim-edit.zsh}
          # Enable cd +1..9 to go back in dir stack
          ${builtins.readFile ./plugins/02-cd.zsh}
          # fzf bindings
          source ${pkgs.fzf}/share/fzf/key-bindings.zsh
          # Word Navigation shortcuts
          bindkey "^A" vi-beginning-of-line
          bindkey "^E" vi-end-of-line
          bindkey "^F" end-of-line
          # ctrl+arrow for word jupming
          bindkey "^[[1;5C" forward-word
          bindkey "^[[1;5D" backward-word
          # alt+f forward a word
          bindkey "^[f" forward-word
          # alt+b back a word
          bindkey "^[b" backward-word
          # working backspace
          bindkey -v '^?' backward-delete-char
          # Use vim keys in tab complete menu
          zmodload zsh/complist
          bindkey -M menuselect 'h' vi-backward-char
          bindkey -M menuselect 'k' vi-up-line-or-history
          bindkey -M menuselect 'l' vi-forward-char
          bindkey -M menuselect 'j' vi-down-line-or-history
          bindkey -M menuselect '^ ' accept-line
          # Add entry by "+" but do not exit menuselect
          bindkey -M menuselect "+" accept-and-menu-complete
          # Color the completions
          autoload -Uz compinit
          zstyle ':completion:*' matcher-list 'm:{[:lower:][:upper:]}={[:upper:][:lower:]}' 'm:{[:lower:][:upper:]}={[:upper:][:lower:]} l:|=* r:|=*' 'm:{[:lower:][:upper:]}={[:upper:][:l
ower:]} l:|=* r:|=*' 'm:{[:lower:][:upper:]}={[:upper:][:lower:]} l:|=* r:|=*'
          zstyle ':completion:*' list-colors ''${(s.:.)LS_COLORS}
          zstyle ':completion:*' menu select
          # Automatically escape urls when pasting
          autoload -Uz url-quote-magic
          zle -N self-insert url-quote-magic
          autoload -Uz bracketed-paste-magic
          zle -N bracketed-paste bracketed-paste-magic
          # Custom plugins can be quickly loaded if fpath is extended:
          fpath=(${./plugins} $fpath)
          # Bookmarks by "@@"
          autoload -Uz bookmarks.zsh && bookmarks.zsh
          # Cursor mode block <> beam
          autoload -Uz cursor_mode.zsh && cursor_mode.zsh
          # alias that creates the directory and changes into it
          mkcd(){ mkdir -p "$@" && cd "$@"; }
        '';
      shellAliases = {
        e = "$EDITOR";
        nvim = "$EDITOR";
        vim = "$EDITOR";
        ls = "${pkgs.exa}/bin/exa -h --group-directories-first --icons";
        l = "ls";
        ll = "ls -l";
        la = "ls -al";
        ka = "${pkgs.killall}/bin/killall";
        mkd = "mkdir -pv";
        ga = "${pkgs.git}/bin/git add";
        gau = "ga -u";
        grep = "grep --color=auto";
        mv = "mv -v";
        rm = "${pkgs.coreutils}/bin/rm -id";
        vidir = "${pkgs.moreutils}/bin/vidir --verbose";
        ccopy = "${pkgs.wl-clipboard}/bin/wl-copy";
        syu = "systemctl --user";
        cde = "cd /etc/nixos";
        lg = "${pkgs.lazygit}/bin/lazygit";
        # Colorize IP output
        ip = "ip -c";
      };
    };
  programs.starship =
    {
      enable = true;
      enableBashIntegration = false;
      enableFishIntegration = false;
      enableIonIntegration = false;
      enableNushellIntegration = false;
    };
}
#+end_src

****** ZSH modules

******* 01-vim-edit

#+begin_src sh :tangle homeConfigurations/zsh/plugins/01-vim-edit.zsh
# vim style editing
bindkey -v

autoload edit-command-line; zle -N edit-command-line
bindkey -M vicmd jk edit-command-line  # jk chord to edit the current line
#+end_src

******* 02-cd

#+begin_src sh :tangle homeConfigurations/zsh/plugins/02-cd.zsh
# File that sets the behavior of cd command
setopt autocd

# dirs stack manipulation
setopt AUTO_PUSHD           # Push the current directory visited on the stack.
setopt PUSHD_IGNORE_DUPS    # Do not store duplicates in the stack.
setopt PUSHD_SILENT         # Do not print the directory stack after

# Enabled cd +X to change directory to somewhere in stack
alias d='dirs -v' # prints stack of directories
for index ({1..9}) alias "$index"="cd +${index}"; unset index
#+end_src

******* bookmarks

#+begin_src sh :tangle homeConfigurations/zsh/plugins/bookmarks.zsh
# -*- sh -*-
autoload is-at-least
# Source: https://github.com/vincentbernat/zshrc/blob/master/rc/bookmarks.zsh
# Changed by Vladimir Timofeenko, changed MARKPATH to local share for persistence

# Handle bookmarks. This uses the static named directories feature of
# zsh. Such directories are declared with `hash -d
# name=directory`. Both prompt expansion and completion know how to
# handle them. We populate the hash with directories.
#
# With autocd, you can just type `~-bookmark`. Since this can be
# cumbersome to type, you can also type `@@` and this will be turned
# into `~-` by ZLE.

is-at-least 4.3.12 && () {
    MARKPATH="${HOME}/.local/share/zsh/bookmarks"

    # Add some static entries
    hash -d log=/var/log
    hash -d doc=/usr/share/doc

    # Populate the hash
    for link ($MARKPATH/*(N@)) {
        hash -d -- -${link:t}=${link:A}
    }

    vbe-insert-bookmark() {
        emulate -L zsh
        LBUFFER=${LBUFFER}"~-"
    }
    zle -N vbe-insert-bookmark
    bindkey '@@' vbe-insert-bookmark

    # Manage bookmarks
    bookmark() {
        [[ -d $MARKPATH ]] || mkdir -p $MARKPATH
        if (( $# == 0 )); then
            # When no arguments are provided, just display existing
            # bookmarks
            for link in $MARKPATH/*(N@); do
                local markname=${(%):-%F{green}${link:t}%f}
                local markpath=${(%):-%F{blue}${link:A}%f}
                printf "%-30s â†’ %s\n" $markname $markpath
            done
        else
            # Otherwise, we may want to add a bookmark or delete an
            # existing one.
            local -a delete
            zparseopts -D d=delete
            if (( $+delete[1] )); then
                # With `-d`, we delete an existing bookmark
                command rm $MARKPATH/$1
            else
                # Otherwise, add a bookmark to the current
                # directory. The first argument is the bookmark
                # name. `.` is special and means the bookmark should
                # be named after the current directory.
                local name=$1
                [[ $name == "." ]] && name=${PWD:t}
                ln -s $PWD $MARKPATH/$name
                hash -d -- -${name}=${PWD}
            fi
        fi
    }
}
#+end_src

******* cursor_mode

#+begin_src sh :tangle homeConfigurations/zsh/plugins/cursor_mode.zsh
cursor_mode() {
    # See https://ttssh2.osdn.jp/manual/4/en/usage/tips/vim.html for cursor shapes
    cursor_block='\e[2 q'

    cursor_beam='\e[6 q'

    function zle-keymap-select {
        if [[ ${KEYMAP} == vicmd ]] ||
            [[ $1 = 'block' ]]; then
            echo -ne $cursor_block
        elif [[ ${KEYMAP} == main ]] ||
            [[ ${KEYMAP} == viins ]] ||
            [[ ${KEYMAP} = '' ]] ||
            [[ $1 = 'beam' ]]; then
            echo -ne $cursor_beam
        fi
    }

    zle-line-init() {
        echo -ne $cursor_beam
    }

    zle -N zle-keymap-select
    zle -N zle-line-init
}

cursor_mode
#+end_src


***** Kitty

#+begin_src nix :tangle homeConfigurations/kitty/default.nix
{ pkgs, ... }:

{
  programs.kitty = {
    enable = true;
    # theme = "Neopolitan";
    theme = "Doom Vibrant";
    settings = {
      cursor_blink_interval = 0;
      background_opacity = "0.95";
      inactive_text_alpha = "0.85";
      cursor = "none";
      enable_audio_bell = false;
      tab_bar_margin_width = 9;
      tab_bar_margin_height = "2 2";
      tab_bar_style = "separator";
      tab_bar_min_tabs = 2;
      tab_bar_edge = "bottom";
      tab_title_template = "{fmt.fg.white} {title.split()[0]} ";
      active_tab_title_template = "{fmt.noitalic}{fmt.bg.black}{fmt.fg.white} {title.split()[0]} ";
    };
    keybindings = {
      # Opens a new Kitty window in the current working directory
      "kitty_mod+enter" = "launch --cwd=current";
    };
  };
}
#+end_src

***** TODO Re-export doom emacs :feat:

**** Specific user customizations

***** Deck

#+begin_src nix :tangle homeConfigurations/_perUser/deck.nix
{ pkgs, lib, config, ... }:
{
  programs.kitty.package = lib.mkForce pkgs.hello; # Workaround for kitty not getting needed opengl on arch
  home.username = "deck";
  home.homeDirectory = "/home/deck";
}
#+end_src

***** Vtimofeenko

#+begin_src nix :tangle homeConfigurations/_perUser/vtimofeenko.nix
{ pkgs, lib, config, ... }:
{
  programs.kitty.package = lib.mkForce pkgs.hello; # Workaround for kitty not getting needed opengl on arch
  home.username = "vtimofeenko";
  home.homeDirectory = "/Users/vtimofeenko";
}
#+end_src

**** Outro :noexport:
#+begin_src nix :tangle flake.nix
# homeConfigurations closing bracket
};
#+end_src

*** Outro :noexport:
#+begin_src nix :tangle flake.nix
# perSystem closing bracket
};
#+end_src


** flake output (modules, nixosConfigurations)

#+begin_src nix
flake = {
#+end_src

*** nixosModules

this section contains the modules that can be reused without using the rest of the configuration. Modules can be imported en massed by importing ~nixosModules.default~ from this flake. Alternatively individual modules can be imported on their own.

~nixosModules~ is a recursive attrset which allows me to refer to other attributes when constructing default module's imports:

#+begin_src nix :tangle flake.nix
    nixosModules = rec {
      default = { ... }: {
        imports = [
          zsh
          nix-config
        ];
      };
      zsh = import ./modules/zsh;
      nix-config = import ./modules/common/nix-config.nix;
      swaySystemModule = import ./modules/sway/system;
    };
#+end_src

*** nixosConfigurations

**** Common

#+begin_src nix :tangle flake.nix
  nixosConfigurations =
    let
      _commonModulesFromInput =
        [
          agenix.nixosModules.default
          home-manager.nixosModules.home-manager
          inputs.my-tmux.nixosModule
          {
            programs.vt-zsh =
              {
                starship_enable = true;
                direnv_enable = true;
                gpg_enable = true;
                enableAnyNixShell = true;
              };
           }
           { home-manager.users.spacecadet = my-sway-config.nixosModules.default; }
           my-sway-config.nixosModules.system
           {
             home-manager.users.spacecadet = { ... }: {
               wayland.windowManager.sway.config = {
                 # Restore non-vm modifier
                 modifier = "Mod4";
                 # Output configuration
                 output = {
                   "eDP-1" = { "scale" = "1"; };
                 };
               };
               vt-sway.enableBrightness = true;
             };
           }
           {
             # Needed, otherwise error
             # error: cannot look up '<nixpkgs>' in pure evaluation mode
             home-manager.useGlobalPkgs = true;
             home-manager.useUserPackages = true;
             home-manager.users.spacecadet.home.stateVersion = "22.05";
           }
           # My emacs module
           {
             home-manager.users.spacecadet = inputs.my-doom-config.nixosModules.default;
           }
           inputs.wg-namespace-flake.nixosModules.default
           private-config.nixosModules.commonNodeModule
        ];
      _commonLocalModules =
        [
          ./modules/applications
          ./modules/common
          ./modules/development
          ./modules/development/cross-compile.nix
          ./modules/development/virtualization.nix
          ./modules/hardware/dygma.nix
          ./modules/hardware/disks.nix
          ./modules/hardware/printer.nix
          ./modules/hardware/scanner.nix
          ./modules/zsh

          # Network
          ./modules/network/common_lan.nix
          ./modules/network/lan-wifi.nix
        ];
      mkMyModules = list: list ++ _commonLocalModules ++ _commonModulesFromInput;
      _allUserModules =
        [
          ./homeConfigurations/vim
        ];
      # A set of modules to be imported for the user-specific configuration
      # TODO: move to homeConfigurations
      _homeModules =
        [
          inputs.my-doom-config.nixosModules.default
          inputs.hyprland.homeManagerModules.default

          # my hyprland config
          ./modules/hyprland
          # kitty config
          ./modules/applications/kitty.nix
        ] ++ _allUserModules;

  # pkgs = import nixpkgs {
  #   inherit system;
  #   config = { allowUnfree = true; };
  #   overlays = [
  #     # nur.overlay
  #     (final: prev: {
  #       my_nvim = my-nvim-flake.defaultPackage."${system}";
  #     })
  #     my-sway-config.overlays.default
  #   ];
  # };
    in
    {
#+end_src

**** Uranium
#+begin_src nix :tangle flake.nix
uranium = inputs.nixpkgs.lib.nixosSystem {
  system = "x86_64-linux";
  modules = mkMyModules [
    ./hosts/uranium
    private-config.nixosModules.management-network-control-node
    private-config.nixosModules.wg-namespace-config
    ./modules/steam
    { nixpkgs.overlays = [ my-sway-config.overlays.default ]; }
  ];
  # NOTE:
  # This makes the inputs propagate into the modules and allows modules to refer to the inputs
  # See network configuration as an example
  specialArgs = inputs;
};

#+end_src
***** Modules

****** Default
#+begin_src nix :tangle hosts/uranium/default.nix
{ config, pkgs, lib, ... }:

{
  imports = [
    ./frame.work.nix
  ];
  # Use the systemd-boot EFI boot loader.
  boot.loader.systemd-boot.enable = true;
  boot.loader.efi.canTouchEfiVariables = true;
  boot.tmpOnTmpfs = true;
  boot.tmpOnTmpfsSize = "8G";
  # Modules I want to ensure are there
  boot.initrd.availableKernelModules = [ "thunderbolt" "nvme" "usb_storage" "uas" ];
  boot.initrd.kernelModules = [ ];
  boot.kernelModules = [ "kvm-intel" "coretemp" ];
  boot.extraModulePackages = [ ];
  # Frame.work needs latest kernel for BT and Wi-Fi to work.
  boot.kernelPackages = pkgs.linuxPackages_latest;

  networking.hostName = "uranium";
  networking.useDHCP = false;

  fileSystems."/" =
    {
      device = "/dev/disk/by-uuid/cbaf293c-c8dc-4586-ba65-73cff3f24468";
      fsType = "ext4";
    };
  boot.initrd.luks.gpgSupport = true;

  boot.initrd.luks.devices."luks".device = "/dev/disk/by-uuid/c2e5cd09-b5d7-42cb-a78a-f549edfa0eb4";

  fileSystems."/boot" =
    {
      device = "/dev/disk/by-uuid/028E-BC0A";
      fsType = "vfat";
    };

  swapDevices = [ ];

  # This node was created in 21.11 days
  system.stateVersion = "21.11";

  # For brightness control
  users.users.spacecadet.extraGroups = [ "video" ];
  # bluetooth
  hardware.bluetooth.enable = true;
  services.blueman.enable = true;
  # pipewire config, from https://nixos.wiki/wiki/PipeWire
  security.rtkit.enable = true;
  services.pipewire = {
    enable = true;
    alsa.enable = true;
    alsa.support32Bit = true;
    pulse.enable = true;
    # If you want to use JACK applications, uncomment this
    #jack.enable = true;

    # use the example session manager (no others are packaged yet so this is enabled by default,
    # no need to redefine it in your config for now)
    #media-session.enable = true;
    media-session.config.bluez-monitor.rules = [
      {
        # Matches all cards
        matches = [{ "device.name" = "~bluez_card.*"; }];
        actions = {
          "update-props" = {
            "bluez5.reconnect-profiles" = [ "hfp_hf" "hsp_hs" "a2dp_sink" ];
            # mSBC is not expected to work on all headset + adapter combinations.
            "bluez5.msbc-support" = true;
            # SBC-XQ is not expected to work on all headset + adapter combinations.
            "bluez5.sbc-xq-support" = true;
          };
        };
      }
      {
        matches = [
          # Matches all sources
          { "node.name" = "~bluez_input.*"; }
          # Matches all outputs
          { "node.name" = "~bluez_output.*"; }
        ];
        actions = {
          "node.pause-on-idle" = false;
        };
      }
    ];
  };
  # battery management
  powerManagement = {
    enable = true;
    powertop.enable = true;
    cpuFreqGovernor = lib.mkDefault "powersave";
  };
  services.tlp = {
    enable = true;
    settings = {
        CPU_BOOST_ON_AC = 1;
        CPU_BOOST_ON_BAT = 0;
        CPU_SCALING_GOVERNOR_ON_AC = "performance";
        CPU_SCALING_GOVERNOR_ON_BAT = "powersave";
    };
  };
  # temperature management
  services.thermald.enable = true;
  environment.etc."sysconfig/lm_sensors".text = ''
    # Generated by sensors-detect on Mon Jan  3 23:34:14 2022
    # This file is sourced by /etc/init.d/lm_sensors and defines the modules to
    # be loaded/unloaded.
    #
    # The format of this file is a shell script that simply defines variables:
    # HWMON_MODULES for hardware monitoring driver modules, and optionally
    # BUS_MODULES for any required bus driver module (for example for I2C or SPI).

    HWMON_MODULES="coretemp"
  '';
  # Instead of archwiki, frame.work forums recommend this with s2idle

  # Hardware acceleration
  # Taken from https://nixos.wiki/wiki/Accelerated_Video_Playback
  nixpkgs.config.packageOverrides = pkgs: {
    vaapiIntel = pkgs.vaapiIntel.override { enableHybridCodec = true; };
  };
  hardware.opengl = {
    enable = true;
    extraPackages = with pkgs; [
      intel-media-driver # LIBVA_DRIVER_NAME=iHD
      vaapiIntel # LIBVA_DRIVER_NAME=i965 (older but works better for Firefox/Chromium)
      vaapiVdpau
      libvdpau-va-gl
    ];
  };
  services.fwupd = {
    enable = true;
    extraRemotes = [ "lvfs-testing" ];
  };
  environment.etc."fwupd/uefi_capsule.conf".text = lib.mkForce ''
    [uefi_capsule]
    OverrideESPMountPoint=/boot
    DisableCapsuleUpdateOnDisk=true
  '';
  # NOTE: fwupdmgr uses this to check the boot
  services.udisks2.enable = true;
  # NOTE: Wireless config is here for now, until refactoring of default.nix is done
  systemd.network.links."10-wifi-lan" = {
    matchConfig.PermanentMACAddress = "f8:b5:4d:d7:16:53";
    linkConfig.Name = "wifi-lan";
  };
}
#+end_src

****** Frame.work

The hardware configuration that was taken from nixos-hardware and slightly tweaked. I am not using deep sleep on this machine as it's very often plugged into the AC power.

#+begin_src nix :tangle hosts/uranium/frame.work.nix
{ config, lib, pkgs, nixos-hardware, ... }:

{
  imports = [
    nixos-hardware.nixosModules.common-cpu-intel
    nixos-hardware.nixosModules.common-pc-laptop
    nixos-hardware.nixosModules.common-pc-laptop-ssd
  ];
  # high-resolution display
  hardware.video.hidpi.enable = lib.mkDefault true;
  # NOTE: required for wifi to work
  hardware.enableRedistributableFirmware = true;
  hardware.cpu.intel.updateMicrocode = lib.mkDefault config.hardware.enableRedistributableFirmware;
  boot.kernelParams = [
    # For Power consumption
    # https://kvark.github.io/linux/framework/2021/10/17/framework-nixos.html

    # "mem_sleep_default=deep"
    # For Power consumption
    # https://community.frame.work/t/linux-battery-life-tuning/6665/156
    "nvme.noacpi=1"
  ];


  # Fix TRRS headphones missing a mic
  # https://community.frame.work/t/headset-microphone-on-linux/12387/3
  boot.extraModprobeConfig = ''
    options snd-hda-intel model=dell-headset-multi
  '';

  # For fingerprint support
  /* services.fprintd.enable = lib.mkDefault true; */

  # Custom udev rules
  services.udev.extraRules = ''
    # Fix headphone noise when on powersave
    # https://community.frame.work/t/headphone-jack-intermittent-noise/5246/55
    SUBSYSTEM=="pci", ATTR{vendor}=="0x8086", ATTR{device}=="0xa0e0", ATTR{power/control}="on"
    # Ethernet expansion card support
    ACTION=="add", SUBSYSTEM=="usb", ATTR{idVendor}=="0bda", ATTR{idProduct}=="8156", ATTR{power/autosuspend}="20"
  '';

  # Mis-detected by nixos-generate-config
  # https://github.com/NixOS/nixpkgs/issues/171093
  # https://wiki.archlinux.org/title/Framework_Laptop#Changing_the_brightness_of_the_monitor_does_not_work
  hardware.acpilight.enable = lib.mkDefault true;

  # Needed for desktop environments to detect/manage display brightness
  hardware.sensor.iio.enable = lib.mkDefault true;

  # HiDPI
  # Leaving here for documentation
  # hardware.video.hidpi.enable = lib.mkDefault true;

  # Fix font sizes in X
  # services.xserver.dpi = 200;

}
#+end_src

******* DONE Figure out why nixos-hardware imports trigger infinite recursion :fix:
CLOSED: [2022-12-09 Fri 17:26]

****** TODO Break up the default.nix module into smaller pieces - it's too long :chore:



**** Neptunium

#+begin_src nix :tangle flake.nix
neptunium = inputs.nixpkgs.lib.nixosSystem {
  system = "x86_64-linux";
  modules = [
    ./hosts/neptunium
    # private-config.nixosModules.management-network-control-node
    # private-config.nixosModules.wg-namespace-config
    # NOTE: not reuisng certain modules during sway setup
    ./modules/zsh
    ./modules/common
    ./modules/hardware/dygma.nix
    ./modules/network/common_lan.nix
    agenix.nixosModules.default
    home-manager.nixosModules.home-manager
    inputs.my-tmux.nixosModule
    inputs.hyprland.nixosModules.default
    ./modules/sway/system/greeter.nix
    ./modules/sway/system/hyprland.nix
    ./modules/development/editor.nix
    {
      programs.vt-zsh = {
        starship_enable = true;
        direnv_enable = true;
        gpg_enable = true;
        enableAnyNixShell = true;
      };
    }
    {
      # Needed, otherwise error
      # error: cannot look up '<nixpkgs>' in pure evaluation mode
      home-manager.useGlobalPkgs = true;
      home-manager.useUserPackages = true;
      home-manager.users.spacecadet.home.stateVersion = "22.05";
    }
    {
      home-manager.users.spacecadet = inputs.nixpkgs.lib.mkMerge _homeModules;
    }
  ];
  specialArgs = inputs;
};
#+end_src

***** Plan [1/3]
- [X] Add nvidia configuration
- [ ] Merge sway flake here
- [ ] Rework modules list to be similar to uranium and reuse as much as possible

***** Modules
****** Default

#+begin_src nix :tangle hosts/neptunium/default.nix
{ config, pkgs, lib, ... }:

{
  imports =
    [
      ./nvidia2070.nix
    ];
  # Use the systemd-boot EFI boot loader.
  boot =
    {
      loader =
        {
          systemd-boot.enable = true;
          efi.canTouchEfiVariables = true;
        };
      initrd =
        {
          availableKernelModules = [ "xhci_pci" "ahci" "usb_storage" "sd_mod" ];
          kernelModules = [ ];
          luks.devices."crypt-root".device = "/dev/disk/by-uuid/687e04e3-c128-4736-8199-2a7a563b4a97";
        };
      kernelModules = [ "kvm-amd" ];
      tmpOnTmpfs = true;
      tmpOnTmpfsSize = "8G";
    };

  networking.hostName = "neptunium";
  networking.wireless.enable = lib.mkForce false;
  networking.useDHCP = lib.mkForce true;

  services.openssh=
    {
      enable = true;
      permitRootLogin = "yes";
    };
  users.users.root.openssh.authorizedKeys.keys = [
    "ssh-rsa AAAAB3NzaC1yc2EAAAADAQABAAACAQDa78M7tTZW84yAsZuvgN1M6AUd3JB9wa8wMoR3cy59LtrU8FwHjJmCqlpyB7Wa9GrfJe7NEqJ077sYrGQZIw41xUJ7fKaa07Xj4GzASYTB0qlZrdr1WJ4XYif5eh7iXMps5F5saz0d3cJWOeKq6jSAwgkqT/tK5ykPm75uV0PyEvNI06pSqmJy+2VHUu1b3f/cwGHUrBzrJjLSvPBppRxpLc4nhNMIdf+G481MQHzCsdz0lIisGk4t+WcMPapH8nwSFDgKZ1ZesGqFaC/AvyRMuaASjFTk+eNMFgR5KQCCP48iaKkr/CGld9mGZyN8nQ9A0g6ckDQInnhef2EwVJFpfYktqBmi4DOfZksw65qY8eQFdQFxRoQ1D69fEsupX3AF0xgRPV+ByVxKCWz11CUR3+QhKJ7uzEhou/RS4GqG4TiR2+b0zMP/sGZwedNMJQYy1h3bfauo2NVmSJMFt8jKmb82tMcqCW6t71UITRmmluwDNHCyrVXLr3GrhOLylp+NBwzm33QlOZ3ExHV+77hM4vHJwpraR+WrzijzqwQ+ut9zNNWv87AS12++kOWsIZmIJk5idpAjUuxRI8ZjMHNZft9+jaARVVAyVFIzdegfLMJZIs8edaqGN1egERJ4FPU64aFosyymHLSmSAnVEIa7SB04BbWvE19kbRTdUG/Q1Q== cardno:000500006946"
  ];


  networking.firewall.enable = false;
  environment.systemPackages = [ pkgs.git ];

  system.stateVersion = "22.11";
  fileSystems."/" =
    {
      device = "/dev/mapper/crypt-root";
      fsType = "ext4";
    };

  fileSystems."/boot" =
    {
      device = "/dev/disk/by-uuid/3FFD-D8B4";
      fsType = "vfat";
    };

  swapDevices =
    [
      { device = "/dev/disk/by-label/swap"; }
    ];
  hardware.cpu.amd.updateMicrocode = lib.mkDefault config.hardware.enableRedistributableFirmware;
  hardware.video.hidpi.enable = lib.mkDefault true;
  time.hardwareClockInLocalTime = true;  # otherwise dual-booted Windows has wrong time
}
#+end_src
******* TODO add the authorized keys to the base config :chore:

****** Nvidia 2070 with sway

This is the WIP config for Nvidia 2070:

#+begin_quote
# lspci -k | grep -A1 -E "VGA"
09:00.0 VGA compatible controller: NVIDIA Corporation TU106 [GeForce RTX 2070] (rev a1)
	Subsystem: eVga.com. Corp. Device 1071
#+end_quote

The services config is described below:

#+begin_src nix :tangle hosts/neptunium/nvidia2070.nix
{ config, pkgs, lib, ... }:
{
  # The settings are applied for both x11 and wayland
  services.xserver.videoDrivers = [ "nvidia" ];

  # nvidia-drm.modeset=1 is required for some wayland compositors, e.g. sway
  hardware.nvidia = {
    modesetting.enable = true;
    package = pkgs.linuxKernel.packages.linux_6_1.nvidia_x11_beta;
    # Suspend does not work :(
    # open = true;
    # Needed for suspend
    powerManagement.enable = true;
  };

  boot.kernelPackages = pkgs.linuxPackages_6_1;

  environment.variables = {
    # NOTE: needed for mouse cursor to be visible
    WLR_NO_HARDWARE_CURSORS = "1";
    WLR_RENDERER = "vulkan";
  };
  # Apps on sway seem to be unusable without this:
  hardware.nvidia.forceFullCompositionPipeline = true;
}
#+end_src

******* TODO rewrite to literal style :chore:

******* TODO Fix the console resolution :fix:

Upon boot the terminal resolution gets borked around stage 1


**** Outro :noexport:
#+begin_src nix
# Closing bracket for nixosConfigurations
  };
#+end_src


*** Modules

Modules will be divided into categories represented as directories

**** Common -- catch-all

General module that includes all the things:

#+begin_src nix :tangle modules/common/default.nix
{ ... }:
{
  imports = [
    ./nix-config.nix
    ./fonts.nix
    ./user.nix
    ./utils.nix
    ./zsh.nix
  ];
  time.timeZone = "America/Los_Angeles";
  # The global useDHCP flag is deprecated, therefore explicitly set to false here.
  # Per-interface useDHCP will be mandatory in the future, so this generated config
  # replicates the default behaviour.
  networking.useDHCP = false;
}
#+end_src

I am using z shell on all machines where I have some need for an interactive login. The z shell configuration is done in a separate flake (~my-zsh~) which provides the zsh configuration encapsulated in a module.

#+begin_src nix :tangle modules/common/zsh.nix
{ pkgs, ... }:
{
    users.users.root.shell = pkgs.zsh;
}

#+end_src

Some common utilities I find myself using all the time as all users on the system:

#+begin_src nix :tangle modules/common/utils.nix
{ pkgs, ... }:
{
  environment.systemPackages = with pkgs; [
    htop
    curl
    wget
    fd
    inetutils  # for telnet
    ripgrep
    lsof
    dig
    nftables
    unzip
    tcpdump
    jq
  ];
}
#+end_src


****** Nix-the-package-manager config

******* README
#+begin_src md :tangle README.md
### Nix module

The tweaks I use for nix the package manager:

- Enable flakes (mandatory)
- Quickly fail if the network is inaccessible
- Do not nag me if a flake git repo is dirty (has some uncommitted stuff)
- Automatically optimizes `/nix/store` to save a bit of space using hardlinking

#### Installation

To use this module separately from `default` one:

```nix
{
    outputs = inputs@{ ... }:
    {
        nixosConfigurations.machine-name = nixpkgs.lib.nixosSystem {
            # ...
            modules =
            [
                inputs.monorepo.nixosModules.nix-config
            ];
        };
    };
}
```

#+end_src

******* Implementation

#+begin_src nix :tangle modules/common/nix-config.nix
# From https://nixos.wiki/wiki/Flakes
{ pkgs, ... }: {
  # Allow unfree packages across the board
  nixpkgs.config.allowUnfree = true;
  nix = {
    extraOptions = ''
      # Quicker timeout for inaccessible binary caches
      connect-timeout = 5
      # Enable flakes
      experimental-features = nix-command flakes
      # Do not warn on dirty git repo
      warn-dirty = false
      # Automatically optimize store
      auto-optimise-store = true
    '';
  };
}
#+end_src

***** User configuration

#+begin_src nix :tangle modules/common/user.nix
{ pkgs, ... }:

{
  users.users.spacecadet = {
    isNormalUser = true;
    extraGroups = [ "wheel" "lp" ];
    shell = pkgs.zsh;
  };
  home-manager.users.spacecadet = { pkgs, ... }: {
    home.packages = with pkgs; [
      ncspot
      pavucontrol
      blueman
      libreoffice
      firefox
      brave
      gthumb
      nextcloud-client
    ];
    programs.browserpass.enable = true;
    programs.password-store = {
      enable = true;
      package = pkgs.pass.withExtensions (exts: [ exts.pass-otp ]);
    };
    home.file.".icons/default".source = "${pkgs.vanilla-dmz}/share/icons/Vanilla-DMZ";
  };
}
#+end_src

***** Font configuration

#+begin_src nix :tangle modules/common/fonts.nix
{ pkgs, ... }:

{
  fonts = {
    fonts = with pkgs; [
      (nerdfonts.override { fonts = [ "JetBrainsMono" ]; })
      roboto
      twitter-color-emoji
      font-awesome
    ];
    fontconfig = {
      defaultFonts = {
        monospace = [ "JetBrainsMono Nerd Font" ];
        sansSerif = [ "Roboto" ];
        serif     = [ "Roboto" ];
        emoji     = [ "Twitter Color Emoji" ];
      };
    };
  };
}
#+end_src

**** Applications
***** Common

#+begin_src nix :tangle modules/applications/default.nix
{ ... }:

{
  imports = [
    ./firejail.nix
    ./flatpak.nix
    ./media.nix
    ./zathura.nix
    ./calibre.nix
  ];
}

#+end_src
***** Firejail
#+begin_src nix :tangle modules/applications/firejail.nix
{ pkgs, lib, ... }:

{
  programs.firejail.enable = true;
  programs.firejail.wrappedBinaries = {
    thunderbird = {
      executable = "${lib.getBin pkgs.thunderbird}/bin/thunderbird";
      profile = "${pkgs.firejail}/etc/firejail/thunderbird.profile";
    };
    telegram-desktop = {
      executable = "${lib.getBin pkgs.tdesktop}/bin/telegram-desktop";
      profile = "${pkgs.firejail}/etc/firejail/telegram.profile";
    };
  };
  # Firejail-specific desktop shortcuts
  home-manager.users.spacecadet = { pkgs, ... }: {
    xdg.desktopEntries = {
      thunderbird = {
        # Taken from Thunderbird v 91.5.0
        name = "Thunderbird";
        comment = "ðŸ¦ŠFirejailed";
        genericName = "Mail Client";
        exec = "thunderbird %U";
        icon = "thunderbird";
        terminal = false;
        mimeType = [ "text/html" "text/xml" "application/xhtml+xml" "application/vnd.mozilla.xul+xml" "x-scheme-handler/http" "x-scheme-handler/https" "x-scheme-handler/ftp" ];
      };
      telegram = {
        # Taken from Telegram v 3.1.11
        name = "Telegram";
        comment = "ðŸ¦ŠFirejailed";
        exec = "telegram-desktop -- %u";
        icon = "telegram";
        terminal = false;
        mimeType = [ "x-scheme-handler/tg" ];
      };
    };
  };
}
#+end_src

****** TODO Fix the icons :fix:
***** Flatpak

#+begin_src nix :tangle modules/applications/flatpak.nix
{ ... }:

{
  services.flatpak.enable = true;
  xdg.portal.enable = true;
}

#+end_src
***** Media
#+begin_src nix :tangle modules/applications/media.nix
{ pkgs, ... }:

{
  environment.systemPackages = with pkgs; [
    # Video
    yt-dlp mpv
  ];
  # Configuration files
  environment.etc = {
    # judging by strace, mpv on NixOS expects it in etc.
    "mpv/mpv.conf".text = ''
      hwdec
      save-position-on-quit
    '';
    "mpv/input.conf".text = ''
      WHEEL_UP add volume 5
      # mouse wheel for sound control
      WHEEL_DOWN add volume -5
    '';
  };
}
#+end_src
***** Kitty
#+begin_src nix :tangle modules/applications/kitty.nix
# Home manager module to configure Kitty
{ pkgs, ... }:

{
  programs.kitty = {
    enable = true;
    # theme = "Neopolitan";
    theme = "Doom Vibrant";
    settings = {
      cursor_blink_interval = 0;
      background_opacity = "0.95";
      inactive_text_alpha = "0.85";
      cursor = "none";
      enable_audio_bell = false;
      tab_bar_margin_width = 9;
      tab_bar_margin_height = "2 2";
      tab_bar_style = "separator";
      tab_bar_min_tabs = 2;
      tab_bar_edge = "bottom";
      tab_title_template = "{fmt.fg.white} {title.split()[0]} ";
      active_tab_title_template = "{fmt.noitalic}{fmt.bg.black}{fmt.fg.white} {title.split()[0]} ";
    };
    keybindings = {
      # Opens a new Kitty window in the current working directory
      "kitty_mod+enter" = "launch --cwd=current";
    };
  };
}
#+end_src
***** Zathura
#+begin_src nix :tangle modules/applications/zathura.nix
{ ... }:

{
  home-manager.users.spacecadet = { ... }: {
    programs.zathura = {
    enable = true;
    options = {
      # Allows zathura to use system clipboard
      selection-clipboard = "clipboard";
    };
    };
  };
}
#+end_src
***** Calibre

#+begin_src nix :tangle modules/applications/calibre.nix
{ pkgs, ... }:
{
  home-manager.users.spacecadet = { ... }: {
      home.packages = [ pkgs.calibre ];
    };
}
#+end_src

****** CNCL Add mountpoint for the device :feat:
CLOSED: [2023-03-01 Wed 08:22]
***** TODO Firefox
**** Development -- for development purposes

***** Default

By default, only editor and git should be imported. The rest of the configs are imported on per-host basis.

#+begin_src nix :tangle modules/development/default.nix
{ ... }:

{
  imports = [
    ./editor.nix
    ./git.nix
  ];
}
#+end_src
***** Git config
First, the git config

#+begin_src nix :tangle modules/development/git.nix
{ pkgs, ... }:
{
  environment.systemPackages = with pkgs; [
    git
    lazygit
    git-crypt
  ];
  programs.git = {
    enable = true;
    config = {
      user = {
        name = "Vladimir Timofeenko";
        email = "id@vtimofeenko.com";
      };
      alias = {
        ci = "commit";
        st = "status";
        co = "checkout";
        rv = "remote --verbose";
        unstage = "reset HEAD --";
      };
      url = {
        "https://github.com/" = {
          insteadOf = [
            "gh:"
            "github:"
          ];
        };
      };
    };
  };
}
#+end_src


***** Console editor

I generally use emacs, but when in console - I use a build of neovim that's provided as an input:

#+begin_src nix :tangle modules/development/editor.nix
{ pkgs, config, ... }:

{
  # environment.systemPackages = [ pkgs.my_nvim ];
  environment.variables.SUDO_EDITOR = "nvim";
  environment.variables.EDITOR = "nvim";
}
#+end_src

***** Virtualization
I occasionally need full blown VMs to emulate stuff:

#+begin_src nix :tangle modules/development/virtualization.nix
{ pkgs, ... }:

{
  virtualisation.libvirtd.enable = true;
  programs.dconf.enable = true;
  environment.systemPackages = with pkgs; [ virt-manager ];
  users.users.spacecadet.extraGroups = [ "libvirtd" ];
}
#+end_src

***** Cross compilation

#+begin_src nix :tangle modules/development/cross-compile.nix
{ ... }:
{
  boot.binfmt.emulatedSystems = [ "aarch64-linux" ];
}
#+end_src

**** Hardware -- specific hardware modules support/config
***** Disks
:PROPERTIES:
:header-args:nix: :tangle modules/hardware/disks.nix
:END:

#+begin_src nix
{ pkgs, ... }:

{
#+end_src

Since I am running on SSDs, worth enabling timed fstrim:

#+begin_src nix
  services.fstrim.enable = true;
#+end_src

I like having a temporary directory  that is separate from ~/tmp~ for random things I don't need to keep around. It can live in ~/scratch~:

#+begin_src nix
  systemd.tmpfiles.rules =
    [
      "d /scratch 1777 spacecadet users 10d"
    ];
#+end_src


#+begin_src nix
}
#+end_src
***** Scanner

#+begin_src nix :tangle modules/hardware/scanner.nix
{ pkgs, ... }:

{
  hardware.sane.enable = true;
  hardware.sane.extraBackends = [ pkgs.hplipWithPlugin ];
  services.avahi.enable = true;
  services.avahi.nssmdns = true;
  users.users.spacecadet.extraGroups = [ "scanner" ];
}
#+end_src
***** Printer

#+begin_src nix :tangle modules/hardware/printer.nix
{ pkgs, ... }:
{
  services.printing.enable = true;
  services.printing.drivers = [ pkgs.hplipWithPlugin ];
}
#+end_src
***** Dygma

#+begin_src nix :tangle modules/hardware/dygma.nix
{ lib, pkgs, ... }:

{
  # Taken from https://github.com/Dygmalab/Bazecor/blob/159eed1d37f3fd1fbf5c17023c12bb683b778281/src/main/index.js#L223
  services.udev.extraRules = ''
    SUBSYSTEMS=="usb", ATTRS{idVendor}=="1209", ATTRS{idProduct}=="2201", GROUP="users", MODE="0666"
    SUBSYSTEMS=="usb", ATTRS{idVendor}=="1209", ATTRS{idProduct}=="2200", GROUP="users", MODE="0666"
  '';
}
#+end_src

****** TODO Add the configurator utility - either firejailed appimage or flatpak :feat:


**** Network -- reusable network configurations

Common network settings:

#+begin_src nix :tangle modules/network/common_lan.nix
{ lib, infra, ...  }:
let
  infraMetadata = lib.importTOML (infra + "/infra.toml");
  inherit (infraMetadata.network) lan;
in
{
  networking.enableIPv6 = false;
}
#+end_src

#+begin_src nix :tangle modules/network/lan-wifi.nix
{ config, lib, infra, private-config, ... }:
let
  infraMetadata = lib.importTOML (infra + "/infra.toml");
  inherit (infraMetadata.network) lan;
  local_address = lan.first_octets + "." + lan."${config.networking.hostName}".ip;
in
{
  imports = [
    private-config.nixosModules.home-wireless-fast-client
    # NOTE: should be kept commented until I need it
    # private-config.nixosModules.phone-shared-network
  ];
  # Disable autogenerated names
  networking.usePredictableInterfaceNames = false;

  # networking.interfaces.wifi-lan = {
  #   useDHCP = false;
  #   ipv4.addresses = [
  #     {
  #       address = local_address;
  #       prefixLength = lan.prefix;
  #     }
  #   ];
  # };
  # Systemd-networkd enabled
  networking.useNetworkd = true;

  systemd.network.networks = {
    "10-wifi-lan" = {
      enable = true;
      name = "wifi-lan";
      dns = lan.dns_servers;
      address = [ local_address ];
      gateway = [ lan.defaultGateway ];
      # Search domain goes here
      domains = [ lan.domain ];
      networkConfig = {
        DHCP = "no";
        DNSSEC = "yes";
        DNSOverTLS = "no";
        # Disable ipv6 explicitly
        LinkLocalAddressing = "ipv4";
      };
    };
  };
  # I am not using llmnr in my LAN
  services.resolved.llmnr = "false";

  # Any interface being up should be OK
  systemd.network.wait-online.anyInterface = true;
}
#+end_src

***** TODO generate routing table here :feat:

**** Zsh

***** README

#+begin_src md :tangle README.md
### ZSH module

#### Usage

To use this module separately from `default` one:

```nix
{
    outputs = inputs@{ ... }:
    {
        nixosConfigurations.machine-name = nixpkgs.lib.nixosSystem {
            # ...
            modules =
            [
                inputs.monorepo.nixosModules.zsh
                {
                    programs.vt-zsh =
                        {
                            starship_enable = true;
                            direnv_enable = true;
                        };
                }
            ];
        };
    };
}
```

and set the users' shells to zsh.

#### Screenshot

A screenshot showing open shell in the root of this project:

![](.assets/zsh-screenshot.png)

#### High-level features description

1. (optionally) uses [starship](https://starship.rs/) to set up the prompt
2. Highlights syntax in command line
3. Automatically suggests command from history
4. Shares history between currently running sessions
5. (optionally) uses gpg-agent for ssh authentication
6. (optionally) sets up [direnv](https://direnv.net/). ~.direnv~ can immediately create a Nix developemnt shell from a local flake.nix if it contains ~use flake~.
7. Allows editing the current command in $EDITOR by hitting ESC and E: [01-vim-edit](./modules/zsh/plugins/01-vim-edit.zsh)
8. Sets up simple way to change directory through stack of last visited dirs (`cd +1`, `+2`, `+3`, ...): [02-cd](./modules/zsh/plugins/02-cd.zsh)
9. Creates a mechanism to use bookmarks by using double @ symbol: bookmarks: [bookmarks](./modules/zsh/plugins/bookmarks.zsh)
10. Depending on the mode (typing vs editing in vim), shape of the cursor changes: [cursor_mode](./modules/zsh/plugins/cursor_mode.zsh)

For more details, see "*ZSH*" heading in `project.org`.

#+end_src

***** Main configuration

I am sharing my zsh config with several machines and users. Certain settings of my zsh config can be turned on and off in the importing config:

#+begin_src nix :tangle modules/zsh/default.nix
{ lib, pkgs, config, ... }:

with lib;
let
  cfg = config.programs.vt-zsh;
in
{
  options.programs.vt-zsh = {
    starship_enable = mkOption {
      default = true;
      description = "Whether to enable starship.";
      type = lib.types.bool;
    };
    direnv_enable = mkEnableOption "enable direnv";
    gpg_enable = mkEnableOption "enable gpg-agent";
    enableAnyNixShell = mkEnableOption "enable any-nix-shell";
  };
#+end_src

First, some packages that I am using on all machines. Direnv is included conditionally since I need to run it interactively (~direnv allow .~).

#+begin_src nix :tangle modules/zsh/default.nix
  config = {
    environment.systemPackages = with pkgs; [
      fzf
      killall
      bat
      # the next line conditionally installs direnv if it is enabled
      # just having pkgs.direnv is not enough, it does not get added to the path
    ] ++ (if cfg.direnv_enable then [ pkgs.direnv ] else [ ]);
#+end_src

The actual zsh configuration happens in ~programs.zsh~ attrset.

#+begin_src nix :tangle modules/zsh/default.nix
    programs.zsh = {
      enable = true;
      enableCompletion = true;
      autosuggestions.enable = true;
      syntaxHighlighting = {
        enable = true;
      };
      shellAliases = {
        e = "$EDITOR"; # looks like 'vim' is needed here so that proper vimrc is being picked up
        nvim = "$EDITOR";
        vim = "$EDITOR";
        ls = "${pkgs.exa}/bin/exa -h --group-directories-first --icons";
        l = "ls";
        ll = "ls -l";
        la = "ls -al";
        ka = "${pkgs.killall}/bin/killall";
        mkd = "mkdir -pv";
        ga = "${pkgs.git}/bin/git add";
        gau = "ga -u";
        grep = "grep --color=auto";
        mv = "mv -v";
        rm = "${pkgs.coreutils}/bin/rm -id";
        vidir = "${pkgs.moreutils}/bin/vidir --verbose";
        ccopy = "${pkgs.wl-clipboard}/bin/wl-copy";
        syu = "systemctl --user";
        cde = "cd /etc/nixos";
        lg = "${pkgs.lazygit}/bin/lazygit";
        # Colorize IP output
        ip = "ip -c";
      };
      setOptions = [
        "INTERACTIVE_COMMENTS" # allow bash-style comments
        # history
        "BANG_HIST" # enable logging !!-like commands
        "EXTENDED_HISTORY" # Write the history file in the ":start:elapsed;command" format.
        "INC_APPEND_HISTORY" # Write to the history file immediately, not when the shell exits.
        "SHARE_HISTORY" # Share history between all sessions.
        "HIST_EXPIRE_DUPS_FIRST" # Expire duplicate entries first when trimming history.
        "HIST_IGNORE_DUPS" # Don't record an entry that was just recorded again.
        "HIST_IGNORE_ALL_DUPS" # Delete old recorded entry if new entry is a duplicate.
        "HIST_FIND_NO_DUPS" # Do not display a line previously found.
        "HIST_IGNORE_SPACE" # Don't record an entry starting with a space.
        "HIST_SAVE_NO_DUPS" # Don't write duplicate entries in the history file.
        "HIST_REDUCE_BLANKS" # Remove superfluous blanks before recording entry.
        "HIST_VERIFY" # Don't execute immediately upon history expansion.
        "HIST_FCNTL_LOCK" # enable fcntl syscall for saving history
        # cd management
        "AUTO_CD" # automatically cd into directory
      ];
      interactiveShellInit =
        ''
        # Enable vim editing of command line
        ${builtins.readFile ./plugins/01-vim-edit.zsh}
        # Enable cd +1..9 to go back in dir stack
        ${builtins.readFile ./plugins/02-cd.zsh}
        # fzf bindings
        source ${pkgs.fzf}/share/fzf/key-bindings.zsh

        # Word Navigation shortcuts
        bindkey "^A" vi-beginning-of-line
        bindkey "^E" vi-end-of-line
        bindkey "^F" end-of-line

        # ctrl+arrow for word jupming
        bindkey "^[[1;5C" forward-word
        bindkey "^[[1;5D" backward-word

        # alt+f forward a word
        bindkey "^[f" forward-word

        # alt+b back a word
        bindkey "^[b" backward-word
        # working backspace
        bindkey -v '^?' backward-delete-char

        # Use vim keys in tab complete menu
        zmodload zsh/complist
        bindkey -M menuselect 'h' vi-backward-char
        bindkey -M menuselect 'k' vi-up-line-or-history
        bindkey -M menuselect 'l' vi-forward-char
        bindkey -M menuselect 'j' vi-down-line-or-history
        bindkey -M menuselect '^ ' accept-line

        # Add entry by "+" but do not exit menuselect
        bindkey -M menuselect "+" accept-and-menu-complete
        # Color the completions
        autoload -Uz compinit
        zstyle ':completion:*' matcher-list 'm:{[:lower:][:upper:]}={[:upper:][:lower:]}' 'm:{[:lower:][:upper:]}={[:upper:][:lower:]} l:|=* r:|=*' 'm:{[:lower:][:upper:]}={[:upper:][:lower:]} l:|=* r:|=*' 'm:{[:lower:][:upper:]}={[:upper:][:lower:]} l:|=* r:|=*'
        zstyle ':completion:*' list-colors ''${(s.:.)LS_COLORS}
        zstyle ':completion:*' menu select

        # Automatically escape urls when pasting
        autoload -Uz url-quote-magic
        zle -N self-insert url-quote-magic
        autoload -Uz bracketed-paste-magic
        zle -N bracketed-paste bracketed-paste-magic

        # Custom plugins can be quickly loaded if fpath is extended:
        fpath=(${./plugins} $fpath)
        # Bookmarks by "@@"
        autoload -Uz bookmarks.zsh && bookmarks.zsh
        # Cursor mode block <> beam
        autoload -Uz cursor_mode.zsh && cursor_mode.zsh

        # To use openpgp cards
        ${if cfg.gpg_enable
        then
          ''
          if (( $EUID != 0 )); then
            export GPG_TTY="$(tty)"
            ${pkgs.gnupg}/bin/gpg-connect-agent /bye
            export SSH_AUTH_SOCK="/run/user/$UID/gnupg/S.gpg-agent.ssh"
          fi
          ''
        else
          toString null
        }
        # alias that creates the directory and changes into it
        mkcd(){ mkdir -p "$@" && cd "$@"; }
      '';
      promptInit = ''
        ${if cfg.starship_enable
        then
          "eval \"$(${pkgs.starship}/bin/starship init zsh)\""
        else
          # reasonable default prompt
          "PROMPT=\"%F{white}%~ %(!.%B%F{red}#.%B%F{blue}>)%f%b\u00A0\""
        }
        ${if cfg.direnv_enable
        then
          "eval \"$(${pkgs.direnv}/bin/direnv hook zsh)\""
        else
          toString null
        }
        ${if cfg.enableAnyNixShell
          then
            "${pkgs.any-nix-shell}/bin/any-nix-shell zsh --info-right | source /dev/stdin"
          else
            toString null
         }
        # Make comments visible on default background
        ZSH_HIGHLIGHT_STYLES[comment]='none'
      '';
    };
  };
}
#+end_src

****** TODO See if rm -i alias can be adjusted not to display the full rm path :feat:

***** ZSH modules

****** 01-vim-edit

#+begin_src sh :tangle modules/zsh/plugins/01-vim-edit.zsh
# vim style editing
bindkey -v

autoload edit-command-line; zle -N edit-command-line
bindkey -M vicmd jk edit-command-line  # jk chord to edit the current line
#+end_src

****** 02-cd

#+begin_src sh :tangle modules/zsh/plugins/02-cd.zsh
# File that sets the behavior of cd command
setopt autocd

# dirs stack manipulation
setopt AUTO_PUSHD           # Push the current directory visited on the stack.
setopt PUSHD_IGNORE_DUPS    # Do not store duplicates in the stack.
setopt PUSHD_SILENT         # Do not print the directory stack after

# Enabled cd +X to change directory to somewhere in stack
alias d='dirs -v' # prints stack of directories
for index ({1..9}) alias "$index"="cd +${index}"; unset index
#+end_src

****** bookmarks

#+begin_src sh :tangle modules/zsh/plugins/bookmarks.zsh
# -*- sh -*-
autoload is-at-least
# Source: https://github.com/vincentbernat/zshrc/blob/master/rc/bookmarks.zsh
# Changed by Vladimir Timofeenko, changed MARKPATH to local share for persistence

# Handle bookmarks. This uses the static named directories feature of
# zsh. Such directories are declared with `hash -d
# name=directory`. Both prompt expansion and completion know how to
# handle them. We populate the hash with directories.
#
# With autocd, you can just type `~-bookmark`. Since this can be
# cumbersome to type, you can also type `@@` and this will be turned
# into `~-` by ZLE.

is-at-least 4.3.12 && () {
    MARKPATH="${HOME}/.local/share/zsh/bookmarks"

    # Add some static entries
    hash -d log=/var/log
    hash -d doc=/usr/share/doc

    # Populate the hash
    for link ($MARKPATH/*(N@)) {
        hash -d -- -${link:t}=${link:A}
    }

    vbe-insert-bookmark() {
        emulate -L zsh
        LBUFFER=${LBUFFER}"~-"
    }
    zle -N vbe-insert-bookmark
    bindkey '@@' vbe-insert-bookmark

    # Manage bookmarks
    bookmark() {
        [[ -d $MARKPATH ]] || mkdir -p $MARKPATH
        if (( $# == 0 )); then
            # When no arguments are provided, just display existing
            # bookmarks
            for link in $MARKPATH/*(N@); do
                local markname=${(%):-%F{green}${link:t}%f}
                local markpath=${(%):-%F{blue}${link:A}%f}
                printf "%-30s â†’ %s\n" $markname $markpath
            done
        else
            # Otherwise, we may want to add a bookmark or delete an
            # existing one.
            local -a delete
            zparseopts -D d=delete
            if (( $+delete[1] )); then
                # With `-d`, we delete an existing bookmark
                command rm $MARKPATH/$1
            else
                # Otherwise, add a bookmark to the current
                # directory. The first argument is the bookmark
                # name. `.` is special and means the bookmark should
                # be named after the current directory.
                local name=$1
                [[ $name == "." ]] && name=${PWD:t}
                ln -s $PWD $MARKPATH/$name
                hash -d -- -${name}=${PWD}
            fi
        fi
    }
}
#+end_src

****** cursor_mode

#+begin_src sh :tangle modules/zsh/plugins/cursor_mode.zsh
cursor_mode() {
    # See https://ttssh2.osdn.jp/manual/4/en/usage/tips/vim.html for cursor shapes
    cursor_block='\e[2 q'

    cursor_beam='\e[6 q'

    function zle-keymap-select {
        if [[ ${KEYMAP} == vicmd ]] ||
            [[ $1 = 'block' ]]; then
            echo -ne $cursor_block
        elif [[ ${KEYMAP} == main ]] ||
            [[ ${KEYMAP} == viins ]] ||
            [[ ${KEYMAP} = '' ]] ||
            [[ $1 = 'beam' ]]; then
            echo -ne $cursor_beam
        fi
    }

    zle-line-init() {
        echo -ne $cursor_beam
    }

    zle -N zle-keymap-select
    zle -N zle-line-init
}

cursor_mode
#+end_src

****** TODO make a minimalistic vim config to edit the shell inline :feat:
- vim-surround
- shell syntax highlighting

***** TODO Rewrite in literal style :doc:

***** TODO alias where to "wh" to fzf find a binary :feat:

***** DONE Correct the options to use something like ~programs.vt-zsh~ :chore:
CLOSED: [2022-12-25 Sun 19:25]

***** DONE disable gpg if root? :chore:
CLOSED: [2023-02-08 Wed 08:20]

***** DONE Add any-nix-shell :feat:
CLOSED: [2023-02-08 Wed 08:25]
***** DONE Add bat :feat:
CLOSED: [2023-02-08 Wed 08:16]
***** DONE Add killall with an alias :feat:
CLOSED: [2023-02-08 Wed 08:12]

**** Sway

[[https://github.com/VTimofeenko/sway-flake][Original source]]

The sway config has two parts -- the system-wide (greeter and global configuration, implemented using standard nixpkgs settings) and the user-specific (window manager itself, implemented through home-manager)

***** STRT Plan [4/8]
- [X] System-wide settings
- [X] Base settings
- [X] Greeter
  - [X] Write
  - [X] Deploy with zsh
  - [X] Evaluate
- [X] Home-specific settings
- [ ] Replace greeter zsh with sway
- [ ] Xremap base config
- [ ] Revisit packages installed through [home|environment]Packages and see if they can be configured through flake
- [ ] Reusable and centralized keyboard shortcuts

***** System-wide configuration

#+begin_src nix :tangle modules/sway/system/default.nix
{ pkgs, ... }:
{
  imports =
    [
      # ./base-settings.nix
      ./greeter.nix
      ./hyprland.nix
      # ./additional-packages.nix
      # TODO: xremap also goes here
    ];
}
#+end_src

****** Base settings

#+begin_src nix :tangle modules/sway/system/base-settings.nix
{ pkgs, ... }:
{
#+end_src

Despite the fact that sway will be configured through home-manager's options, the [[https://github.com/NixOS/nixpkgs/blob/nixos-22.11/nixos/modules/programs/sway.nix][sway module]] enabled by ~programs.sway.enable~ enables some default configurations.

#+begin_src nix :tangle modules/sway/system/base-settings.nix
  programs.sway.enable = true;
#+end_src

Certain programs (flameshot) also require specific configurations of ~xdg.portal~:

#+begin_src nix :tangle modules/sway/system/base-settings.nix
  xdg.portal =
        {
          enable = true;
          wlr.enable = true;
          extraPortals = [ pkgs.xdg-desktop-portal-gtk ];
        };

#+end_src

#+begin_src nix :tangle modules/sway/system/base-settings.nix
}
#+end_src

****** Hyprland settings

#+begin_src nix :tangle modules/sway/system/hyprland.nix
{ config, pkgs, lib, ...}:
{
  programs.hyprland = {
    enable = true;
    xwayland = {
      enable = true;
      hidpi = true;
    };
    nvidiaPatches = false;
  };
  # NOTE: needed for swaylock
  security.pam.services.swaylock.text =
    ''
      # Account management.
      account required pam_unix.so

      # Authentication management.
      auth sufficient pam_unix.so   likeauth try_first_pass
      auth required pam_deny.so

      # Password management.
      password sufficient pam_unix.so nullok sha512

      # Session management.
      session required pam_env.so conffile=/etc/pam/environment readenv=0
      session required pam_unix.so
    '';
  environment.systemPackages =
    with pkgs; [
      # needed because the user config references /etc stuff
      swaynotificationcenter
    ];
}
#+end_src

#+begin_src nix :tangle modules/hyprland/default.nix
{ config, pkgs, lib, ...  }:
let
  # Custom lib.nix for module-specific logic
  modLib = import ./lib.nix;

  cliphist = "${pkgs.cliphist}/bin/cliphist";

  launchShortcuts =
    {
       "Return" = "exec, ${pkgs.kitty}/bin/kitty";
       "E" = "exec, ${pkgs.libsForQt5.dolphin}/bin/dolphin";
       # Launches wofi with icons
       "R" = "exec, ${pkgs.wofi}/bin/wofi --show drun -I";
    };
  focusShortcuts =
    {
       "H" = "movefocus, l";
       "L" = "movefocus, r";
       "K" = "movefocus, u";
       "J" = "movefocus, d";
    };
  mergedConfig = builtins.concatStringsSep
    "\n"
    (
      builtins.attrValues
        (
           builtins.mapAttrs
             modLib.mkMainModBinding
             launchShortcuts
      )
    );

in
{
  imports =
    [
      ./notifications
      ./eww
    ];
  wayland.windowManager.hyprland =
    {
      enable = true;
      systemdIntegration = true;
      xwayland = {
        enable = true;
        hidpi = true;
      };
      nvidiaPatches = true;
      extraConfig =
        ''
          env = LIBVA_DRIVER_NAME,nvidia
          env = XDG_SESSION_TYPE,wayland
          env = GBM_BACKEND,nvidia-drm
          env = __GLX_VENDOR_LIBRARY_NAME,nvidia
          env = WLR_NO_HARDWARE_CURSORS,1

          # Some default env vars.
          env = XCURSOR_SIZE,24

          exec-once = systemd-cat --identifier=swaync ${pkgs.swaynotificationcenter}/bin/swaync
          # Clipboard manager
          exec-once = ${pkgs.wl-clipboard}/bin/wl-paste --watch ${cliphist} store

          # For all categories, see https://wiki.hyprland.org/Configuring/Variables/
          input {
              kb_layout = us,ru
              kb_options = grp:win_space_toggle

              follow_mouse = 1

              touchpad {
                  natural_scroll = false
                  disable_while_typing = true
              }

              sensitivity = 0 # -1.0 - 1.0, 0 means no modification.
          }

          general {
              # See https://wiki.hyprland.org/Configuring/Variables/ for more

              gaps_in = 5
              gaps_out = 20
              border_size = 2
              col.active_border = rgba(33ccffee) rgba(00ff99ee) 45deg
              col.inactive_border = rgba(595959aa)

              layout = dwindle
          }

          decoration {
              # See https://wiki.hyprland.org/Configuring/Variables/ for more

              rounding = 10
              blur = true
              blur_size = 3
              blur_passes = 1
              blur_new_optimizations = true

              drop_shadow = true
              shadow_range = 4
              shadow_render_power = 3
              col.shadow = rgba(1a1a1aee)
          }

          windowrulev2 = opacity 0.94 0.94,class:^(kitty)$

          animations {
              enabled = true

              # Some default animations, see https://wiki.hyprland.org/Configuring/Animations/ for more

              bezier = myBezier, 0.05, 0.9, 0.1, 1.05

              animation = windows, 1, 7, myBezier
              animation = windowsOut, 1, 7, default, popin 80%
              animation = border, 1, 10, default
              animation = borderangle, 1, 8, default
              animation = fade, 1, 7, default
              animation = workspaces, 1, 6, default
          }

          dwindle {
              # See https://wiki.hyprland.org/Configuring/Dwindle-Layout/ for more
              pseudotile = true # master switch for pseudotiling. Enabling is bound to mainMod + P in the keybinds section below
              preserve_split = true # you probably want this
          }

          master {
              # See https://wiki.hyprland.org/Configuring/Master-Layout/ for more
              new_is_master = true
          }

          gestures {
              workspace_swipe = true
          }

          binds {
              # TODO: Not sure
              pass_mouse_when_bound = true
              workspace_back_and_forth = true
              allow_workspace_cycles = true  # This is needed for workspace_back_and_forth behavior to be similar to sway
          }

          # Example windowrule v1
          # windowrule = float, ^(kitty)$
          # Example windowrule v2
          # windowrulev2 = float,class:^(kitty)$,title:^(kitty)$
          # See https://wiki.hyprland.org/Configuring/Window-Rules/ for more


          # See https://wiki.hyprland.org/Configuring/Keywords/ for more
          $mainMod = SUPER

          # Move focus with mainMod + arrow keys
          bind = $mainMod, H, movefocus, l
          bind = $mainMod, L, movefocus, r
          bind = $mainMod, K, movefocus, u
          bind = $mainMod, J, movefocus, d

          # Move current window to target split area
          bind = $mainMod SHIFT, H, movewindow, l
          bind = $mainMod SHIFT, L, movewindow, r
          bind = $mainMod SHIFT, K, movewindow, u
          bind = $mainMod SHIFT, J, movewindow, d

          # Switch workspaces with mainMod + [0-9]
          bind = $mainMod, 1, workspace, 1
          bind = $mainMod, 2, workspace, 2
          bind = $mainMod, 3, workspace, 3
          bind = $mainMod, 4, workspace, 4
          bind = $mainMod, 5, workspace, 5
          bind = $mainMod, 6, workspace, 6
          bind = $mainMod, 7, workspace, 7
          bind = $mainMod, 8, workspace, 8
          bind = $mainMod, 9, workspace, 9
          bind = $mainMod, grave, workspace, previous

          # Move active window to a workspace with mainMod + SHIFT + [0-9]
          bind = $mainMod SHIFT, 1, movetoworkspacesilent, 1
          bind = $mainMod SHIFT, 2, movetoworkspacesilent, 2
          bind = $mainMod SHIFT, 3, movetoworkspacesilent, 3
          bind = $mainMod SHIFT, 4, movetoworkspacesilent, 4
          bind = $mainMod SHIFT, 5, movetoworkspacesilent, 5
          bind = $mainMod SHIFT, 6, movetoworkspacesilent, 6
          bind = $mainMod SHIFT, 7, movetoworkspacesilent, 7
          bind = $mainMod SHIFT, 8, movetoworkspacesilent, 8
          bind = $mainMod SHIFT, 9, movetoworkspacesilent, 9

          # Scroll through existing workspaces with mainMod + scroll
          bind = $mainMod, mouse_down, workspace, e+1
          bind = $mainMod, mouse_up, workspace, e-1

          # Move/resize windows with mainMod + LMB/RMB and dragging
          bindm = $mainMod, mouse:272, movewindow
          bindm = $mainMod, mouse:273, resizewindow

          bind = $mainMod SHIFT, T, togglefloating
          bind = $mainMod SHIFT, Q, killactive
          bind = $mainMod, F, fullscreen  # Fullscreen
          bind = $mainMod, O, fullscreen, 1  # fOcus

          bind = $mainMod CTRL, Q, exec, ${pkgs.swaylock}/bin/swaylock -fF -k -c 000000
          bind = $mainMod CTRL, M, exit,
          # Toggle notification pane
          bind = $mainMod CTRL, N, exec, ${pkgs.swaynotificationcenter}/bin/swaync-client -t -sw
          # Clipboard history toggle
          bind = $mainMod CTRL, C, exec, ${cliphist} list | ${pkgs.wofi}/bin/wofi --show dmenu | ${cliphist} decode | ${pkgs.wl-clipboard}/bin/wl-copy
        '' + mergedConfig;
    };
}
#+end_src

A bag of objects to help with the main config generation:

#+begin_src nix :tangle modules/hyprland/lib.nix
rec {
  shift = "SHIFT";
  ctrl = "CTRL";
  alt = "ALT";
  _mkBinding = mods: k: v: "bind = ${mods}, ${k}, ${v}";
  mkMainModBinding = _mkBinding "$mainMod";
  mkMainModShiftBinding = _mkBinding "$mainMod ${shift}";
  mkMainModCtrlBinding = _mkBinding "$mainMod ${ctrl}";
  mkMainModAltBinding = _mkBinding "$mainMod ${ctrl}";
}
#+end_src

******* STRT Hyprland Plan
- [X] Variables setup
- [X] Base hotkeys setup
- [X] Fix suspend
- [-] Pick out new notification/clipboard/whatever tools
  - [X] notification
  - [X] Clipboard
  - [ ] EWW
- [ ] Check out [[https://wiki.hyprland.org/Configuring/Example-configurations/][examples]]
- [ ] Move to different section in literate config

******* Notification daemon

#+begin_src nix :tangle modules/hyprland/notifications/default.nix
{ pkgs, ... }:
{
  xdg.configFile."/swaync/config.json".text =
    # Taken from swaync 0.8.0
    ''
      {
        "$schema": "/etc/xdg/swaync/configSchema.json",
        "positionX": "right",
        "positionY": "top",
        "layer": "top",
        "cssPriority": "application",
        "control-center-margin-top": 0,
        "control-center-margin-bottom": 0,
        "control-center-margin-right": 0,
        "control-center-margin-left": 0,
        "notification-icon-size": 64,
        "notification-body-image-height": 100,
        "notification-body-image-width": 200,
        "timeout": 10,
        "timeout-low": 5,
        "timeout-critical": 0,
        "fit-to-screen": true,
        "control-center-width": 500,
        "control-center-height": 600,
        "notification-window-width": 500,
        "keyboard-shortcuts": true,
        "image-visibility": "when-available",
        "transition-time": 200,
        "hide-on-clear": false,
        "hide-on-action": true,
        "script-fail-notify": true,
        "scripts": {
          "example-script": {
            "exec": "echo 'Do something...'",
            "urgency": "Normal"
          },
          "example-action-script": {
            "exec": "echo 'Do something actionable!'",
            "urgency": "Normal",
            "run-on": "action"
          }
        },
        "notification-visibility": {
          "example-name": {
            "state": "muted",
            "urgency": "Low",
            "app-name": "Spotify"
          }
        },
        "widgets": [
          "inhibitors",
          "title",
          "dnd",
          "notifications"
        ],
        "widget-config": {
          "inhibitors": {
            "text": "Inhibitors",
            "button-text": "Clear All",
            "clear-all-button": true
          },
          "title": {
            "text": "Notifications",
            "clear-all-button": true,
            "button-text": "Clear All"
          },
          "dnd": {
            "text": "Do Not Disturb"
          },
          "label": {
            "max-lines": 5,
            "text": "Label Text"
          },
          "mpris": {
            "image-size": 96,
            "image-radius": 12
          }
        }
      }
    ''
  ;
}
#+end_src


******* EWW -- Widgets

#+begin_src nix :tangle modules/hyprland/eww/default.nix
{ pkgs, config, lib, ... }:
let
  eww-yuck =
      ''
  (defwindow example
           :monitor 0
           :geometry (geometry
                               :width "100%"
                               :height "1%"
                               :anchor "top center"
                     )
           :exclusive true	
           :stacking "fg"
           (button :class "tray" :halign "end" "''${time}")
  )

  (defpoll time :interval "20s"
	`date +" %b %d %R"`)
      '';
  
  
  eww-scss =
    ''
    '';
in
{
  # Generating the module dynamically => not using home manager module
  home.packages = [ pkgs.eww-wayland ];
  xdg.configFile =
    {
      "eww/eww.yuck".text = eww-yuck;
      "eww/eww.scss".text = eww-scss;
    };
}
#+end_src

******* Wofi

#+begin_src nix :tangle modules/hyprland/wofi/default.nix
{ pkgs, config, lib, ... }:
{
  programs.wofi =
    {
      enable = true;
    };
}

#+end_src

******** TODO Style wofi :feat:

******* TODO Restore swaylock pam.d config need


******* TODO Global "hyper+e" = emacs

******* TODO Add notification to language switch setup

******* TODO Global "hyper-b" = browser

******* TODO focus mode_toggle to switch focus between floating windows and tiled ones

******* TODO consider super+ctrl+grave for terminal

#+begin_src
bind = $mainMod, grave , exec , [ float  ; size 60% 50% ] ${pkgs.kitty}/bin/kitty

original:
bindsym Mod4+Shift+Return exec --no-startup-id scratchpad-terminal kitty "scratchpad_term"
for_window [title="scratchpad_term"] floating enable, move scratchpad

#+end_src

Needs special workspace tho


******* TODO Port over F-and-XF86-whatever bindings

- [ ] Sound control
- [ ] Brightnessctl

******* TODO port over sound control mode

******* TODO port over workspace edit/renumber/rename mode

******* TODO Port over the resize mode

******* TODO Port the shutdown mode

******* TODO Consider a new launcher

******* TODO Fix the xremap ordering for hyprland

******* TODO Custom tools [0/3]

******** TODO Scratchpad terminal

******** TODO Workspace renamer

******** TODO Workspace renumber

******* TODO Colorscheme

******* TODO Check out [[https://github.com/Slackadays/Clipboard][Clipboard]] :to_think:

****** Greeter

#+begin_src nix :tangle modules/sway/system/greeter.nix
{ pkgs, lib, config, ... }:
{
#+end_src

I am using [[https://sr.ht/~kennylevinsen/greetd/][greetd]] as the login manager with [[https://github.com/apognu/tuigreet][tuigreet]] for the login screen.

To not break the tuigreet by kernel's logging, [[https://github.com/apognu/tuigreet/issues/17][two settings need to be set]]:

#+begin_src nix :tangle modules/sway/system/greeter.nix
  boot.kernelParams = [ "console=tty1" ];
  services.greetd = {
    enable = true;
    vt = 2;
#+end_src

Now to start the session itself. I prefer to have all logs managed by systemd, thus sway will be started in a ~systemd-cat~ wrapper.

#+begin_src nix :tangle modules/sway/system/greeter.nix
    settings = {
      default_session =
        let
          sway-launcher = pkgs.writeShellScript "sway-launcher" ''
            exec systemd-cat --identifier=sway ${pkgs.sway}/bin/sway ${if (config.networking.hostName == "neptunium") then "--unsupported-gpu" else ""}
          '';
        in
        {
          # taken from https://github.com/apognu/tuigreet
          # command = "${pkgs.greetd.tuigreet}/bin/tuigreet --time --cmd ${sway-launcher}";
          command = "${pkgs.greetd.tuigreet}/bin/tuigreet --time --cmd ${pkgs.zsh}/bin/zsh";
          user = "greeter";
        };
    };
  };
}

#+end_src

******* TODO theme tuigreet :to_think:

******* TODO Add zsh as an alternative session :feat:

According to ~tuigreet~ [[https://github.com/apognu/tuigreet][doc]]:

#+begin_quote
The available sessions are fetched from desktop files in /usr/share/xsessions and /usr/share/wayland-sessions. If you want to provide custom directories, you can set the --sessions arguments with a colon-separated list of directories for tuigreet to fetch session definitions some other place.
#+end_quote

Since I am not using the sessions directly, it may be worth declaring sessions for zsh and sway and manually creating two desktop files.

******* TODO Make CMD human-readable :feat:

See "zsh as an alternative session", the name of the session in the list may be taken from the file

**** Steam

#+begin_src nix :tangle modules/steam/default.nix
{ pkgs, ... }:
{
  # From gamescope PR
  nixpkgs.config.packageOverrides = pkgs: {
    steam = pkgs.steam.override {
      extraPkgs = pkgs: with pkgs; [
        xorg.libXcursor
        xorg.libXi
        xorg.libXinerama
        xorg.libXScrnSaver
        libpng
        libpulseaudio
        libvorbis
        stdenv.cc.cc.lib
        libkrb5
        keyutils
      ];
    };
  };
  environment.systemPackages = with pkgs; [ steam gamescope ];
  # Steam needs this, otherwise there's an error Assertion Failed: Error: glXChooseVisual failed
  hardware.opengl.driSupport32Bit = true;
  environment.variables = {
    WLR_NO_HARDWARE_CURSORS = "1";
  };
}
#+end_src


*** Hosts


**** TODO Add sample config with mocked out inputs :doc:

**** DONE Add nixpkgs config as an output :feat:
CLOSED: [2023-03-01 Wed 08:27]

** TODO Create check attribute to run checks before nixos-rebuild switches :feat:

** DONE Add ~/scratch~ as tmpfs to keep ~/tmp~ for, well, ~/tmp~ things :feat:
CLOSED: [2023-02-23 Thu 16:10]

* Outro :noexport:

Boring technical stuff

#+begin_src nix :tangle flake.nix
    };
  };
}
#+end_src

* Meta :noexport:
** TODO Hugo publish :chore:

;; eval: (add-hook 'after-save-hook 'org-hugo-export-to-md t t)
** TODO Check all packages that are installed through system.environmentPackages - maybe move them to the user :chore:
** DONE Move to nix flake format to save time on tangling :chore:
CLOSED: [2022-12-12 Mon 19:37]
** DONE [#A] Make `nix flake check` pass :fix:
CLOSED: [2022-12-09 Fri 17:27]
** TODO Consider merging tmux here :feat:
That way I could reuse the configs on other machines
** TODO Merge sway here [0/0] :feat:
** DONE add a description of exposed modules :doc:
CLOSED: [2023-03-02 Thu 11:19]
** TODO Move to flake-parts :chore:
** DONE Add the project counters :chore:
CLOSED: [2023-03-02 Thu 11:25]
** TODO Figure out TODO export :chore:

Looks like ~tasks~ setting may do the trick:

https://orgmode.org/manual/Export-Settings.html

** Literate setup

*** Tag stats calculator

#+name: mktagblock
#+begin_src elisp
(require 'dash)
(require 's)

(defun org-freq-count (search targets &optional cmp)
  (let ((cmp (if (functionp cmp)
                 cmp
               (lambda (a b) nil))))

    (mapcar (lambda (x)
              (list x (length (org-map-entries t (format search x) nil))))
            (sort
             (delete-dups
              (-filter #'stringp targets))
             cmp)
            )))

(defun org--tagblock-all-tags ()
  (-filter #'stringp (-map #'car (append
                                  (org-get-buffer-tags)
                                  org-tag-alist
                                  org-tag-persistent-alist))))

(defun org-write-freq-count (search targets name)
  (insert (s-concat
           (if name (insert (format "#+name: %s\n" name)))
           (mapconcat
            (lambda (x) (format "| %s | %s |" (nth 0 x) (nth 1 x)))
            (org-freq-count search targets)
            "\n")))
  (org-table-align))

(defun org-dblock-write:tagblock (params)
  (let ((todo (plist-get params :todo))
        (tags (or (plist-get params :tags) (org--tagblock-all-tags)))
        (label (plist-get params :label))
        (caption (plist-get params :caption)))
    (when caption (insert (format "#+caption: %s\n" caption)))
    (org-write-freq-count (cond ((equal todo t)
                                 (format "%%s/%s" (mapconcat 'identity
                                                             org-not-done-keywords
                                                             "|"
                                                             )))
                                ((listp todo)
                                 (format "%%s/%s" (mapconcat 'identity
                                                             todo
                                                             "|"
                                                             )))
                                (t "%s"))
                          tags
                          label)))

;;; tagblock definition ends here
#+end_src

#+RESULTS: mktagblock
: org-dblock-write:tagblock



*** Local variables

A few scripts to be automatically run:

- Before the file is saved - tangle all code blocks
- After file is saved - run ~nix fmt~ once

;; Local Variables:
;; eval: (progn (org-babel-goto-named-src-block "mkTagblock") (org-babel-execute-src-block) (outline-hide-sublevels 1))
;; eval: (add-hook 'before-save-hook (lambda ()(org-update-all-dblocks)) nil t)
;; eval: (add-hook 'before-save-hook (lambda ()(org-babel-tangle)) nil t)
;; eval: (add-hook 'after-save-hook (lambda ()(shell-command "nix fmt")) nil t)
;; End:
