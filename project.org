#+TITLE: My machine configs
#+AUTHOR: Vladimir Timofeenko
#+EMAIL: id@vtimofeenko.com
#+DATE: <2022-11-09 Wed>
#+TAGS: fix(b) feat(f) doc(d) chore(c) to_think(t)
#+HEADER-ARGS:nix: :padline no

# TODO Not right now
# #+HUGO_BASE_DIR: ~/Documents/vtimofeenko.com/
# #+HUGO_SECTION: posts
# #+HUGO_LEVEL_OFFSET: 0
# #+HUGO_CODE_FENCE: nil
# #+EXPORT_FILE_NAME: TODO:

* Project structure

- `project.org` :: file, from which everything gets tangled
- `hosts/` :: directory where per-machine configs are stored
- `modules/` :: top-level directory to contain all categories of modules

* Intro :noexport:

Boring technical stuff

#+begin_src nix :tangle flake.nix
{
  description = "NixOS configuration by Vladimir Timofeenko";
#+end_src

* Inputs
:PROPERTIES:
:CATEGORY: INPUTS
:END:

#+begin_src nix :tangle flake.nix
  inputs = {
    nixpkgs.url = "nixpkgs/nixos-22.11";
    nixos-hardware.url = "github:NixOS/nixos-hardware/master";
    home-manager.url = "github:rycee/home-manager/release-22.11";
    agenix.url = "github:ryantm/agenix";

    # Theming and stuff
    base16 = {
      url = "github:SenchoPens/base16.nix";
      # One input only
      inputs.nixpkgs.follows = "nixpkgs";
    };

    color_scheme = {
      url = "github:ajlende/base16-atlas-scheme";
      flake = false;
    };
    private-config = {
      url = "git+ssh://gitea@gitea.srv.vtimofeenko.com/spacecadet/private-flake.git";
      inputs = {
        agenix.follows = "agenix";
        nixpkgs.follows = "nixpkgs";
      };
    };
    my-tmux = {
      url = "github:VTimofeenko/tmux-flake";
      inputs = {
        nixpkgs.follows = "nixpkgs";
        base16.follows = "base16";
        color_scheme.follows = "color_scheme";
      };
    };

    my-nvim-flake.url = "github:VTimofeenko/nvim-flake";

    my-sway-config = {
      url = "git+file:///home/spacecadet/code/sway-flake?ref=master";
      inputs = {
        base16.follows = "base16";
        color-scheme.follows = "color_scheme";
      };
    };
    # nur.url = "github:nix-community/NUR";
    my-doom-config = {
      url = "git+ssh://gitea@gitea.srv.vtimofeenko.com/spacecadet/doom-config.git";
    };
    wg-namespace-flake = {
      url = "git+ssh://gitea@gitea.srv.vtimofeenko.com/spacecadet/wireguard-namespace-flake.git";
      inputs.nixpkgs.follows = "nixpkgs";
    };

    infra = {
      url = "git+ssh://gitea@gitea.srv.vtimofeenko.com/spacecadet/infra-hosts.git";
      flake = false;
    };
  };
#+end_src

*** CNCL Consider dropping nixos-hardware and merging everything here by hand :chore:
CLOSED: [2022-12-09 Fri 17:25]

*** DONE Make sure all inputs of base16 are tracking other inputs :chore:
CLOSED: [2022-12-12 Mon 19:39]

*** DONE Unify naming scheme (some inputs are called "my-", others - "vt-") :chore:
CLOSED: [2022-12-12 Mon 19:43]

*** DONE Evaluate vt-colors input :to_think:
CLOSED: [2022-12-12 Mon 19:45]

*** DONE Move all path:// inputs to at least git+file, ideally - git+ssh on gitea :chore:
CLOSED: [2022-12-14 Wed 21:54]

* Outputs
:PROPERTIES:
:header-args:nix: :tangle flake.nix
:END:

** Intro
First, the plumbing:

#+begin_src nix
outputs = inputs@{ nixpkgs
                 , nixos-hardware
                 , home-manager
                 , agenix
                 , my-nvim-flake
                 , private-config
                 , my-sway-config
                 , ...
                 }:
#+end_src

I am planning to use the same set of overlays with all my machines:

#+begin_src nix
let
  system = "x86_64-linux";
  pkgs = import nixpkgs {
    inherit system;
    config = { allowUnfree = true; };
    overlays = [
      # nur.overlay
      (final: prev: {
        my_nvim = my-nvim-flake.defaultPackage."${system}";
      })
      my-sway-config.overlays.default
    ];
  };
  commonModulesFromInputs = [
    # Enable secrets management
    agenix.nixosModules.default
    home-manager.nixosModules.home-manager
    inputs.my-tmux.nixosModule
    {
      programs.vt-zsh = {
        starship_enable = true;
        direnv_enable = true;
        gpg_enable = true;
        enableAnyNixShell = true;
      };
    }
    {
      home-manager.users.spacecadet = my-sway-config.nixosModules.default;
    }
    {
      home-manager.users.spacecadet = { ... }: {
        wayland.windowManager.sway.config = {
          # Restore non-vm modifier
          modifier = "Mod4";
          # Output configuration
          output = {
            "eDP-1" = { "scale" = "1"; };
          };
        };
        vt-sway.enableBrightness = true;
      };
    }
    my-sway-config.nixosModules.system
    {
      # Needed, otherwise error
      # error: cannot look up '<nixpkgs>' in pure evaluation mode
      home-manager.useGlobalPkgs = true;
      home-manager.useUserPackages = true;
      home-manager.users.spacecadet.home.stateVersion = "22.05";
    }
    # My emacs module
    {
      home-manager.users.spacecadet = inputs.my-doom-config.nixosModules.default;
    }
    inputs.wg-namespace-flake.nixosModules.default
    private-config.nixosModules.commonNodeModule
  ];

  commonCustomModules = [
    ./modules/applications
    ./modules/common
    ./modules/development
    ./modules/development/cross-compile.nix
    ./modules/development/virtualization.nix
    ./modules/hardware/dygma.nix
    ./modules/hardware/disks.nix
    ./modules/hardware/printer.nix
    ./modules/hardware/scanner.nix
    ./modules/zsh

    # Network
    ./modules/network/common_lan.nix
    ./modules/network/lan-wifi.nix
  ];
  # Function to keep everything similar
  mkMyModules = list: list ++ commonModulesFromInputs ++ commonCustomModules;
in
#+end_src

Now for the outputs, which will (for now) only contain ~nixosConfigurations~:

#+begin_src nix
{
  nixosConfigurations = {
#+end_src

** Modules

Modules will be divided into categories represented as directories

*** Common -- catch-all

General module that includes all the things:

#+begin_src nix :tangle modules/common/default.nix
{ ... }:
{
  imports = [
    ./flakes.nix
    ./fonts.nix
    ./user.nix
    ./utils.nix
    ./zsh.nix
  ];
  time.timeZone = "America/Los_Angeles";
  # The global useDHCP flag is deprecated, therefore explicitly set to false here.
  # Per-interface useDHCP will be mandatory in the future, so this generated config
  # replicates the default behaviour.
  networking.useDHCP = false;
  # Allow unfree packages across the board
  nixpkgs.config.allowUnfree = true;
}
#+end_src

I am using z shell on all machines where I have some need for an interactive login. The z shell configuration is done in a separate flake (~my-zsh~) which provides the zsh configuration encapsulated in a module.

#+begin_src nix :tangle modules/common/zsh.nix
{ pkgs, ... }:
{
    users.users.root.shell = pkgs.zsh;
}

#+end_src

To configure Nix-the-package-manager:

#+begin_src nix :tangle modules/common/flakes.nix
# From https://nixos.wiki/wiki/Flakes
{ pkgs, ... }: {
  nix = {
    extraOptions = ''
      # Quicker timeout for inaccessible binary caches
      connect-timeout = 5
      # Enable flakes
      experimental-features = nix-command flakes
      # Do not warn on dirty git repo
      warn-dirty = false
      # Automatically optimize store
      auto-optimise-store = true
    '';
  };
}
#+end_src

Some common utilities I find myself using all the time as all users on the system:

#+begin_src nix :tangle modules/common/utils.nix
{ pkgs, ... }:
{
  environment.systemPackages = with pkgs; [
    htop
    curl
    wget
    fd
    inetutils  # for telnet
    ripgrep
    lsof
    dig
    nftables
    unzip
    tcpdump
    jq
  ];
}
#+end_src

**** CNCL Check if flakes.nix is still necessary post 22.11 :chore:
CLOSED: [2022-12-14 Wed 21:56]

**** User configuration

#+begin_src nix :tangle modules/common/user.nix
{ pkgs, ... }:

{
  users.users.spacecadet = {
    isNormalUser = true;
    extraGroups = [ "wheel" "lp" ];
    shell = pkgs.zsh;
  };
  home-manager.users.spacecadet = { pkgs, ... }: {
    home.packages = with pkgs; [
      ncspot
      pavucontrol
      blueman
      libreoffice
      firefox
      brave
      gthumb
      nextcloud-client
    ];
    programs.browserpass.enable = true;
    programs.password-store = {
      enable = true;
      package = pkgs.pass.withExtensions (exts: [ exts.pass-otp ]);
    };
    home.file.".icons/default".source = "${pkgs.vanilla-dmz}/share/icons/Vanilla-DMZ";
  };
}
#+end_src

**** Font configuration

#+begin_src nix :tangle modules/common/fonts.nix
{ pkgs, ... }:

{
  fonts = {
    fonts = with pkgs; [
      (nerdfonts.override { fonts = [ "JetBrainsMono" ]; })
      roboto
      twitter-color-emoji
      font-awesome
    ];
    fontconfig = {
      defaultFonts = {
        monospace = [ "JetBrainsMono Nerd Font" ];
        sansSerif = [ "Roboto" ];
        serif     = [ "Roboto" ];
        emoji     = [ "Twitter Color Emoji" ];
      };
    };
  };
}
#+end_src

*** Applications
**** Common

#+begin_src nix :tangle modules/applications/default.nix
{ ... }:

{
  imports = [
    ./firejail.nix
    ./flatpak.nix
    ./media.nix
    ./zathura.nix
    ./calibre.nix
  ];
}

#+end_src
**** Firejail
#+begin_src nix :tangle modules/applications/firejail.nix
{ pkgs, lib, ... }:

{
  programs.firejail.enable = true;
  programs.firejail.wrappedBinaries = {
    thunderbird = {
      executable = "${lib.getBin pkgs.thunderbird}/bin/thunderbird";
      profile = "${pkgs.firejail}/etc/firejail/thunderbird.profile";
    };
    telegram-desktop = {
      executable = "${lib.getBin pkgs.tdesktop}/bin/telegram-desktop";
      profile = "${pkgs.firejail}/etc/firejail/telegram.profile";
    };
  };
  # Firejail-specific desktop shortcuts
  home-manager.users.spacecadet = { pkgs, ... }: {
    xdg.desktopEntries = {
      thunderbird = {
        # Taken from Thunderbird v 91.5.0
        name = "Thunderbird";
        comment = "ðŸ¦ŠFirejailed";
        genericName = "Mail Client";
        exec = "thunderbird %U";
        icon = "thunderbird";
        terminal = false;
        mimeType = [ "text/html" "text/xml" "application/xhtml+xml" "application/vnd.mozilla.xul+xml" "x-scheme-handler/http" "x-scheme-handler/https" "x-scheme-handler/ftp" ];
      };
      telegram = {
        # Taken from Telegram v 3.1.11
        name = "Telegram";
        comment = "ðŸ¦ŠFirejailed";
        exec = "telegram-desktop -- %u";
        icon = "telegram";
        terminal = false;
        mimeType = [ "x-scheme-handler/tg" ];
      };
    };
  };
}
#+end_src

***** TODO Fix the icons :fix:
**** Flatpak

#+begin_src nix :tangle modules/applications/flatpak.nix
{ ... }:

{
  services.flatpak.enable = true;
  xdg.portal.enable = true;
}

#+end_src
**** Media
#+begin_src nix :tangle modules/applications/media.nix
{ pkgs, ... }:

{
  environment.systemPackages = with pkgs; [
    # Video
    yt-dlp mpv
  ];
  # Configuration files
  environment.etc = {
    # judging by strace, mpv on NixOS expects it in etc.
    "mpv/mpv.conf".text = ''
      hwdec
      save-position-on-quit
    '';
    "mpv/input.conf".text = ''
      WHEEL_UP add volume 5
      # mouse wheel for sound control
      WHEEL_DOWN add volume -5
    '';
  };
}
#+end_src
**** Zathura
#+begin_src nix :tangle modules/applications/zathura.nix
{ ... }:

{
  home-manager.users.spacecadet = { ... }: {
    programs.zathura = {
    enable = true;
    options = {
      # Allows zathura to use system clipboard
      selection-clipboard = "clipboard";
    };
    };
  };
}
#+end_src
**** Calibre

#+begin_src nix :tangle modules/applications/calibre.nix
{ pkgs, ... }:
{
  home-manager.users.spacecadet = { ... }: {
      home.packages = [ pkgs.calibre ];
    };
}
#+end_src

***** TODO Add mountpoint for the device :feat:

*** Development -- for development purposes

**** Default

By default, only editor and git should be imported. The rest of the configs are imported on per-host basis.

#+begin_src nix :tangle modules/development/default.nix
{ ... }:

{
  imports = [
    ./editor.nix
    ./git.nix
  ];
}
#+end_src
**** Git config
First, the git config

#+begin_src nix :tangle modules/development/git.nix
{ pkgs, ... }:
{
  environment.systemPackages = with pkgs; [
    git
    lazygit
    git-crypt
  ];
  programs.git = {
    enable = true;
    config = {
      user = {
        name = "Vladimir Timofeenko";
        email = "id@vtimofeenko.com";
      };
      alias = {
        ci = "commit";
        st = "status";
        co = "checkout";
        rv = "remote --verbose";
        unstage = "reset HEAD --";
      };
      url = {
        "https://github.com/" = {
          insteadOf = [
            "gh:"
            "github:"
          ];
        };
      };
    };
  };
}
#+end_src

***** TODO lazygit colors :feat:

**** Console editor

I generally use emacs, but when in console - I use a build of neovim that's provided as an input:

#+begin_src nix :tangle modules/development/editor.nix
{ pkgs, config, ... }:

{
  environment.systemPackages = [ pkgs.my_nvim ];
  environment.variables.SUDO_EDITOR = "nvim";
  environment.variables.EDITOR = "nvim";
}
#+end_src

**** Virtualization
I occasionally need full blown VMs to emulate stuff:

#+begin_src nix :tangle modules/development/virtualization.nix
{ pkgs, ... }:

{
  virtualisation.libvirtd.enable = true;
  programs.dconf.enable = true;
  environment.systemPackages = with pkgs; [ virt-manager ];
  users.users.spacecadet.extraGroups = [ "libvirtd" ];
}
#+end_src

**** Cross compilation

#+begin_src nix :tangle modules/development/cross-compile.nix
{ ... }:
{
  boot.binfmt.emulatedSystems = [ "aarch64-linux" ];
}
#+end_src

*** Hardware -- specific hardware modules support/config
**** Disks
:PROPERTIES:
:header-args:nix: :tangle modules/hardware/disks.nix
:END:

#+begin_src nix
{ pkgs, ... }:

{
#+end_src

Since I am running on SSDs, worth enabling timed fstrim:

#+begin_src nix
  services.fstrim.enable = true;
#+end_src

I like having a temporary directory  that is separate from ~/tmp~ for random things I don't need to keep around. It can live in ~/scratch~:

#+begin_src nix
  systemd.tmpfiles.rules =
    [
      "d /scratch 1777 spacecadet users 10d"
    ];
#+end_src


#+begin_src nix
}
#+end_src
**** Scanner

#+begin_src nix :tangle modules/hardware/scanner.nix
{ pkgs, ... }:

{
  hardware.sane.enable = true;
  hardware.sane.extraBackends = [ pkgs.hplipWithPlugin ];
  services.avahi.enable = true;
  services.avahi.nssmdns = true;
  users.users.spacecadet.extraGroups = [ "scanner" ];
}
#+end_src
**** Printer

#+begin_src nix :tangle modules/hardware/printer.nix
{ pkgs, ... }:
{
  services.printing.enable = true;
  services.printing.drivers = [ pkgs.hplipWithPlugin ];
}
#+end_src
**** Dygma

#+begin_src nix :tangle modules/hardware/dygma.nix
{ lib, pkgs, ... }:

{
  # Taken from https://github.com/Dygmalab/Bazecor/blob/159eed1d37f3fd1fbf5c17023c12bb683b778281/src/main/index.js#L223
  services.udev.extraRules = ''
    SUBSYSTEMS=="usb", ATTRS{idVendor}=="1209", ATTRS{idProduct}=="2201", GROUP="users", MODE="0666"
    SUBSYSTEMS=="usb", ATTRS{idVendor}=="1209", ATTRS{idProduct}=="2200", GROUP="users", MODE="0666"
  '';
}
#+end_src
***** TODO Add the configurator utility - either firejailed appimage or flatpak :feat:


*** Network -- reusable network configurations

Common network settings:

#+begin_src nix :tangle modules/network/common_lan.nix
{ lib, infra, ...  }:
let
  infraMetadata = lib.importTOML (infra + "/infra.toml");
  inherit (infraMetadata.network) lan;
in
{
  networking.enableIPv6 = false;
}
#+end_src

#+begin_src nix :tangle modules/network/lan-wifi.nix
{ config, lib, infra, private-config, ... }:
let
  infraMetadata = lib.importTOML (infra + "/infra.toml");
  inherit (infraMetadata.network) lan;
  local_address = lan.first_octets + "." + lan."${config.networking.hostName}".ip;
in
{
  imports = [
    private-config.nixosModules.home-wireless-fast-client
    # NOTE: should be kept commented until I need it
    # private-config.nixosModules.phone-shared-network
  ];
  # Disable autogenerated names
  networking.usePredictableInterfaceNames = false;

  # networking.interfaces.wifi-lan = {
  #   useDHCP = false;
  #   ipv4.addresses = [
  #     {
  #       address = local_address;
  #       prefixLength = lan.prefix;
  #     }
  #   ];
  # };
  # Systemd-networkd enabled
  networking.useNetworkd = true;

  systemd.network.networks = {
    "10-wifi-lan" = {
      enable = true;
      name = "wifi-lan";
      dns = lan.dns_servers;
      address = [ local_address ];
      gateway = [ lan.defaultGateway ];
      # Search domain goes here
      domains = [ lan.domain ];
      networkConfig = {
        DHCP = "no";
        DNSSEC = "yes";
        DNSOverTLS = "no";
        # Disable ipv6 explicitly
        LinkLocalAddressing = "ipv4";
      };
    };
  };
  # I am not using llmnr in my LAN
  services.resolved.llmnr = "false";

  # Any interface being up should be OK
  systemd.network.wait-online.anyInterface = true;
}
#+end_src

**** TODO generate routing table here :feat:

*** Zsh

I use Z shell as my interactive shell of choice. The config described here:

1. (optionally) uses [[https://starship.rs/][starship]] to set up the prompt
2. Highlights syntax in command line
3. Automatically suggests command from history
4. Shares history between currently running sessions
5. (optionally) uses gpg-agent for ssh authentication
6. (optionally) sets up [[https://direnv.net/][direnv]]. ~.direnv~ can immediately create a Nix developemnt shell from a local flake.nix if it contains ~use flake~.
7. Allows editing the current command in $EDITOR by hitting ESC and E: [[01-vim-edit][01-vim-edit]]
8. Sets up simple way to change directory through stack of last visited dirs (~cd +1~, ~+2~, ~+3~, ...): [[*02-cd][02-cd]]
9. Creates a mechanism to use bookmarks by using double @ symbol: bookmarks: [[bookmarks][bookmarks]]
10. Depending on the mode (typing vs editing in vim), shape of the cursor changes: [[*cursor_mode][cursor_mode]]

**** Main configuration

I am sharing my zsh config with several machines and users. Certain settings of my zsh config can be turned on and off in the importing config:

#+begin_src nix :tangle modules/zsh/default.nix
{ lib, pkgs, config, ... }:

with lib;
let
  cfg = config.programs.vt-zsh;
in
{
  options.programs.vt-zsh = {
    starship_enable = mkOption {
      default = true;
      description = "Whether to enable starship.";
      type = lib.types.bool;
    };
    direnv_enable = mkEnableOption "enable direnv";
    gpg_enable = mkEnableOption "enable gpg-agent";
    enableAnyNixShell = mkEnableOption "enable any-nix-shell";
  };
#+end_src

First, some packages that I am using on all machines. Direnv is included conditionally since I need to run it interactively (~direnv allow .~).

#+begin_src nix :tangle modules/zsh/default.nix
  config = {
    environment.systemPackages = with pkgs; [
      fzf
      killall
      bat
      # the next line conditionally installs direnv if it is enabled
      # just having pkgs.direnv is not enough, it does not get added to the path
    ] ++ (if cfg.direnv_enable then [ pkgs.direnv ] else [ ]);
#+end_src

The actual zsh configuration happens in ~programs.zsh~ attrset.

#+begin_src nix :tangle modules/zsh/default.nix
    programs.zsh = {
      enable = true;
      enableCompletion = true;
      autosuggestions.enable = true;
      syntaxHighlighting = {
        enable = true;
      };
      shellAliases = {
        e = "$EDITOR"; # looks like 'vim' is needed here so that proper vimrc is being picked up
        nvim = "$EDITOR";
        vim = "$EDITOR";
        ls = "${pkgs.exa}/bin/exa -h --group-directories-first --icons";
        l = "ls";
        ll = "ls -l";
        la = "ls -al";
        ka = "${pkgs.killall}/bin/killall";
        mkd = "mkdir -pv";
        ga = "${pkgs.git}/bin/git add";
        gau = "ga -u";
        grep = "grep --color=auto";
        mv = "mv -v";
        rm = "${pkgs.coreutils}/bin/rm -id";
        vidir = "${pkgs.moreutils}/bin/vidir --verbose";
        ccopy = "${pkgs.wl-clipboard}/bin/wl-copy";
        syu = "systemctl --user";
        cde = "cd /etc/nixos";
        lg = "lazygit";
        # Colorize IP output
        ip = "ip -c";
      };
      setOptions = [
        "INTERACTIVE_COMMENTS" # allow bash-style comments
        # history
        "BANG_HIST" # enable logging !!-like commands
        "EXTENDED_HISTORY" # Write the history file in the ":start:elapsed;command" format.
        "INC_APPEND_HISTORY" # Write to the history file immediately, not when the shell exits.
        "SHARE_HISTORY" # Share history between all sessions.
        "HIST_EXPIRE_DUPS_FIRST" # Expire duplicate entries first when trimming history.
        "HIST_IGNORE_DUPS" # Don't record an entry that was just recorded again.
        "HIST_IGNORE_ALL_DUPS" # Delete old recorded entry if new entry is a duplicate.
        "HIST_FIND_NO_DUPS" # Do not display a line previously found.
        "HIST_IGNORE_SPACE" # Don't record an entry starting with a space.
        "HIST_SAVE_NO_DUPS" # Don't write duplicate entries in the history file.
        "HIST_REDUCE_BLANKS" # Remove superfluous blanks before recording entry.
        "HIST_VERIFY" # Don't execute immediately upon history expansion.
        "HIST_FCNTL_LOCK" # enable fcntl syscall for saving history
        # cd management
        "AUTO_CD" # automatically cd into directory
      ];
      interactiveShellInit =
        ''
        # Enable vim editing of command line
        ${builtins.readFile ./plugins/01-vim-edit.zsh}
        # Enable cd +1..9 to go back in dir stack
        ${builtins.readFile ./plugins/02-cd.zsh}
        # fzf bindings
        source ${pkgs.fzf}/share/fzf/key-bindings.zsh

        # Word Navigation shortcuts
        bindkey "^A" vi-beginning-of-line
        bindkey "^E" vi-end-of-line
        bindkey "^F" end-of-line

        # ctrl+arrow for word jupming
        bindkey "^[[1;5C" forward-word
        bindkey "^[[1;5D" backward-word

        # alt+f forward a word
        bindkey "^[f" forward-word

        # alt+b back a word
        bindkey "^[b" backward-word
        # working backspace
        bindkey -v '^?' backward-delete-char

        # Use vim keys in tab complete menu
        zmodload zsh/complist
        bindkey -M menuselect 'h' vi-backward-char
        bindkey -M menuselect 'k' vi-up-line-or-history
        bindkey -M menuselect 'l' vi-forward-char
        bindkey -M menuselect 'j' vi-down-line-or-history
        bindkey -M menuselect '^ ' accept-line

        # Add entry by "+" but do not exit menuselect
        bindkey -M menuselect "+" accept-and-menu-complete
        # Color the completions
        autoload -Uz compinit
        zstyle ':completion:*' matcher-list 'm:{[:lower:][:upper:]}={[:upper:][:lower:]}' 'm:{[:lower:][:upper:]}={[:upper:][:lower:]} l:|=* r:|=*' 'm:{[:lower:][:upper:]}={[:upper:][:lower:]} l:|=* r:|=*' 'm:{[:lower:][:upper:]}={[:upper:][:lower:]} l:|=* r:|=*'
        zstyle ':completion:*' list-colors ''${(s.:.)LS_COLORS}
        zstyle ':completion:*' menu select

        # Automatically escape urls when pasting
        autoload -Uz url-quote-magic
        zle -N self-insert url-quote-magic
        autoload -Uz bracketed-paste-magic
        zle -N bracketed-paste bracketed-paste-magic

        # Custom plugins can be quickly loaded if fpath is extended:
        fpath=(${./plugins} $fpath)
        # Bookmarks by "@@"
        autoload -Uz bookmarks.zsh && bookmarks.zsh
        # Cursor mode block <> beam
        autoload -Uz cursor_mode.zsh && cursor_mode.zsh

        # To use openpgp cards
        ${if cfg.gpg_enable
        then
          ''
          if (( $EUID != 0 )); then
            export GPG_TTY="$(tty)"
            ${pkgs.gnupg}/bin/gpg-connect-agent /bye
            export SSH_AUTH_SOCK="/run/user/$UID/gnupg/S.gpg-agent.ssh"
          fi
          ''
        else
          toString null
        }
        # alias that creates the directory and changes into it
        mkcd(){ mkdir -p "$@" && cd "$@"; }
      '';
      promptInit = ''
        ${if cfg.starship_enable
        then
          "eval \"$(${pkgs.starship}/bin/starship init zsh)\""
        else
          # reasonable default prompt
          "PROMPT=\"%F{white}%~ %(!.%B%F{red}#.%B%F{blue}>)%f%b\u00A0\""
        }
        ${if cfg.direnv_enable
        then
          "eval \"$(${pkgs.direnv}/bin/direnv hook zsh)\""
        else
          toString null
        }
        ${if cfg.enableAnyNixShell
          then
            "${pkgs.any-nix-shell}/bin/any-nix-shell zsh --info-right | source /dev/stdin"
          else
            toString null
         }
        # Make comments visible on default background
        ZSH_HIGHLIGHT_STYLES[comment]='none'
      '';
    };
  };
}
#+end_src

**** ZSH modules

***** 01-vim-edit

#+begin_src sh :tangle modules/zsh/plugins/01-vim-edit.zsh
# vim style editing
bindkey -v

autoload edit-command-line; zle -N edit-command-line
bindkey -M vicmd E edit-command-line  # uppercase E to edit the current line
#+end_src

***** 02-cd

#+begin_src sh :tangle modules/zsh/plugins/02-cd.zsh
# File that sets the behavior of cd command
setopt autocd

# dirs stack manipulation
setopt AUTO_PUSHD           # Push the current directory visited on the stack.
setopt PUSHD_IGNORE_DUPS    # Do not store duplicates in the stack.
setopt PUSHD_SILENT         # Do not print the directory stack after

# Enabled cd +X to change directory to somewhere in stack
alias d='dirs -v' # prints stack of directories
for index ({1..9}) alias "$index"="cd +${index}"; unset index
#+end_src

***** bookmarks

#+begin_src sh :tangle modules/zsh/plugins/bookmarks.zsh
# -*- sh -*-
autoload is-at-least
# Source: https://github.com/vincentbernat/zshrc/blob/master/rc/bookmarks.zsh
# Changed by Vladimir Timofeenko, changed MARKPATH to local share for persistence

# Handle bookmarks. This uses the static named directories feature of
# zsh. Such directories are declared with `hash -d
# name=directory`. Both prompt expansion and completion know how to
# handle them. We populate the hash with directories.
#
# With autocd, you can just type `~-bookmark`. Since this can be
# cumbersome to type, you can also type `@@` and this will be turned
# into `~-` by ZLE.

is-at-least 4.3.12 && () {
    MARKPATH="${HOME}/.local/share/zsh/bookmarks"

    # Add some static entries
    hash -d log=/var/log
    hash -d doc=/usr/share/doc

    # Populate the hash
    for link ($MARKPATH/*(N@)) {
        hash -d -- -${link:t}=${link:A}
    }

    vbe-insert-bookmark() {
        emulate -L zsh
        LBUFFER=${LBUFFER}"~-"
    }
    zle -N vbe-insert-bookmark
    bindkey '@@' vbe-insert-bookmark

    # Manage bookmarks
    bookmark() {
        [[ -d $MARKPATH ]] || mkdir -p $MARKPATH
        if (( $# == 0 )); then
            # When no arguments are provided, just display existing
            # bookmarks
            for link in $MARKPATH/*(N@); do
                local markname=${(%):-%F{green}${link:t}%f}
                local markpath=${(%):-%F{blue}${link:A}%f}
                printf "%-30s â†’ %s\n" $markname $markpath
            done
        else
            # Otherwise, we may want to add a bookmark or delete an
            # existing one.
            local -a delete
            zparseopts -D d=delete
            if (( $+delete[1] )); then
                # With `-d`, we delete an existing bookmark
                command rm $MARKPATH/$1
            else
                # Otherwise, add a bookmark to the current
                # directory. The first argument is the bookmark
                # name. `.` is special and means the bookmark should
                # be named after the current directory.
                local name=$1
                [[ $name == "." ]] && name=${PWD:t}
                ln -s $PWD $MARKPATH/$name
                hash -d -- -${name}=${PWD}
            fi
        fi
    }
}
#+end_src

***** cursor_mode

#+begin_src sh :tangle modules/zsh/plugins/cursor_mode.zsh
cursor_mode() {
    # See https://ttssh2.osdn.jp/manual/4/en/usage/tips/vim.html for cursor shapes
    cursor_block='\e[2 q'

    cursor_beam='\e[6 q'

    function zle-keymap-select {
        if [[ ${KEYMAP} == vicmd ]] ||
            [[ $1 = 'block' ]]; then
            echo -ne $cursor_block
        elif [[ ${KEYMAP} == main ]] ||
            [[ ${KEYMAP} == viins ]] ||
            [[ ${KEYMAP} = '' ]] ||
            [[ $1 = 'beam' ]]; then
            echo -ne $cursor_beam
        fi
    }

    zle-line-init() {
        echo -ne $cursor_beam
    }

    zle -N zle-keymap-select
    zle -N zle-line-init
}

cursor_mode
#+end_src

***** TODO make a minimalistic vim config to edit the shell inline :feat:
- vim-surround
- shell syntax highlighting

**** STRT Rewrite in literal style :doc:

**** DONE Correct the options to use something like ~programs.vt-zsh~ :chore:
CLOSED: [2022-12-25 Sun 19:25]

**** DONE disable gpg if root? :chore:
CLOSED: [2023-02-08 Wed 08:20]

**** DONE Add any-nix-shell :feat:
CLOSED: [2023-02-08 Wed 08:25]
**** DONE Add bat :feat:
CLOSED: [2023-02-08 Wed 08:16]
**** DONE Add killall with an alias :feat:
CLOSED: [2023-02-08 Wed 08:12]

** Hosts

*** Uranium

This is an 11th gen Frame.work laptop.

**** Modules

***** Default
#+begin_src nix :tangle hosts/uranium/default.nix
{ config, pkgs, lib, ... }:

{
  imports = [
    ./frame.work.nix
  ];
  # Use the systemd-boot EFI boot loader.
  boot.loader.systemd-boot.enable = true;
  boot.loader.efi.canTouchEfiVariables = true;
  boot.tmpOnTmpfs = true;
  boot.tmpOnTmpfsSize = "8G";
  # Modules I want to ensure are there
  boot.initrd.availableKernelModules = [ "thunderbolt" "nvme" "usb_storage" "uas" ];
  boot.initrd.kernelModules = [ ];
  boot.kernelModules = [ "kvm-intel" "coretemp" ];
  boot.extraModulePackages = [ ];
  # Frame.work needs latest kernel for BT and Wi-Fi to work.
  boot.kernelPackages = pkgs.linuxPackages_latest;

  networking.hostName = "uranium";
  networking.useDHCP = false;

  fileSystems."/" =
    {
      device = "/dev/disk/by-uuid/cbaf293c-c8dc-4586-ba65-73cff3f24468";
      fsType = "ext4";
    };
  boot.initrd.luks.gpgSupport = true;

  boot.initrd.luks.devices."luks".device = "/dev/disk/by-uuid/c2e5cd09-b5d7-42cb-a78a-f549edfa0eb4";

  fileSystems."/boot" =
    {
      device = "/dev/disk/by-uuid/028E-BC0A";
      fsType = "vfat";
    };

  swapDevices = [ ];

  # This node was created in 21.11 days
  system.stateVersion = "21.11";

  # For brightness control
  users.users.spacecadet.extraGroups = [ "video" ];
  # bluetooth
  hardware.bluetooth.enable = true;
  services.blueman.enable = true;
  # pipewire config, from https://nixos.wiki/wiki/PipeWire
  security.rtkit.enable = true;
  services.pipewire = {
    enable = true;
    alsa.enable = true;
    alsa.support32Bit = true;
    pulse.enable = true;
    # If you want to use JACK applications, uncomment this
    #jack.enable = true;

    # use the example session manager (no others are packaged yet so this is enabled by default,
    # no need to redefine it in your config for now)
    #media-session.enable = true;
    media-session.config.bluez-monitor.rules = [
      {
        # Matches all cards
        matches = [{ "device.name" = "~bluez_card.*"; }];
        actions = {
          "update-props" = {
            "bluez5.reconnect-profiles" = [ "hfp_hf" "hsp_hs" "a2dp_sink" ];
            # mSBC is not expected to work on all headset + adapter combinations.
            "bluez5.msbc-support" = true;
            # SBC-XQ is not expected to work on all headset + adapter combinations.
            "bluez5.sbc-xq-support" = true;
          };
        };
      }
      {
        matches = [
          # Matches all sources
          { "node.name" = "~bluez_input.*"; }
          # Matches all outputs
          { "node.name" = "~bluez_output.*"; }
        ];
        actions = {
          "node.pause-on-idle" = false;
        };
      }
    ];
  };
  # battery management
  powerManagement = {
    enable = true;
    powertop.enable = true;
    cpuFreqGovernor = lib.mkDefault "powersave";
  };
  services.tlp = {
    enable = true;
    settings = {
        CPU_BOOST_ON_AC = 1;
        CPU_BOOST_ON_BAT = 0;
        CPU_SCALING_GOVERNOR_ON_AC = "performance";
        CPU_SCALING_GOVERNOR_ON_BAT = "powersave";
    };
  };
  # temperature management
  services.thermald.enable = true;
  environment.etc."sysconfig/lm_sensors".text = ''
    # Generated by sensors-detect on Mon Jan  3 23:34:14 2022
    # This file is sourced by /etc/init.d/lm_sensors and defines the modules to
    # be loaded/unloaded.
    #
    # The format of this file is a shell script that simply defines variables:
    # HWMON_MODULES for hardware monitoring driver modules, and optionally
    # BUS_MODULES for any required bus driver module (for example for I2C or SPI).

    HWMON_MODULES="coretemp"
  '';
  # Instead of archwiki, frame.work forums recommend this with s2idle

  # Hardware acceleration
  # Taken from https://nixos.wiki/wiki/Accelerated_Video_Playback
  nixpkgs.config.packageOverrides = pkgs: {
    vaapiIntel = pkgs.vaapiIntel.override { enableHybridCodec = true; };
  };
  hardware.opengl = {
    enable = true;
    extraPackages = with pkgs; [
      intel-media-driver # LIBVA_DRIVER_NAME=iHD
      vaapiIntel # LIBVA_DRIVER_NAME=i965 (older but works better for Firefox/Chromium)
      vaapiVdpau
      libvdpau-va-gl
    ];
  };
  services.fwupd = {
    enable = true;
    extraRemotes = [ "lvfs-testing" ];
  };
  environment.etc."fwupd/uefi_capsule.conf".text = lib.mkForce ''
    [uefi_capsule]
    OverrideESPMountPoint=/boot
    DisableCapsuleUpdateOnDisk=true
  '';
  # NOTE: fwupdmgr uses this to check the boot
  services.udisks2.enable = true;
  # NOTE: Wireless config is here for now, until refactoring of default.nix is done
  systemd.network.links."10-wifi-lan" = {
    matchConfig.PermanentMACAddress = "f8:b5:4d:d7:16:53";
    linkConfig.Name = "wifi-lan";
  };
}
#+end_src

***** Frame.work

The hardware configuration that was taken from nixos-hardware and slightly tweaked. I am not using deep sleep on this machine as it's very often plugged into the AC power.

#+begin_src nix :tangle hosts/uranium/frame.work.nix
{ config, lib, pkgs, nixos-hardware, ... }:

{
  imports = [
    nixos-hardware.nixosModules.common-cpu-intel
    nixos-hardware.nixosModules.common-pc-laptop
    nixos-hardware.nixosModules.common-pc-laptop-ssd
  ];
  # high-resolution display
  hardware.video.hidpi.enable = lib.mkDefault true;
  # NOTE: required for wifi to work
  hardware.enableRedistributableFirmware = true;
  hardware.cpu.intel.updateMicrocode = lib.mkDefault config.hardware.enableRedistributableFirmware;
  boot.kernelParams = [
    # For Power consumption
    # https://kvark.github.io/linux/framework/2021/10/17/framework-nixos.html

    # "mem_sleep_default=deep"
    # For Power consumption
    # https://community.frame.work/t/linux-battery-life-tuning/6665/156
    "nvme.noacpi=1"
  ];


  # Fix TRRS headphones missing a mic
  # https://community.frame.work/t/headset-microphone-on-linux/12387/3
  boot.extraModprobeConfig = ''
    options snd-hda-intel model=dell-headset-multi
  '';

  # For fingerprint support
  /* services.fprintd.enable = lib.mkDefault true; */

  # Custom udev rules
  services.udev.extraRules = ''
    # Fix headphone noise when on powersave
    # https://community.frame.work/t/headphone-jack-intermittent-noise/5246/55
    SUBSYSTEM=="pci", ATTR{vendor}=="0x8086", ATTR{device}=="0xa0e0", ATTR{power/control}="on"
    # Ethernet expansion card support
    ACTION=="add", SUBSYSTEM=="usb", ATTR{idVendor}=="0bda", ATTR{idProduct}=="8156", ATTR{power/autosuspend}="20"
  '';

  # Mis-detected by nixos-generate-config
  # https://github.com/NixOS/nixpkgs/issues/171093
  # https://wiki.archlinux.org/title/Framework_Laptop#Changing_the_brightness_of_the_monitor_does_not_work
  hardware.acpilight.enable = lib.mkDefault true;

  # Needed for desktop environments to detect/manage display brightness
  hardware.sensor.iio.enable = lib.mkDefault true;

  # HiDPI
  # Leaving here for documentation
  # hardware.video.hidpi.enable = lib.mkDefault true;

  # Fix font sizes in X
  # services.xserver.dpi = 200;

}
#+end_src

****** DONE Figure out why nixos-hardware imports trigger infinite recursion :fix:
CLOSED: [2022-12-09 Fri 17:26]

***** TODO Break up the default.nix module into smaller pieces - it's too long :chore:

**** Flake config

#+begin_src nix :tangle flake.nix
    uranium = nixpkgs.lib.nixosSystem {
      inherit pkgs system;
      modules = mkMyModules [
        ./hosts/uranium
        private-config.nixosModules.management-network-control-node
        private-config.nixosModules.wg-namespace-config
      ];
      # NOTE:
      # This makes the inputs propagate into the modules and allows modules to refer to the inputs
      # See network configuration as an example
      specialArgs = inputs;
    };
  };
#+end_src

***** DONE [#A] Review the flake :chore:
CLOSED: [2022-12-12 Mon 19:21]

**** DONE fwupd enable :feat:
CLOSED: [2022-12-23 Fri 14:53]

See [[https://fwupd.org/lvfs/devices/work.frame.Laptop.TGL.BIOS.firmware][this link]]

** Formatter
I prefer nixpkgs-fmt formatter. Using ~formatter~ output, one can be specified in the flake itself:

#+begin_src nix :tangle flake.nix
    formatter.x86_64-linux = nixpkgs.legacyPackages.x86_64-linux.nixpkgs-fmt;
#+end_src

** nixosModules

this section contains the modules that can be reused without using the rest of the configuration. Modules can be imported en massed by importing ~nixosModules.default~ from this flake. Alternatively individual modules can be imported on their own.

~nixosModules~ is a recursive attrset which allows me to refer to other attributes when constructing default module's imports:

#+begin_src nix :tangle flake.nix
    nixosModules = rec {
      default = { ... }: {
        imports = [
          zsh
        ];
      };
      zsh = import ./modules/zsh;
    };
#+end_src

*** TODO Add sample config with mocked out inputs :doc:

*** TODO Add nixpkgs config as an output :feat:

** TODO Create check attribute to run checks before nixos-rebuild switches :feat:

** DONE Add ~/scratch~ as tmpfs to keep ~/tmp~ for, well, ~/tmp~ things :feat:
CLOSED: [2023-02-23 Thu 16:10]

* Outro :noexport:

Boring technical stuff

#+begin_src nix :tangle flake.nix
  };
}
#+end_src

* Meta :noexport:
** TODO Hugo publish :chore:

;; eval: (add-hook 'after-save-hook 'org-hugo-export-to-md t t)
** TODO Check all packages that are installed through system.environmentPackages - maybe move them to the user :chore:
** DONE Move to nix flake format to save time on tangling :chore:
CLOSED: [2022-12-12 Mon 19:37]
** DONE [#A] Make `nix flake check` pass :fix:
CLOSED: [2022-12-09 Fri 17:27]
** TODO Consider merging tmux here :feat:
That way I could reuse the configs on other machines
** TODO Consider merging sway here :feat:
** TODO add a description of exposed modules :doc:

** Literate setup

A few scripts to be automatically run:

- Before the file is saved - tangle all code blocks
- After file is saved - run ~nix fmt~ once

;; Local Variables:
;; eval: (add-hook 'before-save-hook (lambda ()(org-babel-tangle)) nil t)
;; eval: (add-hook 'after-save-hook (lambda ()(shell-command "nix fmt")) nil t)
;; End:
